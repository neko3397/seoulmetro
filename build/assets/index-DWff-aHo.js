function Gw(r, t) { for (var s = 0; s < t.length; s++) { const o = t[s]; if (typeof o != "string" && !Array.isArray(o)) { for (const a in o) if (a !== "default" && !(a in r)) { const l = Object.getOwnPropertyDescriptor(o, a); l && Object.defineProperty(r, a, l.get ? l : { enumerable: !0, get: () => o[a] }) } } } return Object.freeze(Object.defineProperty(r, Symbol.toStringTag, { value: "Module" })) } (function () { const t = document.createElement("link").relList; if (t && t.supports && t.supports("modulepreload")) return; for (const a of document.querySelectorAll('link[rel="modulepreload"]')) o(a); new MutationObserver(a => { for (const l of a) if (l.type === "childList") for (const u of l.addedNodes) u.tagName === "LINK" && u.rel === "modulepreload" && o(u) }).observe(document, { childList: !0, subtree: !0 }); function s(a) { const l = {}; return a.integrity && (l.integrity = a.integrity), a.referrerPolicy && (l.referrerPolicy = a.referrerPolicy), a.crossOrigin === "use-credentials" ? l.credentials = "include" : a.crossOrigin === "anonymous" ? l.credentials = "omit" : l.credentials = "same-origin", l } function o(a) { if (a.ep) return; a.ep = !0; const l = s(a); fetch(a.href, l) } })(); function Gu(r) { return r && r.__esModule && Object.prototype.hasOwnProperty.call(r, "default") ? r.default : r } function Yw(r) { if (Object.prototype.hasOwnProperty.call(r, "__esModule")) return r; var t = r.default; if (typeof t == "function") { var s = function o() { return this instanceof o ? Reflect.construct(t, arguments, this.constructor) : t.apply(this, arguments) }; s.prototype = t.prototype } else s = {}; return Object.defineProperty(s, "__esModule", { value: !0 }), Object.keys(r).forEach(function (o) { var a = Object.getOwnPropertyDescriptor(r, o); Object.defineProperty(s, o, a.get ? a : { enumerable: !0, get: function () { return r[o] } }) }), s } var Fc = { exports: {} }, Ro = {}, Bc = { exports: {} }, Te = {};/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var Cp; function Jw() { if (Cp) return Te; Cp = 1; var r = Symbol.for("react.element"), t = Symbol.for("react.portal"), s = Symbol.for("react.fragment"), o = Symbol.for("react.strict_mode"), a = Symbol.for("react.profiler"), l = Symbol.for("react.provider"), u = Symbol.for("react.context"), f = Symbol.for("react.forward_ref"), p = Symbol.for("react.suspense"), m = Symbol.for("react.memo"), v = Symbol.for("react.lazy"), y = Symbol.iterator; function _(j) { return j === null || typeof j != "object" ? null : (j = y && j[y] || j["@@iterator"], typeof j == "function" ? j : null) } var S = { isMounted: function () { return !1 }, enqueueForceUpdate: function () { }, enqueueReplaceState: function () { }, enqueueSetState: function () { } }, E = Object.assign, b = {}; function k(j, U, re) { this.props = j, this.context = U, this.refs = b, this.updater = re || S } k.prototype.isReactComponent = {}, k.prototype.setState = function (j, U) { if (typeof j != "object" && typeof j != "function" && j != null) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables."); this.updater.enqueueSetState(this, j, U, "setState") }, k.prototype.forceUpdate = function (j) { this.updater.enqueueForceUpdate(this, j, "forceUpdate") }; function C() { } C.prototype = k.prototype; function T(j, U, re) { this.props = j, this.context = U, this.refs = b, this.updater = re || S } var P = T.prototype = new C; P.constructor = T, E(P, k.prototype), P.isPureReactComponent = !0; var I = Array.isArray, O = Object.prototype.hasOwnProperty, V = { current: null }, M = { key: !0, ref: !0, __self: !0, __source: !0 }; function R(j, U, re) { var H, se = {}, de = null, q = null; if (U != null) for (H in U.ref !== void 0 && (q = U.ref), U.key !== void 0 && (de = "" + U.key), U) O.call(U, H) && !M.hasOwnProperty(H) && (se[H] = U[H]); var le = arguments.length - 2; if (le === 1) se.children = re; else if (1 < le) { for (var ve = Array(le), be = 0; be < le; be++)ve[be] = arguments[be + 2]; se.children = ve } if (j && j.defaultProps) for (H in le = j.defaultProps, le) se[H] === void 0 && (se[H] = le[H]); return { $$typeof: r, type: j, key: de, ref: q, props: se, _owner: V.current } } function L(j, U) { return { $$typeof: r, type: j.type, key: U, ref: j.ref, props: j.props, _owner: j._owner } } function F(j) { return typeof j == "object" && j !== null && j.$$typeof === r } function K(j) { var U = { "=": "=0", ":": "=2" }; return "$" + j.replace(/[=:]/g, function (re) { return U[re] }) } var G = /\/+/g; function oe(j, U) { return typeof j == "object" && j !== null && j.key != null ? K("" + j.key) : U.toString(36) } function ae(j, U, re, H, se) { var de = typeof j; (de === "undefined" || de === "boolean") && (j = null); var q = !1; if (j === null) q = !0; else switch (de) { case "string": case "number": q = !0; break; case "object": switch (j.$$typeof) { case r: case t: q = !0 } }if (q) return q = j, se = se(q), j = H === "" ? "." + oe(q, 0) : H, I(se) ? (re = "", j != null && (re = j.replace(G, "$&/") + "/"), ae(se, U, re, "", function (be) { return be })) : se != null && (F(se) && (se = L(se, re + (!se.key || q && q.key === se.key ? "" : ("" + se.key).replace(G, "$&/") + "/") + j)), U.push(se)), 1; if (q = 0, H = H === "" ? "." : H + ":", I(j)) for (var le = 0; le < j.length; le++) { de = j[le]; var ve = H + oe(de, le); q += ae(de, U, re, ve, se) } else if (ve = _(j), typeof ve == "function") for (j = ve.call(j), le = 0; !(de = j.next()).done;)de = de.value, ve = H + oe(de, le++), q += ae(de, U, re, ve, se); else if (de === "object") throw U = String(j), Error("Objects are not valid as a React child (found: " + (U === "[object Object]" ? "object with keys {" + Object.keys(j).join(", ") + "}" : U) + "). If you meant to render a collection of children, use an array instead."); return q } function ue(j, U, re) { if (j == null) return j; var H = [], se = 0; return ae(j, H, "", "", function (de) { return U.call(re, de, se++) }), H } function te(j) { if (j._status === -1) { var U = j._result; U = U(), U.then(function (re) { (j._status === 0 || j._status === -1) && (j._status = 1, j._result = re) }, function (re) { (j._status === 0 || j._status === -1) && (j._status = 2, j._result = re) }), j._status === -1 && (j._status = 0, j._result = U) } if (j._status === 1) return j._result.default; throw j._result } var ne = { current: null }, $ = { transition: null }, ee = { ReactCurrentDispatcher: ne, ReactCurrentBatchConfig: $, ReactCurrentOwner: V }; function X() { throw Error("act(...) is not supported in production builds of React.") } return Te.Children = { map: ue, forEach: function (j, U, re) { ue(j, function () { U.apply(this, arguments) }, re) }, count: function (j) { var U = 0; return ue(j, function () { U++ }), U }, toArray: function (j) { return ue(j, function (U) { return U }) || [] }, only: function (j) { if (!F(j)) throw Error("React.Children.only expected to receive a single React element child."); return j } }, Te.Component = k, Te.Fragment = s, Te.Profiler = a, Te.PureComponent = T, Te.StrictMode = o, Te.Suspense = p, Te.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ee, Te.act = X, Te.cloneElement = function (j, U, re) { if (j == null) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + j + "."); var H = E({}, j.props), se = j.key, de = j.ref, q = j._owner; if (U != null) { if (U.ref !== void 0 && (de = U.ref, q = V.current), U.key !== void 0 && (se = "" + U.key), j.type && j.type.defaultProps) var le = j.type.defaultProps; for (ve in U) O.call(U, ve) && !M.hasOwnProperty(ve) && (H[ve] = U[ve] === void 0 && le !== void 0 ? le[ve] : U[ve]) } var ve = arguments.length - 2; if (ve === 1) H.children = re; else if (1 < ve) { le = Array(ve); for (var be = 0; be < ve; be++)le[be] = arguments[be + 2]; H.children = le } return { $$typeof: r, type: j.type, key: se, ref: de, props: H, _owner: q } }, Te.createContext = function (j) { return j = { $$typeof: u, _currentValue: j, _currentValue2: j, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null }, j.Provider = { $$typeof: l, _context: j }, j.Consumer = j }, Te.createElement = R, Te.createFactory = function (j) { var U = R.bind(null, j); return U.type = j, U }, Te.createRef = function () { return { current: null } }, Te.forwardRef = function (j) { return { $$typeof: f, render: j } }, Te.isValidElement = F, Te.lazy = function (j) { return { $$typeof: v, _payload: { _status: -1, _result: j }, _init: te } }, Te.memo = function (j, U) { return { $$typeof: m, type: j, compare: U === void 0 ? null : U } }, Te.startTransition = function (j) { var U = $.transition; $.transition = {}; try { j() } finally { $.transition = U } }, Te.unstable_act = X, Te.useCallback = function (j, U) { return ne.current.useCallback(j, U) }, Te.useContext = function (j) { return ne.current.useContext(j) }, Te.useDebugValue = function () { }, Te.useDeferredValue = function (j) { return ne.current.useDeferredValue(j) }, Te.useEffect = function (j, U) { return ne.current.useEffect(j, U) }, Te.useId = function () { return ne.current.useId() }, Te.useImperativeHandle = function (j, U, re) { return ne.current.useImperativeHandle(j, U, re) }, Te.useInsertionEffect = function (j, U) { return ne.current.useInsertionEffect(j, U) }, Te.useLayoutEffect = function (j, U) { return ne.current.useLayoutEffect(j, U) }, Te.useMemo = function (j, U) { return ne.current.useMemo(j, U) }, Te.useReducer = function (j, U, re) { return ne.current.useReducer(j, U, re) }, Te.useRef = function (j) { return ne.current.useRef(j) }, Te.useState = function (j) { return ne.current.useState(j) }, Te.useSyncExternalStore = function (j, U, re) { return ne.current.useSyncExternalStore(j, U, re) }, Te.useTransition = function () { return ne.current.useTransition() }, Te.version = "18.3.1", Te } var Np; function Yu() { return Np || (Np = 1, Bc.exports = Jw()), Bc.exports }/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var Tp; function Qw() { if (Tp) return Ro; Tp = 1; var r = Yu(), t = Symbol.for("react.element"), s = Symbol.for("react.fragment"), o = Object.prototype.hasOwnProperty, a = r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, l = { key: !0, ref: !0, __self: !0, __source: !0 }; function u(f, p, m) { var v, y = {}, _ = null, S = null; m !== void 0 && (_ = "" + m), p.key !== void 0 && (_ = "" + p.key), p.ref !== void 0 && (S = p.ref); for (v in p) o.call(p, v) && !l.hasOwnProperty(v) && (y[v] = p[v]); if (f && f.defaultProps) for (v in p = f.defaultProps, p) y[v] === void 0 && (y[v] = p[v]); return { $$typeof: t, type: f, key: _, ref: S, props: y, _owner: a.current } } return Ro.Fragment = s, Ro.jsx = u, Ro.jsxs = u, Ro } var Pp; function Xw() { return Pp || (Pp = 1, Fc.exports = Qw()), Fc.exports } var d = Xw(), oa = {}, Vc = { exports: {} }, Tt = {}, Wc = { exports: {} }, Hc = {};/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var Rp; function Zw() { return Rp || (Rp = 1, (function (r) { function t($, ee) { var X = $.length; $.push(ee); e: for (; 0 < X;) { var j = X - 1 >>> 1, U = $[j]; if (0 < a(U, ee)) $[j] = ee, $[X] = U, X = j; else break e } } function s($) { return $.length === 0 ? null : $[0] } function o($) { if ($.length === 0) return null; var ee = $[0], X = $.pop(); if (X !== ee) { $[0] = X; e: for (var j = 0, U = $.length, re = U >>> 1; j < re;) { var H = 2 * (j + 1) - 1, se = $[H], de = H + 1, q = $[de]; if (0 > a(se, X)) de < U && 0 > a(q, se) ? ($[j] = q, $[de] = X, j = de) : ($[j] = se, $[H] = X, j = H); else if (de < U && 0 > a(q, X)) $[j] = q, $[de] = X, j = de; else break e } } return ee } function a($, ee) { var X = $.sortIndex - ee.sortIndex; return X !== 0 ? X : $.id - ee.id } if (typeof performance == "object" && typeof performance.now == "function") { var l = performance; r.unstable_now = function () { return l.now() } } else { var u = Date, f = u.now(); r.unstable_now = function () { return u.now() - f } } var p = [], m = [], v = 1, y = null, _ = 3, S = !1, E = !1, b = !1, k = typeof setTimeout == "function" ? setTimeout : null, C = typeof clearTimeout == "function" ? clearTimeout : null, T = typeof setImmediate < "u" ? setImmediate : null; typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling); function P($) { for (var ee = s(m); ee !== null;) { if (ee.callback === null) o(m); else if (ee.startTime <= $) o(m), ee.sortIndex = ee.expirationTime, t(p, ee); else break; ee = s(m) } } function I($) { if (b = !1, P($), !E) if (s(p) !== null) E = !0, te(O); else { var ee = s(m); ee !== null && ne(I, ee.startTime - $) } } function O($, ee) { E = !1, b && (b = !1, C(R), R = -1), S = !0; var X = _; try { for (P(ee), y = s(p); y !== null && (!(y.expirationTime > ee) || $ && !K());) { var j = y.callback; if (typeof j == "function") { y.callback = null, _ = y.priorityLevel; var U = j(y.expirationTime <= ee); ee = r.unstable_now(), typeof U == "function" ? y.callback = U : y === s(p) && o(p), P(ee) } else o(p); y = s(p) } if (y !== null) var re = !0; else { var H = s(m); H !== null && ne(I, H.startTime - ee), re = !1 } return re } finally { y = null, _ = X, S = !1 } } var V = !1, M = null, R = -1, L = 5, F = -1; function K() { return !(r.unstable_now() - F < L) } function G() { if (M !== null) { var $ = r.unstable_now(); F = $; var ee = !0; try { ee = M(!0, $) } finally { ee ? oe() : (V = !1, M = null) } } else V = !1 } var oe; if (typeof T == "function") oe = function () { T(G) }; else if (typeof MessageChannel < "u") { var ae = new MessageChannel, ue = ae.port2; ae.port1.onmessage = G, oe = function () { ue.postMessage(null) } } else oe = function () { k(G, 0) }; function te($) { M = $, V || (V = !0, oe()) } function ne($, ee) { R = k(function () { $(r.unstable_now()) }, ee) } r.unstable_IdlePriority = 5, r.unstable_ImmediatePriority = 1, r.unstable_LowPriority = 4, r.unstable_NormalPriority = 3, r.unstable_Profiling = null, r.unstable_UserBlockingPriority = 2, r.unstable_cancelCallback = function ($) { $.callback = null }, r.unstable_continueExecution = function () { E || S || (E = !0, te(O)) }, r.unstable_forceFrameRate = function ($) { 0 > $ || 125 < $ ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : L = 0 < $ ? Math.floor(1e3 / $) : 5 }, r.unstable_getCurrentPriorityLevel = function () { return _ }, r.unstable_getFirstCallbackNode = function () { return s(p) }, r.unstable_next = function ($) { switch (_) { case 1: case 2: case 3: var ee = 3; break; default: ee = _ }var X = _; _ = ee; try { return $() } finally { _ = X } }, r.unstable_pauseExecution = function () { }, r.unstable_requestPaint = function () { }, r.unstable_runWithPriority = function ($, ee) { switch ($) { case 1: case 2: case 3: case 4: case 5: break; default: $ = 3 }var X = _; _ = $; try { return ee() } finally { _ = X } }, r.unstable_scheduleCallback = function ($, ee, X) { var j = r.unstable_now(); switch (typeof X == "object" && X !== null ? (X = X.delay, X = typeof X == "number" && 0 < X ? j + X : j) : X = j, $) { case 1: var U = -1; break; case 2: U = 250; break; case 5: U = 1073741823; break; case 4: U = 1e4; break; default: U = 5e3 }return U = X + U, $ = { id: v++, callback: ee, priorityLevel: $, startTime: X, expirationTime: U, sortIndex: -1 }, X > j ? ($.sortIndex = X, t(m, $), s(p) === null && $ === s(m) && (b ? (C(R), R = -1) : b = !0, ne(I, X - j))) : ($.sortIndex = U, t(p, $), E || S || (E = !0, te(O))), $ }, r.unstable_shouldYield = K, r.unstable_wrapCallback = function ($) { var ee = _; return function () { var X = _; _ = ee; try { return $.apply(this, arguments) } finally { _ = X } } } })(Hc)), Hc } var Ap; function ex() { return Ap || (Ap = 1, Wc.exports = Zw()), Wc.exports }/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var Op; function tx() {
  if (Op) return Tt; Op = 1; var r = Yu(), t = ex(); function s(e) { for (var n = "https://reactjs.org/docs/error-decoder.html?invariant=" + e, i = 1; i < arguments.length; i++)n += "&args[]=" + encodeURIComponent(arguments[i]); return "Minified React error #" + e + "; visit " + n + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings." } var o = new Set, a = {}; function l(e, n) { u(e, n), u(e + "Capture", n) } function u(e, n) { for (a[e] = n, e = 0; e < n.length; e++)o.add(n[e]) } var f = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), p = Object.prototype.hasOwnProperty, m = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, v = {}, y = {}; function _(e) { return p.call(y, e) ? !0 : p.call(v, e) ? !1 : m.test(e) ? y[e] = !0 : (v[e] = !0, !1) } function S(e, n, i, c) { if (i !== null && i.type === 0) return !1; switch (typeof n) { case "function": case "symbol": return !0; case "boolean": return c ? !1 : i !== null ? !i.acceptsBooleans : (e = e.toLowerCase().slice(0, 5), e !== "data-" && e !== "aria-"); default: return !1 } } function E(e, n, i, c) { if (n === null || typeof n > "u" || S(e, n, i, c)) return !0; if (c) return !1; if (i !== null) switch (i.type) { case 3: return !n; case 4: return n === !1; case 5: return isNaN(n); case 6: return isNaN(n) || 1 > n }return !1 } function b(e, n, i, c, h, g, w) { this.acceptsBooleans = n === 2 || n === 3 || n === 4, this.attributeName = c, this.attributeNamespace = h, this.mustUseProperty = i, this.propertyName = e, this.type = n, this.sanitizeURL = g, this.removeEmptyString = w } var k = {}; "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function (e) { k[e] = new b(e, 0, !1, e, null, !1, !1) }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function (e) { var n = e[0]; k[n] = new b(n, 1, !1, e[1], null, !1, !1) }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function (e) { k[e] = new b(e, 2, !1, e.toLowerCase(), null, !1, !1) }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function (e) { k[e] = new b(e, 2, !1, e, null, !1, !1) }), "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function (e) { k[e] = new b(e, 3, !1, e.toLowerCase(), null, !1, !1) }), ["checked", "multiple", "muted", "selected"].forEach(function (e) { k[e] = new b(e, 3, !0, e, null, !1, !1) }), ["capture", "download"].forEach(function (e) { k[e] = new b(e, 4, !1, e, null, !1, !1) }), ["cols", "rows", "size", "span"].forEach(function (e) { k[e] = new b(e, 6, !1, e, null, !1, !1) }), ["rowSpan", "start"].forEach(function (e) { k[e] = new b(e, 5, !1, e.toLowerCase(), null, !1, !1) }); var C = /[\-:]([a-z])/g; function T(e) { return e[1].toUpperCase() } "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function (e) { var n = e.replace(C, T); k[n] = new b(n, 1, !1, e, null, !1, !1) }), "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function (e) { var n = e.replace(C, T); k[n] = new b(n, 1, !1, e, "http://www.w3.org/1999/xlink", !1, !1) }), ["xml:base", "xml:lang", "xml:space"].forEach(function (e) { var n = e.replace(C, T); k[n] = new b(n, 1, !1, e, "http://www.w3.org/XML/1998/namespace", !1, !1) }), ["tabIndex", "crossOrigin"].forEach(function (e) { k[e] = new b(e, 1, !1, e.toLowerCase(), null, !1, !1) }), k.xlinkHref = new b("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1), ["src", "href", "action", "formAction"].forEach(function (e) { k[e] = new b(e, 1, !1, e.toLowerCase(), null, !0, !0) }); function P(e, n, i, c) { var h = k.hasOwnProperty(n) ? k[n] : null; (h !== null ? h.type !== 0 : c || !(2 < n.length) || n[0] !== "o" && n[0] !== "O" || n[1] !== "n" && n[1] !== "N") && (E(n, i, h, c) && (i = null), c || h === null ? _(n) && (i === null ? e.removeAttribute(n) : e.setAttribute(n, "" + i)) : h.mustUseProperty ? e[h.propertyName] = i === null ? h.type === 3 ? !1 : "" : i : (n = h.attributeName, c = h.attributeNamespace, i === null ? e.removeAttribute(n) : (h = h.type, i = h === 3 || h === 4 && i === !0 ? "" : "" + i, c ? e.setAttributeNS(c, n, i) : e.setAttribute(n, i)))) } var I = r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, O = Symbol.for("react.element"), V = Symbol.for("react.portal"), M = Symbol.for("react.fragment"), R = Symbol.for("react.strict_mode"), L = Symbol.for("react.profiler"), F = Symbol.for("react.provider"), K = Symbol.for("react.context"), G = Symbol.for("react.forward_ref"), oe = Symbol.for("react.suspense"), ae = Symbol.for("react.suspense_list"), ue = Symbol.for("react.memo"), te = Symbol.for("react.lazy"), ne = Symbol.for("react.offscreen"), $ = Symbol.iterator; function ee(e) { return e === null || typeof e != "object" ? null : (e = $ && e[$] || e["@@iterator"], typeof e == "function" ? e : null) } var X = Object.assign, j; function U(e) {
    if (j === void 0) try { throw Error() } catch (i) { var n = i.stack.trim().match(/\n( *(at )?)/); j = n && n[1] || "" } return `
`+ j + e
  } var re = !1; function H(e, n) {
    if (!e || re) return ""; re = !0; var i = Error.prepareStackTrace; Error.prepareStackTrace = void 0; try { if (n) if (n = function () { throw Error() }, Object.defineProperty(n.prototype, "props", { set: function () { throw Error() } }), typeof Reflect == "object" && Reflect.construct) { try { Reflect.construct(n, []) } catch (W) { var c = W } Reflect.construct(e, [], n) } else { try { n.call() } catch (W) { c = W } e.call(n.prototype) } else { try { throw Error() } catch (W) { c = W } e() } } catch (W) {
      if (W && c && typeof W.stack == "string") {
        for (var h = W.stack.split(`
`), g = c.stack.split(`
`), w = h.length - 1, N = g.length - 1; 1 <= w && 0 <= N && h[w] !== g[N];)N--; for (; 1 <= w && 0 <= N; w--, N--)if (h[w] !== g[N]) {
          if (w !== 1 || N !== 1) do if (w--, N--, 0 > N || h[w] !== g[N]) {
            var A = `
`+ h[w].replace(" at new ", " at "); return e.displayName && A.includes("<anonymous>") && (A = A.replace("<anonymous>", e.displayName)), A
          } while (1 <= w && 0 <= N); break
        }
      }
    } finally { re = !1, Error.prepareStackTrace = i } return (e = e ? e.displayName || e.name : "") ? U(e) : ""
  } function se(e) { switch (e.tag) { case 5: return U(e.type); case 16: return U("Lazy"); case 13: return U("Suspense"); case 19: return U("SuspenseList"); case 0: case 2: case 15: return e = H(e.type, !1), e; case 11: return e = H(e.type.render, !1), e; case 1: return e = H(e.type, !0), e; default: return "" } } function de(e) { if (e == null) return null; if (typeof e == "function") return e.displayName || e.name || null; if (typeof e == "string") return e; switch (e) { case M: return "Fragment"; case V: return "Portal"; case L: return "Profiler"; case R: return "StrictMode"; case oe: return "Suspense"; case ae: return "SuspenseList" }if (typeof e == "object") switch (e.$$typeof) { case K: return (e.displayName || "Context") + ".Consumer"; case F: return (e._context.displayName || "Context") + ".Provider"; case G: var n = e.render; return e = e.displayName, e || (e = n.displayName || n.name || "", e = e !== "" ? "ForwardRef(" + e + ")" : "ForwardRef"), e; case ue: return n = e.displayName || null, n !== null ? n : de(e.type) || "Memo"; case te: n = e._payload, e = e._init; try { return de(e(n)) } catch { } }return null } function q(e) { var n = e.type; switch (e.tag) { case 24: return "Cache"; case 9: return (n.displayName || "Context") + ".Consumer"; case 10: return (n._context.displayName || "Context") + ".Provider"; case 18: return "DehydratedFragment"; case 11: return e = n.render, e = e.displayName || e.name || "", n.displayName || (e !== "" ? "ForwardRef(" + e + ")" : "ForwardRef"); case 7: return "Fragment"; case 5: return n; case 4: return "Portal"; case 3: return "Root"; case 6: return "Text"; case 16: return de(n); case 8: return n === R ? "StrictMode" : "Mode"; case 22: return "Offscreen"; case 12: return "Profiler"; case 21: return "Scope"; case 13: return "Suspense"; case 19: return "SuspenseList"; case 25: return "TracingMarker"; case 1: case 0: case 17: case 2: case 14: case 15: if (typeof n == "function") return n.displayName || n.name || null; if (typeof n == "string") return n }return null } function le(e) { switch (typeof e) { case "boolean": case "number": case "string": case "undefined": return e; case "object": return e; default: return "" } } function ve(e) { var n = e.type; return (e = e.nodeName) && e.toLowerCase() === "input" && (n === "checkbox" || n === "radio") } function be(e) { var n = ve(e) ? "checked" : "value", i = Object.getOwnPropertyDescriptor(e.constructor.prototype, n), c = "" + e[n]; if (!e.hasOwnProperty(n) && typeof i < "u" && typeof i.get == "function" && typeof i.set == "function") { var h = i.get, g = i.set; return Object.defineProperty(e, n, { configurable: !0, get: function () { return h.call(this) }, set: function (w) { c = "" + w, g.call(this, w) } }), Object.defineProperty(e, n, { enumerable: i.enumerable }), { getValue: function () { return c }, setValue: function (w) { c = "" + w }, stopTracking: function () { e._valueTracker = null, delete e[n] } } } } function je(e) { e._valueTracker || (e._valueTracker = be(e)) } function Le(e) { if (!e) return !1; var n = e._valueTracker; if (!n) return !0; var i = n.getValue(), c = ""; return e && (c = ve(e) ? e.checked ? "true" : "false" : e.value), e = c, e !== i ? (n.setValue(e), !0) : !1 } function Xe(e) { if (e = e || (typeof document < "u" ? document : void 0), typeof e > "u") return null; try { return e.activeElement || e.body } catch { return e.body } } function nt(e, n) { var i = n.checked; return X({}, n, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: i ?? e._wrapperState.initialChecked }) } function Mr(e, n) { var i = n.defaultValue == null ? "" : n.defaultValue, c = n.checked != null ? n.checked : n.defaultChecked; i = le(n.value != null ? n.value : i), e._wrapperState = { initialChecked: c, initialValue: i, controlled: n.type === "checkbox" || n.type === "radio" ? n.checked != null : n.value != null } } function Ur(e, n) { n = n.checked, n != null && P(e, "checked", n, !1) } function dr(e, n) { Ur(e, n); var i = le(n.value), c = n.type; if (i != null) c === "number" ? (i === 0 && e.value === "" || e.value != i) && (e.value = "" + i) : e.value !== "" + i && (e.value = "" + i); else if (c === "submit" || c === "reset") { e.removeAttribute("value"); return } n.hasOwnProperty("value") ? Ja(e, n.type, i) : n.hasOwnProperty("defaultValue") && Ja(e, n.type, le(n.defaultValue)), n.checked == null && n.defaultChecked != null && (e.defaultChecked = !!n.defaultChecked) } function Dd(e, n, i) { if (n.hasOwnProperty("value") || n.hasOwnProperty("defaultValue")) { var c = n.type; if (!(c !== "submit" && c !== "reset" || n.value !== void 0 && n.value !== null)) return; n = "" + e._wrapperState.initialValue, i || n === e.value || (e.value = n), e.defaultValue = n } i = e.name, i !== "" && (e.name = ""), e.defaultChecked = !!e._wrapperState.initialChecked, i !== "" && (e.name = i) } function Ja(e, n, i) { (n !== "number" || Xe(e.ownerDocument) !== e) && (i == null ? e.defaultValue = "" + e._wrapperState.initialValue : e.defaultValue !== "" + i && (e.defaultValue = "" + i)) } var Hs = Array.isArray; function zr(e, n, i, c) { if (e = e.options, n) { n = {}; for (var h = 0; h < i.length; h++)n["$" + i[h]] = !0; for (i = 0; i < e.length; i++)h = n.hasOwnProperty("$" + e[i].value), e[i].selected !== h && (e[i].selected = h), h && c && (e[i].defaultSelected = !0) } else { for (i = "" + le(i), n = null, h = 0; h < e.length; h++) { if (e[h].value === i) { e[h].selected = !0, c && (e[h].defaultSelected = !0); return } n !== null || e[h].disabled || (n = e[h]) } n !== null && (n.selected = !0) } } function Qa(e, n) { if (n.dangerouslySetInnerHTML != null) throw Error(s(91)); return X({}, n, { value: void 0, defaultValue: void 0, children: "" + e._wrapperState.initialValue }) } function $d(e, n) { var i = n.value; if (i == null) { if (i = n.children, n = n.defaultValue, i != null) { if (n != null) throw Error(s(92)); if (Hs(i)) { if (1 < i.length) throw Error(s(93)); i = i[0] } n = i } n == null && (n = ""), i = n } e._wrapperState = { initialValue: le(i) } } function Ld(e, n) { var i = le(n.value), c = le(n.defaultValue); i != null && (i = "" + i, i !== e.value && (e.value = i), n.defaultValue == null && e.defaultValue !== i && (e.defaultValue = i)), c != null && (e.defaultValue = "" + c) } function Md(e) { var n = e.textContent; n === e._wrapperState.initialValue && n !== "" && n !== null && (e.value = n) } function Ud(e) { switch (e) { case "svg": return "http://www.w3.org/2000/svg"; case "math": return "http://www.w3.org/1998/Math/MathML"; default: return "http://www.w3.org/1999/xhtml" } } function Xa(e, n) { return e == null || e === "http://www.w3.org/1999/xhtml" ? Ud(n) : e === "http://www.w3.org/2000/svg" && n === "foreignObject" ? "http://www.w3.org/1999/xhtml" : e } var Qo, zd = (function (e) { return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function (n, i, c, h) { MSApp.execUnsafeLocalFunction(function () { return e(n, i, c, h) }) } : e })(function (e, n) { if (e.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in e) e.innerHTML = n; else { for (Qo = Qo || document.createElement("div"), Qo.innerHTML = "<svg>" + n.valueOf().toString() + "</svg>", n = Qo.firstChild; e.firstChild;)e.removeChild(e.firstChild); for (; n.firstChild;)e.appendChild(n.firstChild) } }); function Ks(e, n) { if (n) { var i = e.firstChild; if (i && i === e.lastChild && i.nodeType === 3) { i.nodeValue = n; return } } e.textContent = n } var qs = { animationIterationCount: !0, aspectRatio: !0, borderImageOutset: !0, borderImageSlice: !0, borderImageWidth: !0, boxFlex: !0, boxFlexGroup: !0, boxOrdinalGroup: !0, columnCount: !0, columns: !0, flex: !0, flexGrow: !0, flexPositive: !0, flexShrink: !0, flexNegative: !0, flexOrder: !0, gridArea: !0, gridRow: !0, gridRowEnd: !0, gridRowSpan: !0, gridRowStart: !0, gridColumn: !0, gridColumnEnd: !0, gridColumnSpan: !0, gridColumnStart: !0, fontWeight: !0, lineClamp: !0, lineHeight: !0, opacity: !0, order: !0, orphans: !0, tabSize: !0, widows: !0, zIndex: !0, zoom: !0, fillOpacity: !0, floodOpacity: !0, stopOpacity: !0, strokeDasharray: !0, strokeDashoffset: !0, strokeMiterlimit: !0, strokeOpacity: !0, strokeWidth: !0 }, Xy = ["Webkit", "ms", "Moz", "O"]; Object.keys(qs).forEach(function (e) { Xy.forEach(function (n) { n = n + e.charAt(0).toUpperCase() + e.substring(1), qs[n] = qs[e] }) }); function Fd(e, n, i) { return n == null || typeof n == "boolean" || n === "" ? "" : i || typeof n != "number" || n === 0 || qs.hasOwnProperty(e) && qs[e] ? ("" + n).trim() : n + "px" } function Bd(e, n) { e = e.style; for (var i in n) if (n.hasOwnProperty(i)) { var c = i.indexOf("--") === 0, h = Fd(i, n[i], c); i === "float" && (i = "cssFloat"), c ? e.setProperty(i, h) : e[i] = h } } var Zy = X({ menuitem: !0 }, { area: !0, base: !0, br: !0, col: !0, embed: !0, hr: !0, img: !0, input: !0, keygen: !0, link: !0, meta: !0, param: !0, source: !0, track: !0, wbr: !0 }); function Za(e, n) { if (n) { if (Zy[e] && (n.children != null || n.dangerouslySetInnerHTML != null)) throw Error(s(137, e)); if (n.dangerouslySetInnerHTML != null) { if (n.children != null) throw Error(s(60)); if (typeof n.dangerouslySetInnerHTML != "object" || !("__html" in n.dangerouslySetInnerHTML)) throw Error(s(61)) } if (n.style != null && typeof n.style != "object") throw Error(s(62)) } } function el(e, n) { if (e.indexOf("-") === -1) return typeof n.is == "string"; switch (e) { case "annotation-xml": case "color-profile": case "font-face": case "font-face-src": case "font-face-uri": case "font-face-format": case "font-face-name": case "missing-glyph": return !1; default: return !0 } } var tl = null; function nl(e) { return e = e.target || e.srcElement || window, e.correspondingUseElement && (e = e.correspondingUseElement), e.nodeType === 3 ? e.parentNode : e } var rl = null, Fr = null, Br = null; function Vd(e) { if (e = go(e)) { if (typeof rl != "function") throw Error(s(280)); var n = e.stateNode; n && (n = xi(n), rl(e.stateNode, e.type, n)) } } function Wd(e) { Fr ? Br ? Br.push(e) : Br = [e] : Fr = e } function Hd() { if (Fr) { var e = Fr, n = Br; if (Br = Fr = null, Vd(e), n) for (e = 0; e < n.length; e++)Vd(n[e]) } } function Kd(e, n) { return e(n) } function qd() { } var sl = !1; function Gd(e, n, i) { if (sl) return e(n, i); sl = !0; try { return Kd(e, n, i) } finally { sl = !1, (Fr !== null || Br !== null) && (qd(), Hd()) } } function Gs(e, n) { var i = e.stateNode; if (i === null) return null; var c = xi(i); if (c === null) return null; i = c[n]; e: switch (n) { case "onClick": case "onClickCapture": case "onDoubleClick": case "onDoubleClickCapture": case "onMouseDown": case "onMouseDownCapture": case "onMouseMove": case "onMouseMoveCapture": case "onMouseUp": case "onMouseUpCapture": case "onMouseEnter": (c = !c.disabled) || (e = e.type, c = !(e === "button" || e === "input" || e === "select" || e === "textarea")), e = !c; break e; default: e = !1 }if (e) return null; if (i && typeof i != "function") throw Error(s(231, n, typeof i)); return i } var ol = !1; if (f) try { var Ys = {}; Object.defineProperty(Ys, "passive", { get: function () { ol = !0 } }), window.addEventListener("test", Ys, Ys), window.removeEventListener("test", Ys, Ys) } catch { ol = !1 } function e0(e, n, i, c, h, g, w, N, A) { var W = Array.prototype.slice.call(arguments, 3); try { n.apply(i, W) } catch (J) { this.onError(J) } } var Js = !1, Xo = null, Zo = !1, il = null, t0 = { onError: function (e) { Js = !0, Xo = e } }; function n0(e, n, i, c, h, g, w, N, A) { Js = !1, Xo = null, e0.apply(t0, arguments) } function r0(e, n, i, c, h, g, w, N, A) { if (n0.apply(this, arguments), Js) { if (Js) { var W = Xo; Js = !1, Xo = null } else throw Error(s(198)); Zo || (Zo = !0, il = W) } } function fr(e) { var n = e, i = e; if (e.alternate) for (; n.return;)n = n.return; else { e = n; do n = e, (n.flags & 4098) !== 0 && (i = n.return), e = n.return; while (e) } return n.tag === 3 ? i : null } function Yd(e) { if (e.tag === 13) { var n = e.memoizedState; if (n === null && (e = e.alternate, e !== null && (n = e.memoizedState)), n !== null) return n.dehydrated } return null } function Jd(e) { if (fr(e) !== e) throw Error(s(188)) } function s0(e) { var n = e.alternate; if (!n) { if (n = fr(e), n === null) throw Error(s(188)); return n !== e ? null : e } for (var i = e, c = n; ;) { var h = i.return; if (h === null) break; var g = h.alternate; if (g === null) { if (c = h.return, c !== null) { i = c; continue } break } if (h.child === g.child) { for (g = h.child; g;) { if (g === i) return Jd(h), e; if (g === c) return Jd(h), n; g = g.sibling } throw Error(s(188)) } if (i.return !== c.return) i = h, c = g; else { for (var w = !1, N = h.child; N;) { if (N === i) { w = !0, i = h, c = g; break } if (N === c) { w = !0, c = h, i = g; break } N = N.sibling } if (!w) { for (N = g.child; N;) { if (N === i) { w = !0, i = g, c = h; break } if (N === c) { w = !0, c = g, i = h; break } N = N.sibling } if (!w) throw Error(s(189)) } } if (i.alternate !== c) throw Error(s(190)) } if (i.tag !== 3) throw Error(s(188)); return i.stateNode.current === i ? e : n } function Qd(e) { return e = s0(e), e !== null ? Xd(e) : null } function Xd(e) { if (e.tag === 5 || e.tag === 6) return e; for (e = e.child; e !== null;) { var n = Xd(e); if (n !== null) return n; e = e.sibling } return null } var Zd = t.unstable_scheduleCallback, ef = t.unstable_cancelCallback, o0 = t.unstable_shouldYield, i0 = t.unstable_requestPaint, Ye = t.unstable_now, a0 = t.unstable_getCurrentPriorityLevel, al = t.unstable_ImmediatePriority, tf = t.unstable_UserBlockingPriority, ei = t.unstable_NormalPriority, l0 = t.unstable_LowPriority, nf = t.unstable_IdlePriority, ti = null, cn = null; function c0(e) { if (cn && typeof cn.onCommitFiberRoot == "function") try { cn.onCommitFiberRoot(ti, e, void 0, (e.current.flags & 128) === 128) } catch { } } var Yt = Math.clz32 ? Math.clz32 : f0, u0 = Math.log, d0 = Math.LN2; function f0(e) { return e >>>= 0, e === 0 ? 32 : 31 - (u0(e) / d0 | 0) | 0 } var ni = 64, ri = 4194304; function Qs(e) { switch (e & -e) { case 1: return 1; case 2: return 2; case 4: return 4; case 8: return 8; case 16: return 16; case 32: return 32; case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: return e & 4194240; case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: return e & 130023424; case 134217728: return 134217728; case 268435456: return 268435456; case 536870912: return 536870912; case 1073741824: return 1073741824; default: return e } } function si(e, n) { var i = e.pendingLanes; if (i === 0) return 0; var c = 0, h = e.suspendedLanes, g = e.pingedLanes, w = i & 268435455; if (w !== 0) { var N = w & ~h; N !== 0 ? c = Qs(N) : (g &= w, g !== 0 && (c = Qs(g))) } else w = i & ~h, w !== 0 ? c = Qs(w) : g !== 0 && (c = Qs(g)); if (c === 0) return 0; if (n !== 0 && n !== c && (n & h) === 0 && (h = c & -c, g = n & -n, h >= g || h === 16 && (g & 4194240) !== 0)) return n; if ((c & 4) !== 0 && (c |= i & 16), n = e.entangledLanes, n !== 0) for (e = e.entanglements, n &= c; 0 < n;)i = 31 - Yt(n), h = 1 << i, c |= e[i], n &= ~h; return c } function h0(e, n) { switch (e) { case 1: case 2: case 4: return n + 250; case 8: case 16: case 32: case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: return n + 5e3; case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: return -1; case 134217728: case 268435456: case 536870912: case 1073741824: return -1; default: return -1 } } function p0(e, n) { for (var i = e.suspendedLanes, c = e.pingedLanes, h = e.expirationTimes, g = e.pendingLanes; 0 < g;) { var w = 31 - Yt(g), N = 1 << w, A = h[w]; A === -1 ? ((N & i) === 0 || (N & c) !== 0) && (h[w] = h0(N, n)) : A <= n && (e.expiredLanes |= N), g &= ~N } } function ll(e) { return e = e.pendingLanes & -1073741825, e !== 0 ? e : e & 1073741824 ? 1073741824 : 0 } function rf() { var e = ni; return ni <<= 1, (ni & 4194240) === 0 && (ni = 64), e } function cl(e) { for (var n = [], i = 0; 31 > i; i++)n.push(e); return n } function Xs(e, n, i) { e.pendingLanes |= n, n !== 536870912 && (e.suspendedLanes = 0, e.pingedLanes = 0), e = e.eventTimes, n = 31 - Yt(n), e[n] = i } function m0(e, n) { var i = e.pendingLanes & ~n; e.pendingLanes = n, e.suspendedLanes = 0, e.pingedLanes = 0, e.expiredLanes &= n, e.mutableReadLanes &= n, e.entangledLanes &= n, n = e.entanglements; var c = e.eventTimes; for (e = e.expirationTimes; 0 < i;) { var h = 31 - Yt(i), g = 1 << h; n[h] = 0, c[h] = -1, e[h] = -1, i &= ~g } } function ul(e, n) { var i = e.entangledLanes |= n; for (e = e.entanglements; i;) { var c = 31 - Yt(i), h = 1 << c; h & n | e[c] & n && (e[c] |= n), i &= ~h } } var Me = 0; function sf(e) { return e &= -e, 1 < e ? 4 < e ? (e & 268435455) !== 0 ? 16 : 536870912 : 4 : 1 } var of, dl, af, lf, cf, fl = !1, oi = [], On = null, In = null, Dn = null, Zs = new Map, eo = new Map, $n = [], g0 = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" "); function uf(e, n) { switch (e) { case "focusin": case "focusout": On = null; break; case "dragenter": case "dragleave": In = null; break; case "mouseover": case "mouseout": Dn = null; break; case "pointerover": case "pointerout": Zs.delete(n.pointerId); break; case "gotpointercapture": case "lostpointercapture": eo.delete(n.pointerId) } } function to(e, n, i, c, h, g) { return e === null || e.nativeEvent !== g ? (e = { blockedOn: n, domEventName: i, eventSystemFlags: c, nativeEvent: g, targetContainers: [h] }, n !== null && (n = go(n), n !== null && dl(n)), e) : (e.eventSystemFlags |= c, n = e.targetContainers, h !== null && n.indexOf(h) === -1 && n.push(h), e) } function v0(e, n, i, c, h) { switch (n) { case "focusin": return On = to(On, e, n, i, c, h), !0; case "dragenter": return In = to(In, e, n, i, c, h), !0; case "mouseover": return Dn = to(Dn, e, n, i, c, h), !0; case "pointerover": var g = h.pointerId; return Zs.set(g, to(Zs.get(g) || null, e, n, i, c, h)), !0; case "gotpointercapture": return g = h.pointerId, eo.set(g, to(eo.get(g) || null, e, n, i, c, h)), !0 }return !1 } function df(e) { var n = hr(e.target); if (n !== null) { var i = fr(n); if (i !== null) { if (n = i.tag, n === 13) { if (n = Yd(i), n !== null) { e.blockedOn = n, cf(e.priority, function () { af(i) }); return } } else if (n === 3 && i.stateNode.current.memoizedState.isDehydrated) { e.blockedOn = i.tag === 3 ? i.stateNode.containerInfo : null; return } } } e.blockedOn = null } function ii(e) { if (e.blockedOn !== null) return !1; for (var n = e.targetContainers; 0 < n.length;) { var i = pl(e.domEventName, e.eventSystemFlags, n[0], e.nativeEvent); if (i === null) { i = e.nativeEvent; var c = new i.constructor(i.type, i); tl = c, i.target.dispatchEvent(c), tl = null } else return n = go(i), n !== null && dl(n), e.blockedOn = i, !1; n.shift() } return !0 } function ff(e, n, i) { ii(e) && i.delete(n) } function y0() { fl = !1, On !== null && ii(On) && (On = null), In !== null && ii(In) && (In = null), Dn !== null && ii(Dn) && (Dn = null), Zs.forEach(ff), eo.forEach(ff) } function no(e, n) { e.blockedOn === n && (e.blockedOn = null, fl || (fl = !0, t.unstable_scheduleCallback(t.unstable_NormalPriority, y0))) } function ro(e) { function n(h) { return no(h, e) } if (0 < oi.length) { no(oi[0], e); for (var i = 1; i < oi.length; i++) { var c = oi[i]; c.blockedOn === e && (c.blockedOn = null) } } for (On !== null && no(On, e), In !== null && no(In, e), Dn !== null && no(Dn, e), Zs.forEach(n), eo.forEach(n), i = 0; i < $n.length; i++)c = $n[i], c.blockedOn === e && (c.blockedOn = null); for (; 0 < $n.length && (i = $n[0], i.blockedOn === null);)df(i), i.blockedOn === null && $n.shift() } var Vr = I.ReactCurrentBatchConfig, ai = !0; function w0(e, n, i, c) { var h = Me, g = Vr.transition; Vr.transition = null; try { Me = 1, hl(e, n, i, c) } finally { Me = h, Vr.transition = g } } function x0(e, n, i, c) { var h = Me, g = Vr.transition; Vr.transition = null; try { Me = 4, hl(e, n, i, c) } finally { Me = h, Vr.transition = g } } function hl(e, n, i, c) { if (ai) { var h = pl(e, n, i, c); if (h === null) Rl(e, n, c, li, i), uf(e, c); else if (v0(h, e, n, i, c)) c.stopPropagation(); else if (uf(e, c), n & 4 && -1 < g0.indexOf(e)) { for (; h !== null;) { var g = go(h); if (g !== null && of(g), g = pl(e, n, i, c), g === null && Rl(e, n, c, li, i), g === h) break; h = g } h !== null && c.stopPropagation() } else Rl(e, n, c, null, i) } } var li = null; function pl(e, n, i, c) { if (li = null, e = nl(c), e = hr(e), e !== null) if (n = fr(e), n === null) e = null; else if (i = n.tag, i === 13) { if (e = Yd(n), e !== null) return e; e = null } else if (i === 3) { if (n.stateNode.current.memoizedState.isDehydrated) return n.tag === 3 ? n.stateNode.containerInfo : null; e = null } else n !== e && (e = null); return li = e, null } function hf(e) { switch (e) { case "cancel": case "click": case "close": case "contextmenu": case "copy": case "cut": case "auxclick": case "dblclick": case "dragend": case "dragstart": case "drop": case "focusin": case "focusout": case "input": case "invalid": case "keydown": case "keypress": case "keyup": case "mousedown": case "mouseup": case "paste": case "pause": case "play": case "pointercancel": case "pointerdown": case "pointerup": case "ratechange": case "reset": case "resize": case "seeked": case "submit": case "touchcancel": case "touchend": case "touchstart": case "volumechange": case "change": case "selectionchange": case "textInput": case "compositionstart": case "compositionend": case "compositionupdate": case "beforeblur": case "afterblur": case "beforeinput": case "blur": case "fullscreenchange": case "focus": case "hashchange": case "popstate": case "select": case "selectstart": return 1; case "drag": case "dragenter": case "dragexit": case "dragleave": case "dragover": case "mousemove": case "mouseout": case "mouseover": case "pointermove": case "pointerout": case "pointerover": case "scroll": case "toggle": case "touchmove": case "wheel": case "mouseenter": case "mouseleave": case "pointerenter": case "pointerleave": return 4; case "message": switch (a0()) { case al: return 1; case tf: return 4; case ei: case l0: return 16; case nf: return 536870912; default: return 16 }default: return 16 } } var Ln = null, ml = null, ci = null; function pf() { if (ci) return ci; var e, n = ml, i = n.length, c, h = "value" in Ln ? Ln.value : Ln.textContent, g = h.length; for (e = 0; e < i && n[e] === h[e]; e++); var w = i - e; for (c = 1; c <= w && n[i - c] === h[g - c]; c++); return ci = h.slice(e, 1 < c ? 1 - c : void 0) } function ui(e) { var n = e.keyCode; return "charCode" in e ? (e = e.charCode, e === 0 && n === 13 && (e = 13)) : e = n, e === 10 && (e = 13), 32 <= e || e === 13 ? e : 0 } function di() { return !0 } function mf() { return !1 } function At(e) { function n(i, c, h, g, w) { this._reactName = i, this._targetInst = h, this.type = c, this.nativeEvent = g, this.target = w, this.currentTarget = null; for (var N in e) e.hasOwnProperty(N) && (i = e[N], this[N] = i ? i(g) : g[N]); return this.isDefaultPrevented = (g.defaultPrevented != null ? g.defaultPrevented : g.returnValue === !1) ? di : mf, this.isPropagationStopped = mf, this } return X(n.prototype, { preventDefault: function () { this.defaultPrevented = !0; var i = this.nativeEvent; i && (i.preventDefault ? i.preventDefault() : typeof i.returnValue != "unknown" && (i.returnValue = !1), this.isDefaultPrevented = di) }, stopPropagation: function () { var i = this.nativeEvent; i && (i.stopPropagation ? i.stopPropagation() : typeof i.cancelBubble != "unknown" && (i.cancelBubble = !0), this.isPropagationStopped = di) }, persist: function () { }, isPersistent: di }), n } var Wr = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function (e) { return e.timeStamp || Date.now() }, defaultPrevented: 0, isTrusted: 0 }, gl = At(Wr), so = X({}, Wr, { view: 0, detail: 0 }), b0 = At(so), vl, yl, oo, fi = X({}, so, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: xl, button: 0, buttons: 0, relatedTarget: function (e) { return e.relatedTarget === void 0 ? e.fromElement === e.srcElement ? e.toElement : e.fromElement : e.relatedTarget }, movementX: function (e) { return "movementX" in e ? e.movementX : (e !== oo && (oo && e.type === "mousemove" ? (vl = e.screenX - oo.screenX, yl = e.screenY - oo.screenY) : yl = vl = 0, oo = e), vl) }, movementY: function (e) { return "movementY" in e ? e.movementY : yl } }), gf = At(fi), _0 = X({}, fi, { dataTransfer: 0 }), S0 = At(_0), k0 = X({}, so, { relatedTarget: 0 }), wl = At(k0), E0 = X({}, Wr, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), j0 = At(E0), C0 = X({}, Wr, { clipboardData: function (e) { return "clipboardData" in e ? e.clipboardData : window.clipboardData } }), N0 = At(C0), T0 = X({}, Wr, { data: 0 }), vf = At(T0), P0 = { Esc: "Escape", Spacebar: " ", Left: "ArrowLeft", Up: "ArrowUp", Right: "ArrowRight", Down: "ArrowDown", Del: "Delete", Win: "OS", Menu: "ContextMenu", Apps: "ContextMenu", Scroll: "ScrollLock", MozPrintableKey: "Unidentified" }, R0 = { 8: "Backspace", 9: "Tab", 12: "Clear", 13: "Enter", 16: "Shift", 17: "Control", 18: "Alt", 19: "Pause", 20: "CapsLock", 27: "Escape", 32: " ", 33: "PageUp", 34: "PageDown", 35: "End", 36: "Home", 37: "ArrowLeft", 38: "ArrowUp", 39: "ArrowRight", 40: "ArrowDown", 45: "Insert", 46: "Delete", 112: "F1", 113: "F2", 114: "F3", 115: "F4", 116: "F5", 117: "F6", 118: "F7", 119: "F8", 120: "F9", 121: "F10", 122: "F11", 123: "F12", 144: "NumLock", 145: "ScrollLock", 224: "Meta" }, A0 = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" }; function O0(e) { var n = this.nativeEvent; return n.getModifierState ? n.getModifierState(e) : (e = A0[e]) ? !!n[e] : !1 } function xl() { return O0 } var I0 = X({}, so, { key: function (e) { if (e.key) { var n = P0[e.key] || e.key; if (n !== "Unidentified") return n } return e.type === "keypress" ? (e = ui(e), e === 13 ? "Enter" : String.fromCharCode(e)) : e.type === "keydown" || e.type === "keyup" ? R0[e.keyCode] || "Unidentified" : "" }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: xl, charCode: function (e) { return e.type === "keypress" ? ui(e) : 0 }, keyCode: function (e) { return e.type === "keydown" || e.type === "keyup" ? e.keyCode : 0 }, which: function (e) { return e.type === "keypress" ? ui(e) : e.type === "keydown" || e.type === "keyup" ? e.keyCode : 0 } }), D0 = At(I0), $0 = X({}, fi, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), yf = At($0), L0 = X({}, so, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: xl }), M0 = At(L0), U0 = X({}, Wr, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), z0 = At(U0), F0 = X({}, fi, { deltaX: function (e) { return "deltaX" in e ? e.deltaX : "wheelDeltaX" in e ? -e.wheelDeltaX : 0 }, deltaY: function (e) { return "deltaY" in e ? e.deltaY : "wheelDeltaY" in e ? -e.wheelDeltaY : "wheelDelta" in e ? -e.wheelDelta : 0 }, deltaZ: 0, deltaMode: 0 }), B0 = At(F0), V0 = [9, 13, 27, 32], bl = f && "CompositionEvent" in window, io = null; f && "documentMode" in document && (io = document.documentMode); var W0 = f && "TextEvent" in window && !io, wf = f && (!bl || io && 8 < io && 11 >= io), xf = " ", bf = !1; function _f(e, n) { switch (e) { case "keyup": return V0.indexOf(n.keyCode) !== -1; case "keydown": return n.keyCode !== 229; case "keypress": case "mousedown": case "focusout": return !0; default: return !1 } } function Sf(e) { return e = e.detail, typeof e == "object" && "data" in e ? e.data : null } var Hr = !1; function H0(e, n) { switch (e) { case "compositionend": return Sf(n); case "keypress": return n.which !== 32 ? null : (bf = !0, xf); case "textInput": return e = n.data, e === xf && bf ? null : e; default: return null } } function K0(e, n) { if (Hr) return e === "compositionend" || !bl && _f(e, n) ? (e = pf(), ci = ml = Ln = null, Hr = !1, e) : null; switch (e) { case "paste": return null; case "keypress": if (!(n.ctrlKey || n.altKey || n.metaKey) || n.ctrlKey && n.altKey) { if (n.char && 1 < n.char.length) return n.char; if (n.which) return String.fromCharCode(n.which) } return null; case "compositionend": return wf && n.locale !== "ko" ? null : n.data; default: return null } } var q0 = { color: !0, date: !0, datetime: !0, "datetime-local": !0, email: !0, month: !0, number: !0, password: !0, range: !0, search: !0, tel: !0, text: !0, time: !0, url: !0, week: !0 }; function kf(e) { var n = e && e.nodeName && e.nodeName.toLowerCase(); return n === "input" ? !!q0[e.type] : n === "textarea" } function Ef(e, n, i, c) { Wd(c), n = vi(n, "onChange"), 0 < n.length && (i = new gl("onChange", "change", null, i, c), e.push({ event: i, listeners: n })) } var ao = null, lo = null; function G0(e) { Vf(e, 0) } function hi(e) { var n = Jr(e); if (Le(n)) return e } function Y0(e, n) { if (e === "change") return n } var jf = !1; if (f) { var _l; if (f) { var Sl = "oninput" in document; if (!Sl) { var Cf = document.createElement("div"); Cf.setAttribute("oninput", "return;"), Sl = typeof Cf.oninput == "function" } _l = Sl } else _l = !1; jf = _l && (!document.documentMode || 9 < document.documentMode) } function Nf() { ao && (ao.detachEvent("onpropertychange", Tf), lo = ao = null) } function Tf(e) { if (e.propertyName === "value" && hi(lo)) { var n = []; Ef(n, lo, e, nl(e)), Gd(G0, n) } } function J0(e, n, i) { e === "focusin" ? (Nf(), ao = n, lo = i, ao.attachEvent("onpropertychange", Tf)) : e === "focusout" && Nf() } function Q0(e) { if (e === "selectionchange" || e === "keyup" || e === "keydown") return hi(lo) } function X0(e, n) { if (e === "click") return hi(n) } function Z0(e, n) { if (e === "input" || e === "change") return hi(n) } function ew(e, n) { return e === n && (e !== 0 || 1 / e === 1 / n) || e !== e && n !== n } var Jt = typeof Object.is == "function" ? Object.is : ew; function co(e, n) { if (Jt(e, n)) return !0; if (typeof e != "object" || e === null || typeof n != "object" || n === null) return !1; var i = Object.keys(e), c = Object.keys(n); if (i.length !== c.length) return !1; for (c = 0; c < i.length; c++) { var h = i[c]; if (!p.call(n, h) || !Jt(e[h], n[h])) return !1 } return !0 } function Pf(e) { for (; e && e.firstChild;)e = e.firstChild; return e } function Rf(e, n) { var i = Pf(e); e = 0; for (var c; i;) { if (i.nodeType === 3) { if (c = e + i.textContent.length, e <= n && c >= n) return { node: i, offset: n - e }; e = c } e: { for (; i;) { if (i.nextSibling) { i = i.nextSibling; break e } i = i.parentNode } i = void 0 } i = Pf(i) } } function Af(e, n) { return e && n ? e === n ? !0 : e && e.nodeType === 3 ? !1 : n && n.nodeType === 3 ? Af(e, n.parentNode) : "contains" in e ? e.contains(n) : e.compareDocumentPosition ? !!(e.compareDocumentPosition(n) & 16) : !1 : !1 } function Of() { for (var e = window, n = Xe(); n instanceof e.HTMLIFrameElement;) { try { var i = typeof n.contentWindow.location.href == "string" } catch { i = !1 } if (i) e = n.contentWindow; else break; n = Xe(e.document) } return n } function kl(e) { var n = e && e.nodeName && e.nodeName.toLowerCase(); return n && (n === "input" && (e.type === "text" || e.type === "search" || e.type === "tel" || e.type === "url" || e.type === "password") || n === "textarea" || e.contentEditable === "true") } function tw(e) { var n = Of(), i = e.focusedElem, c = e.selectionRange; if (n !== i && i && i.ownerDocument && Af(i.ownerDocument.documentElement, i)) { if (c !== null && kl(i)) { if (n = c.start, e = c.end, e === void 0 && (e = n), "selectionStart" in i) i.selectionStart = n, i.selectionEnd = Math.min(e, i.value.length); else if (e = (n = i.ownerDocument || document) && n.defaultView || window, e.getSelection) { e = e.getSelection(); var h = i.textContent.length, g = Math.min(c.start, h); c = c.end === void 0 ? g : Math.min(c.end, h), !e.extend && g > c && (h = c, c = g, g = h), h = Rf(i, g); var w = Rf(i, c); h && w && (e.rangeCount !== 1 || e.anchorNode !== h.node || e.anchorOffset !== h.offset || e.focusNode !== w.node || e.focusOffset !== w.offset) && (n = n.createRange(), n.setStart(h.node, h.offset), e.removeAllRanges(), g > c ? (e.addRange(n), e.extend(w.node, w.offset)) : (n.setEnd(w.node, w.offset), e.addRange(n))) } } for (n = [], e = i; e = e.parentNode;)e.nodeType === 1 && n.push({ element: e, left: e.scrollLeft, top: e.scrollTop }); for (typeof i.focus == "function" && i.focus(), i = 0; i < n.length; i++)e = n[i], e.element.scrollLeft = e.left, e.element.scrollTop = e.top } } var nw = f && "documentMode" in document && 11 >= document.documentMode, Kr = null, El = null, uo = null, jl = !1; function If(e, n, i) { var c = i.window === i ? i.document : i.nodeType === 9 ? i : i.ownerDocument; jl || Kr == null || Kr !== Xe(c) || (c = Kr, "selectionStart" in c && kl(c) ? c = { start: c.selectionStart, end: c.selectionEnd } : (c = (c.ownerDocument && c.ownerDocument.defaultView || window).getSelection(), c = { anchorNode: c.anchorNode, anchorOffset: c.anchorOffset, focusNode: c.focusNode, focusOffset: c.focusOffset }), uo && co(uo, c) || (uo = c, c = vi(El, "onSelect"), 0 < c.length && (n = new gl("onSelect", "select", null, n, i), e.push({ event: n, listeners: c }), n.target = Kr))) } function pi(e, n) { var i = {}; return i[e.toLowerCase()] = n.toLowerCase(), i["Webkit" + e] = "webkit" + n, i["Moz" + e] = "moz" + n, i } var qr = { animationend: pi("Animation", "AnimationEnd"), animationiteration: pi("Animation", "AnimationIteration"), animationstart: pi("Animation", "AnimationStart"), transitionend: pi("Transition", "TransitionEnd") }, Cl = {}, Df = {}; f && (Df = document.createElement("div").style, "AnimationEvent" in window || (delete qr.animationend.animation, delete qr.animationiteration.animation, delete qr.animationstart.animation), "TransitionEvent" in window || delete qr.transitionend.transition); function mi(e) { if (Cl[e]) return Cl[e]; if (!qr[e]) return e; var n = qr[e], i; for (i in n) if (n.hasOwnProperty(i) && i in Df) return Cl[e] = n[i]; return e } var $f = mi("animationend"), Lf = mi("animationiteration"), Mf = mi("animationstart"), Uf = mi("transitionend"), zf = new Map, Ff = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" "); function Mn(e, n) { zf.set(e, n), l(n, [e]) } for (var Nl = 0; Nl < Ff.length; Nl++) { var Tl = Ff[Nl], rw = Tl.toLowerCase(), sw = Tl[0].toUpperCase() + Tl.slice(1); Mn(rw, "on" + sw) } Mn($f, "onAnimationEnd"), Mn(Lf, "onAnimationIteration"), Mn(Mf, "onAnimationStart"), Mn("dblclick", "onDoubleClick"), Mn("focusin", "onFocus"), Mn("focusout", "onBlur"), Mn(Uf, "onTransitionEnd"), u("onMouseEnter", ["mouseout", "mouseover"]), u("onMouseLeave", ["mouseout", "mouseover"]), u("onPointerEnter", ["pointerout", "pointerover"]), u("onPointerLeave", ["pointerout", "pointerover"]), l("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" ")), l("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")), l("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]), l("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" ")), l("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" ")), l("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" ")); var fo = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), ow = new Set("cancel close invalid load scroll toggle".split(" ").concat(fo)); function Bf(e, n, i) { var c = e.type || "unknown-event"; e.currentTarget = i, r0(c, n, void 0, e), e.currentTarget = null } function Vf(e, n) { n = (n & 4) !== 0; for (var i = 0; i < e.length; i++) { var c = e[i], h = c.event; c = c.listeners; e: { var g = void 0; if (n) for (var w = c.length - 1; 0 <= w; w--) { var N = c[w], A = N.instance, W = N.currentTarget; if (N = N.listener, A !== g && h.isPropagationStopped()) break e; Bf(h, N, W), g = A } else for (w = 0; w < c.length; w++) { if (N = c[w], A = N.instance, W = N.currentTarget, N = N.listener, A !== g && h.isPropagationStopped()) break e; Bf(h, N, W), g = A } } } if (Zo) throw e = il, Zo = !1, il = null, e } function Ve(e, n) { var i = n[Ll]; i === void 0 && (i = n[Ll] = new Set); var c = e + "__bubble"; i.has(c) || (Wf(n, e, 2, !1), i.add(c)) } function Pl(e, n, i) { var c = 0; n && (c |= 4), Wf(i, e, c, n) } var gi = "_reactListening" + Math.random().toString(36).slice(2); function ho(e) { if (!e[gi]) { e[gi] = !0, o.forEach(function (i) { i !== "selectionchange" && (ow.has(i) || Pl(i, !1, e), Pl(i, !0, e)) }); var n = e.nodeType === 9 ? e : e.ownerDocument; n === null || n[gi] || (n[gi] = !0, Pl("selectionchange", !1, n)) } } function Wf(e, n, i, c) { switch (hf(n)) { case 1: var h = w0; break; case 4: h = x0; break; default: h = hl }i = h.bind(null, n, i, e), h = void 0, !ol || n !== "touchstart" && n !== "touchmove" && n !== "wheel" || (h = !0), c ? h !== void 0 ? e.addEventListener(n, i, { capture: !0, passive: h }) : e.addEventListener(n, i, !0) : h !== void 0 ? e.addEventListener(n, i, { passive: h }) : e.addEventListener(n, i, !1) } function Rl(e, n, i, c, h) { var g = c; if ((n & 1) === 0 && (n & 2) === 0 && c !== null) e: for (; ;) { if (c === null) return; var w = c.tag; if (w === 3 || w === 4) { var N = c.stateNode.containerInfo; if (N === h || N.nodeType === 8 && N.parentNode === h) break; if (w === 4) for (w = c.return; w !== null;) { var A = w.tag; if ((A === 3 || A === 4) && (A = w.stateNode.containerInfo, A === h || A.nodeType === 8 && A.parentNode === h)) return; w = w.return } for (; N !== null;) { if (w = hr(N), w === null) return; if (A = w.tag, A === 5 || A === 6) { c = g = w; continue e } N = N.parentNode } } c = c.return } Gd(function () { var W = g, J = nl(i), Q = []; e: { var Y = zf.get(e); if (Y !== void 0) { var ie = gl, fe = e; switch (e) { case "keypress": if (ui(i) === 0) break e; case "keydown": case "keyup": ie = D0; break; case "focusin": fe = "focus", ie = wl; break; case "focusout": fe = "blur", ie = wl; break; case "beforeblur": case "afterblur": ie = wl; break; case "click": if (i.button === 2) break e; case "auxclick": case "dblclick": case "mousedown": case "mousemove": case "mouseup": case "mouseout": case "mouseover": case "contextmenu": ie = gf; break; case "drag": case "dragend": case "dragenter": case "dragexit": case "dragleave": case "dragover": case "dragstart": case "drop": ie = S0; break; case "touchcancel": case "touchend": case "touchmove": case "touchstart": ie = M0; break; case $f: case Lf: case Mf: ie = j0; break; case Uf: ie = z0; break; case "scroll": ie = b0; break; case "wheel": ie = B0; break; case "copy": case "cut": case "paste": ie = N0; break; case "gotpointercapture": case "lostpointercapture": case "pointercancel": case "pointerdown": case "pointermove": case "pointerout": case "pointerover": case "pointerup": ie = yf }var me = (n & 4) !== 0, Je = !me && e === "scroll", z = me ? Y !== null ? Y + "Capture" : null : Y; me = []; for (var D = W, B; D !== null;) { B = D; var Z = B.stateNode; if (B.tag === 5 && Z !== null && (B = Z, z !== null && (Z = Gs(D, z), Z != null && me.push(po(D, Z, B)))), Je) break; D = D.return } 0 < me.length && (Y = new ie(Y, fe, null, i, J), Q.push({ event: Y, listeners: me })) } } if ((n & 7) === 0) { e: { if (Y = e === "mouseover" || e === "pointerover", ie = e === "mouseout" || e === "pointerout", Y && i !== tl && (fe = i.relatedTarget || i.fromElement) && (hr(fe) || fe[bn])) break e; if ((ie || Y) && (Y = J.window === J ? J : (Y = J.ownerDocument) ? Y.defaultView || Y.parentWindow : window, ie ? (fe = i.relatedTarget || i.toElement, ie = W, fe = fe ? hr(fe) : null, fe !== null && (Je = fr(fe), fe !== Je || fe.tag !== 5 && fe.tag !== 6) && (fe = null)) : (ie = null, fe = W), ie !== fe)) { if (me = gf, Z = "onMouseLeave", z = "onMouseEnter", D = "mouse", (e === "pointerout" || e === "pointerover") && (me = yf, Z = "onPointerLeave", z = "onPointerEnter", D = "pointer"), Je = ie == null ? Y : Jr(ie), B = fe == null ? Y : Jr(fe), Y = new me(Z, D + "leave", ie, i, J), Y.target = Je, Y.relatedTarget = B, Z = null, hr(J) === W && (me = new me(z, D + "enter", fe, i, J), me.target = B, me.relatedTarget = Je, Z = me), Je = Z, ie && fe) t: { for (me = ie, z = fe, D = 0, B = me; B; B = Gr(B))D++; for (B = 0, Z = z; Z; Z = Gr(Z))B++; for (; 0 < D - B;)me = Gr(me), D--; for (; 0 < B - D;)z = Gr(z), B--; for (; D--;) { if (me === z || z !== null && me === z.alternate) break t; me = Gr(me), z = Gr(z) } me = null } else me = null; ie !== null && Hf(Q, Y, ie, me, !1), fe !== null && Je !== null && Hf(Q, Je, fe, me, !0) } } e: { if (Y = W ? Jr(W) : window, ie = Y.nodeName && Y.nodeName.toLowerCase(), ie === "select" || ie === "input" && Y.type === "file") var ge = Y0; else if (kf(Y)) if (jf) ge = Z0; else { ge = Q0; var ye = J0 } else (ie = Y.nodeName) && ie.toLowerCase() === "input" && (Y.type === "checkbox" || Y.type === "radio") && (ge = X0); if (ge && (ge = ge(e, W))) { Ef(Q, ge, i, J); break e } ye && ye(e, Y, W), e === "focusout" && (ye = Y._wrapperState) && ye.controlled && Y.type === "number" && Ja(Y, "number", Y.value) } switch (ye = W ? Jr(W) : window, e) { case "focusin": (kf(ye) || ye.contentEditable === "true") && (Kr = ye, El = W, uo = null); break; case "focusout": uo = El = Kr = null; break; case "mousedown": jl = !0; break; case "contextmenu": case "mouseup": case "dragend": jl = !1, If(Q, i, J); break; case "selectionchange": if (nw) break; case "keydown": case "keyup": If(Q, i, J) }var we; if (bl) e: { switch (e) { case "compositionstart": var _e = "onCompositionStart"; break e; case "compositionend": _e = "onCompositionEnd"; break e; case "compositionupdate": _e = "onCompositionUpdate"; break e }_e = void 0 } else Hr ? _f(e, i) && (_e = "onCompositionEnd") : e === "keydown" && i.keyCode === 229 && (_e = "onCompositionStart"); _e && (wf && i.locale !== "ko" && (Hr || _e !== "onCompositionStart" ? _e === "onCompositionEnd" && Hr && (we = pf()) : (Ln = J, ml = "value" in Ln ? Ln.value : Ln.textContent, Hr = !0)), ye = vi(W, _e), 0 < ye.length && (_e = new vf(_e, e, null, i, J), Q.push({ event: _e, listeners: ye }), we ? _e.data = we : (we = Sf(i), we !== null && (_e.data = we)))), (we = W0 ? H0(e, i) : K0(e, i)) && (W = vi(W, "onBeforeInput"), 0 < W.length && (J = new vf("onBeforeInput", "beforeinput", null, i, J), Q.push({ event: J, listeners: W }), J.data = we)) } Vf(Q, n) }) } function po(e, n, i) { return { instance: e, listener: n, currentTarget: i } } function vi(e, n) { for (var i = n + "Capture", c = []; e !== null;) { var h = e, g = h.stateNode; h.tag === 5 && g !== null && (h = g, g = Gs(e, i), g != null && c.unshift(po(e, g, h)), g = Gs(e, n), g != null && c.push(po(e, g, h))), e = e.return } return c } function Gr(e) { if (e === null) return null; do e = e.return; while (e && e.tag !== 5); return e || null } function Hf(e, n, i, c, h) { for (var g = n._reactName, w = []; i !== null && i !== c;) { var N = i, A = N.alternate, W = N.stateNode; if (A !== null && A === c) break; N.tag === 5 && W !== null && (N = W, h ? (A = Gs(i, g), A != null && w.unshift(po(i, A, N))) : h || (A = Gs(i, g), A != null && w.push(po(i, A, N)))), i = i.return } w.length !== 0 && e.push({ event: n, listeners: w }) } var iw = /\r\n?/g, aw = /\u0000|\uFFFD/g; function Kf(e) {
    return (typeof e == "string" ? e : "" + e).replace(iw, `
`).replace(aw, "")
  } function yi(e, n, i) { if (n = Kf(n), Kf(e) !== n && i) throw Error(s(425)) } function wi() { } var Al = null, Ol = null; function Il(e, n) { return e === "textarea" || e === "noscript" || typeof n.children == "string" || typeof n.children == "number" || typeof n.dangerouslySetInnerHTML == "object" && n.dangerouslySetInnerHTML !== null && n.dangerouslySetInnerHTML.__html != null } var Dl = typeof setTimeout == "function" ? setTimeout : void 0, lw = typeof clearTimeout == "function" ? clearTimeout : void 0, qf = typeof Promise == "function" ? Promise : void 0, cw = typeof queueMicrotask == "function" ? queueMicrotask : typeof qf < "u" ? function (e) { return qf.resolve(null).then(e).catch(uw) } : Dl; function uw(e) { setTimeout(function () { throw e }) } function $l(e, n) { var i = n, c = 0; do { var h = i.nextSibling; if (e.removeChild(i), h && h.nodeType === 8) if (i = h.data, i === "/$") { if (c === 0) { e.removeChild(h), ro(n); return } c-- } else i !== "$" && i !== "$?" && i !== "$!" || c++; i = h } while (i); ro(n) } function Un(e) { for (; e != null; e = e.nextSibling) { var n = e.nodeType; if (n === 1 || n === 3) break; if (n === 8) { if (n = e.data, n === "$" || n === "$!" || n === "$?") break; if (n === "/$") return null } } return e } function Gf(e) { e = e.previousSibling; for (var n = 0; e;) { if (e.nodeType === 8) { var i = e.data; if (i === "$" || i === "$!" || i === "$?") { if (n === 0) return e; n-- } else i === "/$" && n++ } e = e.previousSibling } return null } var Yr = Math.random().toString(36).slice(2), un = "__reactFiber$" + Yr, mo = "__reactProps$" + Yr, bn = "__reactContainer$" + Yr, Ll = "__reactEvents$" + Yr, dw = "__reactListeners$" + Yr, fw = "__reactHandles$" + Yr; function hr(e) { var n = e[un]; if (n) return n; for (var i = e.parentNode; i;) { if (n = i[bn] || i[un]) { if (i = n.alternate, n.child !== null || i !== null && i.child !== null) for (e = Gf(e); e !== null;) { if (i = e[un]) return i; e = Gf(e) } return n } e = i, i = e.parentNode } return null } function go(e) { return e = e[un] || e[bn], !e || e.tag !== 5 && e.tag !== 6 && e.tag !== 13 && e.tag !== 3 ? null : e } function Jr(e) { if (e.tag === 5 || e.tag === 6) return e.stateNode; throw Error(s(33)) } function xi(e) { return e[mo] || null } var Ml = [], Qr = -1; function zn(e) { return { current: e } } function We(e) { 0 > Qr || (e.current = Ml[Qr], Ml[Qr] = null, Qr--) } function Fe(e, n) { Qr++, Ml[Qr] = e.current, e.current = n } var Fn = {}, pt = zn(Fn), kt = zn(!1), pr = Fn; function Xr(e, n) { var i = e.type.contextTypes; if (!i) return Fn; var c = e.stateNode; if (c && c.__reactInternalMemoizedUnmaskedChildContext === n) return c.__reactInternalMemoizedMaskedChildContext; var h = {}, g; for (g in i) h[g] = n[g]; return c && (e = e.stateNode, e.__reactInternalMemoizedUnmaskedChildContext = n, e.__reactInternalMemoizedMaskedChildContext = h), h } function Et(e) { return e = e.childContextTypes, e != null } function bi() { We(kt), We(pt) } function Yf(e, n, i) { if (pt.current !== Fn) throw Error(s(168)); Fe(pt, n), Fe(kt, i) } function Jf(e, n, i) { var c = e.stateNode; if (n = n.childContextTypes, typeof c.getChildContext != "function") return i; c = c.getChildContext(); for (var h in c) if (!(h in n)) throw Error(s(108, q(e) || "Unknown", h)); return X({}, i, c) } function _i(e) { return e = (e = e.stateNode) && e.__reactInternalMemoizedMergedChildContext || Fn, pr = pt.current, Fe(pt, e), Fe(kt, kt.current), !0 } function Qf(e, n, i) { var c = e.stateNode; if (!c) throw Error(s(169)); i ? (e = Jf(e, n, pr), c.__reactInternalMemoizedMergedChildContext = e, We(kt), We(pt), Fe(pt, e)) : We(kt), Fe(kt, i) } var _n = null, Si = !1, Ul = !1; function Xf(e) { _n === null ? _n = [e] : _n.push(e) } function hw(e) { Si = !0, Xf(e) } function Bn() { if (!Ul && _n !== null) { Ul = !0; var e = 0, n = Me; try { var i = _n; for (Me = 1; e < i.length; e++) { var c = i[e]; do c = c(!0); while (c !== null) } _n = null, Si = !1 } catch (h) { throw _n !== null && (_n = _n.slice(e + 1)), Zd(al, Bn), h } finally { Me = n, Ul = !1 } } return null } var Zr = [], es = 0, ki = null, Ei = 0, zt = [], Ft = 0, mr = null, Sn = 1, kn = ""; function gr(e, n) { Zr[es++] = Ei, Zr[es++] = ki, ki = e, Ei = n } function Zf(e, n, i) { zt[Ft++] = Sn, zt[Ft++] = kn, zt[Ft++] = mr, mr = e; var c = Sn; e = kn; var h = 32 - Yt(c) - 1; c &= ~(1 << h), i += 1; var g = 32 - Yt(n) + h; if (30 < g) { var w = h - h % 5; g = (c & (1 << w) - 1).toString(32), c >>= w, h -= w, Sn = 1 << 32 - Yt(n) + h | i << h | c, kn = g + e } else Sn = 1 << g | i << h | c, kn = e } function zl(e) { e.return !== null && (gr(e, 1), Zf(e, 1, 0)) } function Fl(e) { for (; e === ki;)ki = Zr[--es], Zr[es] = null, Ei = Zr[--es], Zr[es] = null; for (; e === mr;)mr = zt[--Ft], zt[Ft] = null, kn = zt[--Ft], zt[Ft] = null, Sn = zt[--Ft], zt[Ft] = null } var Ot = null, It = null, He = !1, Qt = null; function eh(e, n) { var i = Ht(5, null, null, 0); i.elementType = "DELETED", i.stateNode = n, i.return = e, n = e.deletions, n === null ? (e.deletions = [i], e.flags |= 16) : n.push(i) } function th(e, n) { switch (e.tag) { case 5: var i = e.type; return n = n.nodeType !== 1 || i.toLowerCase() !== n.nodeName.toLowerCase() ? null : n, n !== null ? (e.stateNode = n, Ot = e, It = Un(n.firstChild), !0) : !1; case 6: return n = e.pendingProps === "" || n.nodeType !== 3 ? null : n, n !== null ? (e.stateNode = n, Ot = e, It = null, !0) : !1; case 13: return n = n.nodeType !== 8 ? null : n, n !== null ? (i = mr !== null ? { id: Sn, overflow: kn } : null, e.memoizedState = { dehydrated: n, treeContext: i, retryLane: 1073741824 }, i = Ht(18, null, null, 0), i.stateNode = n, i.return = e, e.child = i, Ot = e, It = null, !0) : !1; default: return !1 } } function Bl(e) { return (e.mode & 1) !== 0 && (e.flags & 128) === 0 } function Vl(e) { if (He) { var n = It; if (n) { var i = n; if (!th(e, n)) { if (Bl(e)) throw Error(s(418)); n = Un(i.nextSibling); var c = Ot; n && th(e, n) ? eh(c, i) : (e.flags = e.flags & -4097 | 2, He = !1, Ot = e) } } else { if (Bl(e)) throw Error(s(418)); e.flags = e.flags & -4097 | 2, He = !1, Ot = e } } } function nh(e) { for (e = e.return; e !== null && e.tag !== 5 && e.tag !== 3 && e.tag !== 13;)e = e.return; Ot = e } function ji(e) { if (e !== Ot) return !1; if (!He) return nh(e), He = !0, !1; var n; if ((n = e.tag !== 3) && !(n = e.tag !== 5) && (n = e.type, n = n !== "head" && n !== "body" && !Il(e.type, e.memoizedProps)), n && (n = It)) { if (Bl(e)) throw rh(), Error(s(418)); for (; n;)eh(e, n), n = Un(n.nextSibling) } if (nh(e), e.tag === 13) { if (e = e.memoizedState, e = e !== null ? e.dehydrated : null, !e) throw Error(s(317)); e: { for (e = e.nextSibling, n = 0; e;) { if (e.nodeType === 8) { var i = e.data; if (i === "/$") { if (n === 0) { It = Un(e.nextSibling); break e } n-- } else i !== "$" && i !== "$!" && i !== "$?" || n++ } e = e.nextSibling } It = null } } else It = Ot ? Un(e.stateNode.nextSibling) : null; return !0 } function rh() { for (var e = It; e;)e = Un(e.nextSibling) } function ts() { It = Ot = null, He = !1 } function Wl(e) { Qt === null ? Qt = [e] : Qt.push(e) } var pw = I.ReactCurrentBatchConfig; function vo(e, n, i) { if (e = i.ref, e !== null && typeof e != "function" && typeof e != "object") { if (i._owner) { if (i = i._owner, i) { if (i.tag !== 1) throw Error(s(309)); var c = i.stateNode } if (!c) throw Error(s(147, e)); var h = c, g = "" + e; return n !== null && n.ref !== null && typeof n.ref == "function" && n.ref._stringRef === g ? n.ref : (n = function (w) { var N = h.refs; w === null ? delete N[g] : N[g] = w }, n._stringRef = g, n) } if (typeof e != "string") throw Error(s(284)); if (!i._owner) throw Error(s(290, e)) } return e } function Ci(e, n) { throw e = Object.prototype.toString.call(n), Error(s(31, e === "[object Object]" ? "object with keys {" + Object.keys(n).join(", ") + "}" : e)) } function sh(e) { var n = e._init; return n(e._payload) } function oh(e) { function n(z, D) { if (e) { var B = z.deletions; B === null ? (z.deletions = [D], z.flags |= 16) : B.push(D) } } function i(z, D) { if (!e) return null; for (; D !== null;)n(z, D), D = D.sibling; return null } function c(z, D) { for (z = new Map; D !== null;)D.key !== null ? z.set(D.key, D) : z.set(D.index, D), D = D.sibling; return z } function h(z, D) { return z = Jn(z, D), z.index = 0, z.sibling = null, z } function g(z, D, B) { return z.index = B, e ? (B = z.alternate, B !== null ? (B = B.index, B < D ? (z.flags |= 2, D) : B) : (z.flags |= 2, D)) : (z.flags |= 1048576, D) } function w(z) { return e && z.alternate === null && (z.flags |= 2), z } function N(z, D, B, Z) { return D === null || D.tag !== 6 ? (D = Dc(B, z.mode, Z), D.return = z, D) : (D = h(D, B), D.return = z, D) } function A(z, D, B, Z) { var ge = B.type; return ge === M ? J(z, D, B.props.children, Z, B.key) : D !== null && (D.elementType === ge || typeof ge == "object" && ge !== null && ge.$$typeof === te && sh(ge) === D.type) ? (Z = h(D, B.props), Z.ref = vo(z, D, B), Z.return = z, Z) : (Z = Qi(B.type, B.key, B.props, null, z.mode, Z), Z.ref = vo(z, D, B), Z.return = z, Z) } function W(z, D, B, Z) { return D === null || D.tag !== 4 || D.stateNode.containerInfo !== B.containerInfo || D.stateNode.implementation !== B.implementation ? (D = $c(B, z.mode, Z), D.return = z, D) : (D = h(D, B.children || []), D.return = z, D) } function J(z, D, B, Z, ge) { return D === null || D.tag !== 7 ? (D = kr(B, z.mode, Z, ge), D.return = z, D) : (D = h(D, B), D.return = z, D) } function Q(z, D, B) { if (typeof D == "string" && D !== "" || typeof D == "number") return D = Dc("" + D, z.mode, B), D.return = z, D; if (typeof D == "object" && D !== null) { switch (D.$$typeof) { case O: return B = Qi(D.type, D.key, D.props, null, z.mode, B), B.ref = vo(z, null, D), B.return = z, B; case V: return D = $c(D, z.mode, B), D.return = z, D; case te: var Z = D._init; return Q(z, Z(D._payload), B) }if (Hs(D) || ee(D)) return D = kr(D, z.mode, B, null), D.return = z, D; Ci(z, D) } return null } function Y(z, D, B, Z) { var ge = D !== null ? D.key : null; if (typeof B == "string" && B !== "" || typeof B == "number") return ge !== null ? null : N(z, D, "" + B, Z); if (typeof B == "object" && B !== null) { switch (B.$$typeof) { case O: return B.key === ge ? A(z, D, B, Z) : null; case V: return B.key === ge ? W(z, D, B, Z) : null; case te: return ge = B._init, Y(z, D, ge(B._payload), Z) }if (Hs(B) || ee(B)) return ge !== null ? null : J(z, D, B, Z, null); Ci(z, B) } return null } function ie(z, D, B, Z, ge) { if (typeof Z == "string" && Z !== "" || typeof Z == "number") return z = z.get(B) || null, N(D, z, "" + Z, ge); if (typeof Z == "object" && Z !== null) { switch (Z.$$typeof) { case O: return z = z.get(Z.key === null ? B : Z.key) || null, A(D, z, Z, ge); case V: return z = z.get(Z.key === null ? B : Z.key) || null, W(D, z, Z, ge); case te: var ye = Z._init; return ie(z, D, B, ye(Z._payload), ge) }if (Hs(Z) || ee(Z)) return z = z.get(B) || null, J(D, z, Z, ge, null); Ci(D, Z) } return null } function fe(z, D, B, Z) { for (var ge = null, ye = null, we = D, _e = D = 0, ct = null; we !== null && _e < B.length; _e++) { we.index > _e ? (ct = we, we = null) : ct = we.sibling; var De = Y(z, we, B[_e], Z); if (De === null) { we === null && (we = ct); break } e && we && De.alternate === null && n(z, we), D = g(De, D, _e), ye === null ? ge = De : ye.sibling = De, ye = De, we = ct } if (_e === B.length) return i(z, we), He && gr(z, _e), ge; if (we === null) { for (; _e < B.length; _e++)we = Q(z, B[_e], Z), we !== null && (D = g(we, D, _e), ye === null ? ge = we : ye.sibling = we, ye = we); return He && gr(z, _e), ge } for (we = c(z, we); _e < B.length; _e++)ct = ie(we, z, _e, B[_e], Z), ct !== null && (e && ct.alternate !== null && we.delete(ct.key === null ? _e : ct.key), D = g(ct, D, _e), ye === null ? ge = ct : ye.sibling = ct, ye = ct); return e && we.forEach(function (Qn) { return n(z, Qn) }), He && gr(z, _e), ge } function me(z, D, B, Z) { var ge = ee(B); if (typeof ge != "function") throw Error(s(150)); if (B = ge.call(B), B == null) throw Error(s(151)); for (var ye = ge = null, we = D, _e = D = 0, ct = null, De = B.next(); we !== null && !De.done; _e++, De = B.next()) { we.index > _e ? (ct = we, we = null) : ct = we.sibling; var Qn = Y(z, we, De.value, Z); if (Qn === null) { we === null && (we = ct); break } e && we && Qn.alternate === null && n(z, we), D = g(Qn, D, _e), ye === null ? ge = Qn : ye.sibling = Qn, ye = Qn, we = ct } if (De.done) return i(z, we), He && gr(z, _e), ge; if (we === null) { for (; !De.done; _e++, De = B.next())De = Q(z, De.value, Z), De !== null && (D = g(De, D, _e), ye === null ? ge = De : ye.sibling = De, ye = De); return He && gr(z, _e), ge } for (we = c(z, we); !De.done; _e++, De = B.next())De = ie(we, z, _e, De.value, Z), De !== null && (e && De.alternate !== null && we.delete(De.key === null ? _e : De.key), D = g(De, D, _e), ye === null ? ge = De : ye.sibling = De, ye = De); return e && we.forEach(function (qw) { return n(z, qw) }), He && gr(z, _e), ge } function Je(z, D, B, Z) { if (typeof B == "object" && B !== null && B.type === M && B.key === null && (B = B.props.children), typeof B == "object" && B !== null) { switch (B.$$typeof) { case O: e: { for (var ge = B.key, ye = D; ye !== null;) { if (ye.key === ge) { if (ge = B.type, ge === M) { if (ye.tag === 7) { i(z, ye.sibling), D = h(ye, B.props.children), D.return = z, z = D; break e } } else if (ye.elementType === ge || typeof ge == "object" && ge !== null && ge.$$typeof === te && sh(ge) === ye.type) { i(z, ye.sibling), D = h(ye, B.props), D.ref = vo(z, ye, B), D.return = z, z = D; break e } i(z, ye); break } else n(z, ye); ye = ye.sibling } B.type === M ? (D = kr(B.props.children, z.mode, Z, B.key), D.return = z, z = D) : (Z = Qi(B.type, B.key, B.props, null, z.mode, Z), Z.ref = vo(z, D, B), Z.return = z, z = Z) } return w(z); case V: e: { for (ye = B.key; D !== null;) { if (D.key === ye) if (D.tag === 4 && D.stateNode.containerInfo === B.containerInfo && D.stateNode.implementation === B.implementation) { i(z, D.sibling), D = h(D, B.children || []), D.return = z, z = D; break e } else { i(z, D); break } else n(z, D); D = D.sibling } D = $c(B, z.mode, Z), D.return = z, z = D } return w(z); case te: return ye = B._init, Je(z, D, ye(B._payload), Z) }if (Hs(B)) return fe(z, D, B, Z); if (ee(B)) return me(z, D, B, Z); Ci(z, B) } return typeof B == "string" && B !== "" || typeof B == "number" ? (B = "" + B, D !== null && D.tag === 6 ? (i(z, D.sibling), D = h(D, B), D.return = z, z = D) : (i(z, D), D = Dc(B, z.mode, Z), D.return = z, z = D), w(z)) : i(z, D) } return Je } var ns = oh(!0), ih = oh(!1), Ni = zn(null), Ti = null, rs = null, Hl = null; function Kl() { Hl = rs = Ti = null } function ql(e) { var n = Ni.current; We(Ni), e._currentValue = n } function Gl(e, n, i) { for (; e !== null;) { var c = e.alternate; if ((e.childLanes & n) !== n ? (e.childLanes |= n, c !== null && (c.childLanes |= n)) : c !== null && (c.childLanes & n) !== n && (c.childLanes |= n), e === i) break; e = e.return } } function ss(e, n) { Ti = e, Hl = rs = null, e = e.dependencies, e !== null && e.firstContext !== null && ((e.lanes & n) !== 0 && (jt = !0), e.firstContext = null) } function Bt(e) { var n = e._currentValue; if (Hl !== e) if (e = { context: e, memoizedValue: n, next: null }, rs === null) { if (Ti === null) throw Error(s(308)); rs = e, Ti.dependencies = { lanes: 0, firstContext: e } } else rs = rs.next = e; return n } var vr = null; function Yl(e) { vr === null ? vr = [e] : vr.push(e) } function ah(e, n, i, c) { var h = n.interleaved; return h === null ? (i.next = i, Yl(n)) : (i.next = h.next, h.next = i), n.interleaved = i, En(e, c) } function En(e, n) { e.lanes |= n; var i = e.alternate; for (i !== null && (i.lanes |= n), i = e, e = e.return; e !== null;)e.childLanes |= n, i = e.alternate, i !== null && (i.childLanes |= n), i = e, e = e.return; return i.tag === 3 ? i.stateNode : null } var Vn = !1; function Jl(e) { e.updateQueue = { baseState: e.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null } } function lh(e, n) { e = e.updateQueue, n.updateQueue === e && (n.updateQueue = { baseState: e.baseState, firstBaseUpdate: e.firstBaseUpdate, lastBaseUpdate: e.lastBaseUpdate, shared: e.shared, effects: e.effects }) } function jn(e, n) { return { eventTime: e, lane: n, tag: 0, payload: null, callback: null, next: null } } function Wn(e, n, i) { var c = e.updateQueue; if (c === null) return null; if (c = c.shared, (Oe & 2) !== 0) { var h = c.pending; return h === null ? n.next = n : (n.next = h.next, h.next = n), c.pending = n, En(e, i) } return h = c.interleaved, h === null ? (n.next = n, Yl(c)) : (n.next = h.next, h.next = n), c.interleaved = n, En(e, i) } function Pi(e, n, i) { if (n = n.updateQueue, n !== null && (n = n.shared, (i & 4194240) !== 0)) { var c = n.lanes; c &= e.pendingLanes, i |= c, n.lanes = i, ul(e, i) } } function ch(e, n) { var i = e.updateQueue, c = e.alternate; if (c !== null && (c = c.updateQueue, i === c)) { var h = null, g = null; if (i = i.firstBaseUpdate, i !== null) { do { var w = { eventTime: i.eventTime, lane: i.lane, tag: i.tag, payload: i.payload, callback: i.callback, next: null }; g === null ? h = g = w : g = g.next = w, i = i.next } while (i !== null); g === null ? h = g = n : g = g.next = n } else h = g = n; i = { baseState: c.baseState, firstBaseUpdate: h, lastBaseUpdate: g, shared: c.shared, effects: c.effects }, e.updateQueue = i; return } e = i.lastBaseUpdate, e === null ? i.firstBaseUpdate = n : e.next = n, i.lastBaseUpdate = n } function Ri(e, n, i, c) { var h = e.updateQueue; Vn = !1; var g = h.firstBaseUpdate, w = h.lastBaseUpdate, N = h.shared.pending; if (N !== null) { h.shared.pending = null; var A = N, W = A.next; A.next = null, w === null ? g = W : w.next = W, w = A; var J = e.alternate; J !== null && (J = J.updateQueue, N = J.lastBaseUpdate, N !== w && (N === null ? J.firstBaseUpdate = W : N.next = W, J.lastBaseUpdate = A)) } if (g !== null) { var Q = h.baseState; w = 0, J = W = A = null, N = g; do { var Y = N.lane, ie = N.eventTime; if ((c & Y) === Y) { J !== null && (J = J.next = { eventTime: ie, lane: 0, tag: N.tag, payload: N.payload, callback: N.callback, next: null }); e: { var fe = e, me = N; switch (Y = n, ie = i, me.tag) { case 1: if (fe = me.payload, typeof fe == "function") { Q = fe.call(ie, Q, Y); break e } Q = fe; break e; case 3: fe.flags = fe.flags & -65537 | 128; case 0: if (fe = me.payload, Y = typeof fe == "function" ? fe.call(ie, Q, Y) : fe, Y == null) break e; Q = X({}, Q, Y); break e; case 2: Vn = !0 } } N.callback !== null && N.lane !== 0 && (e.flags |= 64, Y = h.effects, Y === null ? h.effects = [N] : Y.push(N)) } else ie = { eventTime: ie, lane: Y, tag: N.tag, payload: N.payload, callback: N.callback, next: null }, J === null ? (W = J = ie, A = Q) : J = J.next = ie, w |= Y; if (N = N.next, N === null) { if (N = h.shared.pending, N === null) break; Y = N, N = Y.next, Y.next = null, h.lastBaseUpdate = Y, h.shared.pending = null } } while (!0); if (J === null && (A = Q), h.baseState = A, h.firstBaseUpdate = W, h.lastBaseUpdate = J, n = h.shared.interleaved, n !== null) { h = n; do w |= h.lane, h = h.next; while (h !== n) } else g === null && (h.shared.lanes = 0); xr |= w, e.lanes = w, e.memoizedState = Q } } function uh(e, n, i) { if (e = n.effects, n.effects = null, e !== null) for (n = 0; n < e.length; n++) { var c = e[n], h = c.callback; if (h !== null) { if (c.callback = null, c = i, typeof h != "function") throw Error(s(191, h)); h.call(c) } } } var yo = {}, dn = zn(yo), wo = zn(yo), xo = zn(yo); function yr(e) { if (e === yo) throw Error(s(174)); return e } function Ql(e, n) { switch (Fe(xo, n), Fe(wo, e), Fe(dn, yo), e = n.nodeType, e) { case 9: case 11: n = (n = n.documentElement) ? n.namespaceURI : Xa(null, ""); break; default: e = e === 8 ? n.parentNode : n, n = e.namespaceURI || null, e = e.tagName, n = Xa(n, e) }We(dn), Fe(dn, n) } function os() { We(dn), We(wo), We(xo) } function dh(e) { yr(xo.current); var n = yr(dn.current), i = Xa(n, e.type); n !== i && (Fe(wo, e), Fe(dn, i)) } function Xl(e) { wo.current === e && (We(dn), We(wo)) } var Ke = zn(0); function Ai(e) { for (var n = e; n !== null;) { if (n.tag === 13) { var i = n.memoizedState; if (i !== null && (i = i.dehydrated, i === null || i.data === "$?" || i.data === "$!")) return n } else if (n.tag === 19 && n.memoizedProps.revealOrder !== void 0) { if ((n.flags & 128) !== 0) return n } else if (n.child !== null) { n.child.return = n, n = n.child; continue } if (n === e) break; for (; n.sibling === null;) { if (n.return === null || n.return === e) return null; n = n.return } n.sibling.return = n.return, n = n.sibling } return null } var Zl = []; function ec() { for (var e = 0; e < Zl.length; e++)Zl[e]._workInProgressVersionPrimary = null; Zl.length = 0 } var Oi = I.ReactCurrentDispatcher, tc = I.ReactCurrentBatchConfig, wr = 0, qe = null, rt = null, at = null, Ii = !1, bo = !1, _o = 0, mw = 0; function mt() { throw Error(s(321)) } function nc(e, n) { if (n === null) return !1; for (var i = 0; i < n.length && i < e.length; i++)if (!Jt(e[i], n[i])) return !1; return !0 } function rc(e, n, i, c, h, g) { if (wr = g, qe = n, n.memoizedState = null, n.updateQueue = null, n.lanes = 0, Oi.current = e === null || e.memoizedState === null ? ww : xw, e = i(c, h), bo) { g = 0; do { if (bo = !1, _o = 0, 25 <= g) throw Error(s(301)); g += 1, at = rt = null, n.updateQueue = null, Oi.current = bw, e = i(c, h) } while (bo) } if (Oi.current = Li, n = rt !== null && rt.next !== null, wr = 0, at = rt = qe = null, Ii = !1, n) throw Error(s(300)); return e } function sc() { var e = _o !== 0; return _o = 0, e } function fn() { var e = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null }; return at === null ? qe.memoizedState = at = e : at = at.next = e, at } function Vt() { if (rt === null) { var e = qe.alternate; e = e !== null ? e.memoizedState : null } else e = rt.next; var n = at === null ? qe.memoizedState : at.next; if (n !== null) at = n, rt = e; else { if (e === null) throw Error(s(310)); rt = e, e = { memoizedState: rt.memoizedState, baseState: rt.baseState, baseQueue: rt.baseQueue, queue: rt.queue, next: null }, at === null ? qe.memoizedState = at = e : at = at.next = e } return at } function So(e, n) { return typeof n == "function" ? n(e) : n } function oc(e) { var n = Vt(), i = n.queue; if (i === null) throw Error(s(311)); i.lastRenderedReducer = e; var c = rt, h = c.baseQueue, g = i.pending; if (g !== null) { if (h !== null) { var w = h.next; h.next = g.next, g.next = w } c.baseQueue = h = g, i.pending = null } if (h !== null) { g = h.next, c = c.baseState; var N = w = null, A = null, W = g; do { var J = W.lane; if ((wr & J) === J) A !== null && (A = A.next = { lane: 0, action: W.action, hasEagerState: W.hasEagerState, eagerState: W.eagerState, next: null }), c = W.hasEagerState ? W.eagerState : e(c, W.action); else { var Q = { lane: J, action: W.action, hasEagerState: W.hasEagerState, eagerState: W.eagerState, next: null }; A === null ? (N = A = Q, w = c) : A = A.next = Q, qe.lanes |= J, xr |= J } W = W.next } while (W !== null && W !== g); A === null ? w = c : A.next = N, Jt(c, n.memoizedState) || (jt = !0), n.memoizedState = c, n.baseState = w, n.baseQueue = A, i.lastRenderedState = c } if (e = i.interleaved, e !== null) { h = e; do g = h.lane, qe.lanes |= g, xr |= g, h = h.next; while (h !== e) } else h === null && (i.lanes = 0); return [n.memoizedState, i.dispatch] } function ic(e) { var n = Vt(), i = n.queue; if (i === null) throw Error(s(311)); i.lastRenderedReducer = e; var c = i.dispatch, h = i.pending, g = n.memoizedState; if (h !== null) { i.pending = null; var w = h = h.next; do g = e(g, w.action), w = w.next; while (w !== h); Jt(g, n.memoizedState) || (jt = !0), n.memoizedState = g, n.baseQueue === null && (n.baseState = g), i.lastRenderedState = g } return [g, c] } function fh() { } function hh(e, n) { var i = qe, c = Vt(), h = n(), g = !Jt(c.memoizedState, h); if (g && (c.memoizedState = h, jt = !0), c = c.queue, ac(gh.bind(null, i, c, e), [e]), c.getSnapshot !== n || g || at !== null && at.memoizedState.tag & 1) { if (i.flags |= 2048, ko(9, mh.bind(null, i, c, h, n), void 0, null), lt === null) throw Error(s(349)); (wr & 30) !== 0 || ph(i, n, h) } return h } function ph(e, n, i) { e.flags |= 16384, e = { getSnapshot: n, value: i }, n = qe.updateQueue, n === null ? (n = { lastEffect: null, stores: null }, qe.updateQueue = n, n.stores = [e]) : (i = n.stores, i === null ? n.stores = [e] : i.push(e)) } function mh(e, n, i, c) { n.value = i, n.getSnapshot = c, vh(n) && yh(e) } function gh(e, n, i) { return i(function () { vh(n) && yh(e) }) } function vh(e) { var n = e.getSnapshot; e = e.value; try { var i = n(); return !Jt(e, i) } catch { return !0 } } function yh(e) { var n = En(e, 1); n !== null && tn(n, e, 1, -1) } function wh(e) { var n = fn(); return typeof e == "function" && (e = e()), n.memoizedState = n.baseState = e, e = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: So, lastRenderedState: e }, n.queue = e, e = e.dispatch = yw.bind(null, qe, e), [n.memoizedState, e] } function ko(e, n, i, c) { return e = { tag: e, create: n, destroy: i, deps: c, next: null }, n = qe.updateQueue, n === null ? (n = { lastEffect: null, stores: null }, qe.updateQueue = n, n.lastEffect = e.next = e) : (i = n.lastEffect, i === null ? n.lastEffect = e.next = e : (c = i.next, i.next = e, e.next = c, n.lastEffect = e)), e } function xh() { return Vt().memoizedState } function Di(e, n, i, c) { var h = fn(); qe.flags |= e, h.memoizedState = ko(1 | n, i, void 0, c === void 0 ? null : c) } function $i(e, n, i, c) { var h = Vt(); c = c === void 0 ? null : c; var g = void 0; if (rt !== null) { var w = rt.memoizedState; if (g = w.destroy, c !== null && nc(c, w.deps)) { h.memoizedState = ko(n, i, g, c); return } } qe.flags |= e, h.memoizedState = ko(1 | n, i, g, c) } function bh(e, n) { return Di(8390656, 8, e, n) } function ac(e, n) { return $i(2048, 8, e, n) } function _h(e, n) { return $i(4, 2, e, n) } function Sh(e, n) { return $i(4, 4, e, n) } function kh(e, n) { if (typeof n == "function") return e = e(), n(e), function () { n(null) }; if (n != null) return e = e(), n.current = e, function () { n.current = null } } function Eh(e, n, i) { return i = i != null ? i.concat([e]) : null, $i(4, 4, kh.bind(null, n, e), i) } function lc() { } function jh(e, n) { var i = Vt(); n = n === void 0 ? null : n; var c = i.memoizedState; return c !== null && n !== null && nc(n, c[1]) ? c[0] : (i.memoizedState = [e, n], e) } function Ch(e, n) { var i = Vt(); n = n === void 0 ? null : n; var c = i.memoizedState; return c !== null && n !== null && nc(n, c[1]) ? c[0] : (e = e(), i.memoizedState = [e, n], e) } function Nh(e, n, i) { return (wr & 21) === 0 ? (e.baseState && (e.baseState = !1, jt = !0), e.memoizedState = i) : (Jt(i, n) || (i = rf(), qe.lanes |= i, xr |= i, e.baseState = !0), n) } function gw(e, n) { var i = Me; Me = i !== 0 && 4 > i ? i : 4, e(!0); var c = tc.transition; tc.transition = {}; try { e(!1), n() } finally { Me = i, tc.transition = c } } function Th() { return Vt().memoizedState } function vw(e, n, i) { var c = Gn(e); if (i = { lane: c, action: i, hasEagerState: !1, eagerState: null, next: null }, Ph(e)) Rh(n, i); else if (i = ah(e, n, i, c), i !== null) { var h = St(); tn(i, e, c, h), Ah(i, n, c) } } function yw(e, n, i) { var c = Gn(e), h = { lane: c, action: i, hasEagerState: !1, eagerState: null, next: null }; if (Ph(e)) Rh(n, h); else { var g = e.alternate; if (e.lanes === 0 && (g === null || g.lanes === 0) && (g = n.lastRenderedReducer, g !== null)) try { var w = n.lastRenderedState, N = g(w, i); if (h.hasEagerState = !0, h.eagerState = N, Jt(N, w)) { var A = n.interleaved; A === null ? (h.next = h, Yl(n)) : (h.next = A.next, A.next = h), n.interleaved = h; return } } catch { } finally { } i = ah(e, n, h, c), i !== null && (h = St(), tn(i, e, c, h), Ah(i, n, c)) } } function Ph(e) { var n = e.alternate; return e === qe || n !== null && n === qe } function Rh(e, n) { bo = Ii = !0; var i = e.pending; i === null ? n.next = n : (n.next = i.next, i.next = n), e.pending = n } function Ah(e, n, i) { if ((i & 4194240) !== 0) { var c = n.lanes; c &= e.pendingLanes, i |= c, n.lanes = i, ul(e, i) } } var Li = { readContext: Bt, useCallback: mt, useContext: mt, useEffect: mt, useImperativeHandle: mt, useInsertionEffect: mt, useLayoutEffect: mt, useMemo: mt, useReducer: mt, useRef: mt, useState: mt, useDebugValue: mt, useDeferredValue: mt, useTransition: mt, useMutableSource: mt, useSyncExternalStore: mt, useId: mt, unstable_isNewReconciler: !1 }, ww = { readContext: Bt, useCallback: function (e, n) { return fn().memoizedState = [e, n === void 0 ? null : n], e }, useContext: Bt, useEffect: bh, useImperativeHandle: function (e, n, i) { return i = i != null ? i.concat([e]) : null, Di(4194308, 4, kh.bind(null, n, e), i) }, useLayoutEffect: function (e, n) { return Di(4194308, 4, e, n) }, useInsertionEffect: function (e, n) { return Di(4, 2, e, n) }, useMemo: function (e, n) { var i = fn(); return n = n === void 0 ? null : n, e = e(), i.memoizedState = [e, n], e }, useReducer: function (e, n, i) { var c = fn(); return n = i !== void 0 ? i(n) : n, c.memoizedState = c.baseState = n, e = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: e, lastRenderedState: n }, c.queue = e, e = e.dispatch = vw.bind(null, qe, e), [c.memoizedState, e] }, useRef: function (e) { var n = fn(); return e = { current: e }, n.memoizedState = e }, useState: wh, useDebugValue: lc, useDeferredValue: function (e) { return fn().memoizedState = e }, useTransition: function () { var e = wh(!1), n = e[0]; return e = gw.bind(null, e[1]), fn().memoizedState = e, [n, e] }, useMutableSource: function () { }, useSyncExternalStore: function (e, n, i) { var c = qe, h = fn(); if (He) { if (i === void 0) throw Error(s(407)); i = i() } else { if (i = n(), lt === null) throw Error(s(349)); (wr & 30) !== 0 || ph(c, n, i) } h.memoizedState = i; var g = { value: i, getSnapshot: n }; return h.queue = g, bh(gh.bind(null, c, g, e), [e]), c.flags |= 2048, ko(9, mh.bind(null, c, g, i, n), void 0, null), i }, useId: function () { var e = fn(), n = lt.identifierPrefix; if (He) { var i = kn, c = Sn; i = (c & ~(1 << 32 - Yt(c) - 1)).toString(32) + i, n = ":" + n + "R" + i, i = _o++, 0 < i && (n += "H" + i.toString(32)), n += ":" } else i = mw++, n = ":" + n + "r" + i.toString(32) + ":"; return e.memoizedState = n }, unstable_isNewReconciler: !1 }, xw = { readContext: Bt, useCallback: jh, useContext: Bt, useEffect: ac, useImperativeHandle: Eh, useInsertionEffect: _h, useLayoutEffect: Sh, useMemo: Ch, useReducer: oc, useRef: xh, useState: function () { return oc(So) }, useDebugValue: lc, useDeferredValue: function (e) { var n = Vt(); return Nh(n, rt.memoizedState, e) }, useTransition: function () { var e = oc(So)[0], n = Vt().memoizedState; return [e, n] }, useMutableSource: fh, useSyncExternalStore: hh, useId: Th, unstable_isNewReconciler: !1 }, bw = { readContext: Bt, useCallback: jh, useContext: Bt, useEffect: ac, useImperativeHandle: Eh, useInsertionEffect: _h, useLayoutEffect: Sh, useMemo: Ch, useReducer: ic, useRef: xh, useState: function () { return ic(So) }, useDebugValue: lc, useDeferredValue: function (e) { var n = Vt(); return rt === null ? n.memoizedState = e : Nh(n, rt.memoizedState, e) }, useTransition: function () { var e = ic(So)[0], n = Vt().memoizedState; return [e, n] }, useMutableSource: fh, useSyncExternalStore: hh, useId: Th, unstable_isNewReconciler: !1 }; function Xt(e, n) { if (e && e.defaultProps) { n = X({}, n), e = e.defaultProps; for (var i in e) n[i] === void 0 && (n[i] = e[i]); return n } return n } function cc(e, n, i, c) { n = e.memoizedState, i = i(c, n), i = i == null ? n : X({}, n, i), e.memoizedState = i, e.lanes === 0 && (e.updateQueue.baseState = i) } var Mi = { isMounted: function (e) { return (e = e._reactInternals) ? fr(e) === e : !1 }, enqueueSetState: function (e, n, i) { e = e._reactInternals; var c = St(), h = Gn(e), g = jn(c, h); g.payload = n, i != null && (g.callback = i), n = Wn(e, g, h), n !== null && (tn(n, e, h, c), Pi(n, e, h)) }, enqueueReplaceState: function (e, n, i) { e = e._reactInternals; var c = St(), h = Gn(e), g = jn(c, h); g.tag = 1, g.payload = n, i != null && (g.callback = i), n = Wn(e, g, h), n !== null && (tn(n, e, h, c), Pi(n, e, h)) }, enqueueForceUpdate: function (e, n) { e = e._reactInternals; var i = St(), c = Gn(e), h = jn(i, c); h.tag = 2, n != null && (h.callback = n), n = Wn(e, h, c), n !== null && (tn(n, e, c, i), Pi(n, e, c)) } }; function Oh(e, n, i, c, h, g, w) { return e = e.stateNode, typeof e.shouldComponentUpdate == "function" ? e.shouldComponentUpdate(c, g, w) : n.prototype && n.prototype.isPureReactComponent ? !co(i, c) || !co(h, g) : !0 } function Ih(e, n, i) { var c = !1, h = Fn, g = n.contextType; return typeof g == "object" && g !== null ? g = Bt(g) : (h = Et(n) ? pr : pt.current, c = n.contextTypes, g = (c = c != null) ? Xr(e, h) : Fn), n = new n(i, g), e.memoizedState = n.state !== null && n.state !== void 0 ? n.state : null, n.updater = Mi, e.stateNode = n, n._reactInternals = e, c && (e = e.stateNode, e.__reactInternalMemoizedUnmaskedChildContext = h, e.__reactInternalMemoizedMaskedChildContext = g), n } function Dh(e, n, i, c) { e = n.state, typeof n.componentWillReceiveProps == "function" && n.componentWillReceiveProps(i, c), typeof n.UNSAFE_componentWillReceiveProps == "function" && n.UNSAFE_componentWillReceiveProps(i, c), n.state !== e && Mi.enqueueReplaceState(n, n.state, null) } function uc(e, n, i, c) { var h = e.stateNode; h.props = i, h.state = e.memoizedState, h.refs = {}, Jl(e); var g = n.contextType; typeof g == "object" && g !== null ? h.context = Bt(g) : (g = Et(n) ? pr : pt.current, h.context = Xr(e, g)), h.state = e.memoizedState, g = n.getDerivedStateFromProps, typeof g == "function" && (cc(e, n, g, i), h.state = e.memoizedState), typeof n.getDerivedStateFromProps == "function" || typeof h.getSnapshotBeforeUpdate == "function" || typeof h.UNSAFE_componentWillMount != "function" && typeof h.componentWillMount != "function" || (n = h.state, typeof h.componentWillMount == "function" && h.componentWillMount(), typeof h.UNSAFE_componentWillMount == "function" && h.UNSAFE_componentWillMount(), n !== h.state && Mi.enqueueReplaceState(h, h.state, null), Ri(e, i, h, c), h.state = e.memoizedState), typeof h.componentDidMount == "function" && (e.flags |= 4194308) } function is(e, n) {
    try { var i = "", c = n; do i += se(c), c = c.return; while (c); var h = i } catch (g) {
      h = `
Error generating stack: `+ g.message + `
`+ g.stack
    } return { value: e, source: n, stack: h, digest: null }
  } function dc(e, n, i) { return { value: e, source: null, stack: i ?? null, digest: n ?? null } } function fc(e, n) { try { console.error(n.value) } catch (i) { setTimeout(function () { throw i }) } } var _w = typeof WeakMap == "function" ? WeakMap : Map; function $h(e, n, i) { i = jn(-1, i), i.tag = 3, i.payload = { element: null }; var c = n.value; return i.callback = function () { Hi || (Hi = !0, Cc = c), fc(e, n) }, i } function Lh(e, n, i) { i = jn(-1, i), i.tag = 3; var c = e.type.getDerivedStateFromError; if (typeof c == "function") { var h = n.value; i.payload = function () { return c(h) }, i.callback = function () { fc(e, n) } } var g = e.stateNode; return g !== null && typeof g.componentDidCatch == "function" && (i.callback = function () { fc(e, n), typeof c != "function" && (Kn === null ? Kn = new Set([this]) : Kn.add(this)); var w = n.stack; this.componentDidCatch(n.value, { componentStack: w !== null ? w : "" }) }), i } function Mh(e, n, i) { var c = e.pingCache; if (c === null) { c = e.pingCache = new _w; var h = new Set; c.set(n, h) } else h = c.get(n), h === void 0 && (h = new Set, c.set(n, h)); h.has(i) || (h.add(i), e = $w.bind(null, e, n, i), n.then(e, e)) } function Uh(e) { do { var n; if ((n = e.tag === 13) && (n = e.memoizedState, n = n !== null ? n.dehydrated !== null : !0), n) return e; e = e.return } while (e !== null); return null } function zh(e, n, i, c, h) { return (e.mode & 1) === 0 ? (e === n ? e.flags |= 65536 : (e.flags |= 128, i.flags |= 131072, i.flags &= -52805, i.tag === 1 && (i.alternate === null ? i.tag = 17 : (n = jn(-1, 1), n.tag = 2, Wn(i, n, 1))), i.lanes |= 1), e) : (e.flags |= 65536, e.lanes = h, e) } var Sw = I.ReactCurrentOwner, jt = !1; function _t(e, n, i, c) { n.child = e === null ? ih(n, null, i, c) : ns(n, e.child, i, c) } function Fh(e, n, i, c, h) { i = i.render; var g = n.ref; return ss(n, h), c = rc(e, n, i, c, g, h), i = sc(), e !== null && !jt ? (n.updateQueue = e.updateQueue, n.flags &= -2053, e.lanes &= ~h, Cn(e, n, h)) : (He && i && zl(n), n.flags |= 1, _t(e, n, c, h), n.child) } function Bh(e, n, i, c, h) { if (e === null) { var g = i.type; return typeof g == "function" && !Ic(g) && g.defaultProps === void 0 && i.compare === null && i.defaultProps === void 0 ? (n.tag = 15, n.type = g, Vh(e, n, g, c, h)) : (e = Qi(i.type, null, c, n, n.mode, h), e.ref = n.ref, e.return = n, n.child = e) } if (g = e.child, (e.lanes & h) === 0) { var w = g.memoizedProps; if (i = i.compare, i = i !== null ? i : co, i(w, c) && e.ref === n.ref) return Cn(e, n, h) } return n.flags |= 1, e = Jn(g, c), e.ref = n.ref, e.return = n, n.child = e } function Vh(e, n, i, c, h) { if (e !== null) { var g = e.memoizedProps; if (co(g, c) && e.ref === n.ref) if (jt = !1, n.pendingProps = c = g, (e.lanes & h) !== 0) (e.flags & 131072) !== 0 && (jt = !0); else return n.lanes = e.lanes, Cn(e, n, h) } return hc(e, n, i, c, h) } function Wh(e, n, i) { var c = n.pendingProps, h = c.children, g = e !== null ? e.memoizedState : null; if (c.mode === "hidden") if ((n.mode & 1) === 0) n.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, Fe(ls, Dt), Dt |= i; else { if ((i & 1073741824) === 0) return e = g !== null ? g.baseLanes | i : i, n.lanes = n.childLanes = 1073741824, n.memoizedState = { baseLanes: e, cachePool: null, transitions: null }, n.updateQueue = null, Fe(ls, Dt), Dt |= e, null; n.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, c = g !== null ? g.baseLanes : i, Fe(ls, Dt), Dt |= c } else g !== null ? (c = g.baseLanes | i, n.memoizedState = null) : c = i, Fe(ls, Dt), Dt |= c; return _t(e, n, h, i), n.child } function Hh(e, n) { var i = n.ref; (e === null && i !== null || e !== null && e.ref !== i) && (n.flags |= 512, n.flags |= 2097152) } function hc(e, n, i, c, h) { var g = Et(i) ? pr : pt.current; return g = Xr(n, g), ss(n, h), i = rc(e, n, i, c, g, h), c = sc(), e !== null && !jt ? (n.updateQueue = e.updateQueue, n.flags &= -2053, e.lanes &= ~h, Cn(e, n, h)) : (He && c && zl(n), n.flags |= 1, _t(e, n, i, h), n.child) } function Kh(e, n, i, c, h) { if (Et(i)) { var g = !0; _i(n) } else g = !1; if (ss(n, h), n.stateNode === null) zi(e, n), Ih(n, i, c), uc(n, i, c, h), c = !0; else if (e === null) { var w = n.stateNode, N = n.memoizedProps; w.props = N; var A = w.context, W = i.contextType; typeof W == "object" && W !== null ? W = Bt(W) : (W = Et(i) ? pr : pt.current, W = Xr(n, W)); var J = i.getDerivedStateFromProps, Q = typeof J == "function" || typeof w.getSnapshotBeforeUpdate == "function"; Q || typeof w.UNSAFE_componentWillReceiveProps != "function" && typeof w.componentWillReceiveProps != "function" || (N !== c || A !== W) && Dh(n, w, c, W), Vn = !1; var Y = n.memoizedState; w.state = Y, Ri(n, c, w, h), A = n.memoizedState, N !== c || Y !== A || kt.current || Vn ? (typeof J == "function" && (cc(n, i, J, c), A = n.memoizedState), (N = Vn || Oh(n, i, N, c, Y, A, W)) ? (Q || typeof w.UNSAFE_componentWillMount != "function" && typeof w.componentWillMount != "function" || (typeof w.componentWillMount == "function" && w.componentWillMount(), typeof w.UNSAFE_componentWillMount == "function" && w.UNSAFE_componentWillMount()), typeof w.componentDidMount == "function" && (n.flags |= 4194308)) : (typeof w.componentDidMount == "function" && (n.flags |= 4194308), n.memoizedProps = c, n.memoizedState = A), w.props = c, w.state = A, w.context = W, c = N) : (typeof w.componentDidMount == "function" && (n.flags |= 4194308), c = !1) } else { w = n.stateNode, lh(e, n), N = n.memoizedProps, W = n.type === n.elementType ? N : Xt(n.type, N), w.props = W, Q = n.pendingProps, Y = w.context, A = i.contextType, typeof A == "object" && A !== null ? A = Bt(A) : (A = Et(i) ? pr : pt.current, A = Xr(n, A)); var ie = i.getDerivedStateFromProps; (J = typeof ie == "function" || typeof w.getSnapshotBeforeUpdate == "function") || typeof w.UNSAFE_componentWillReceiveProps != "function" && typeof w.componentWillReceiveProps != "function" || (N !== Q || Y !== A) && Dh(n, w, c, A), Vn = !1, Y = n.memoizedState, w.state = Y, Ri(n, c, w, h); var fe = n.memoizedState; N !== Q || Y !== fe || kt.current || Vn ? (typeof ie == "function" && (cc(n, i, ie, c), fe = n.memoizedState), (W = Vn || Oh(n, i, W, c, Y, fe, A) || !1) ? (J || typeof w.UNSAFE_componentWillUpdate != "function" && typeof w.componentWillUpdate != "function" || (typeof w.componentWillUpdate == "function" && w.componentWillUpdate(c, fe, A), typeof w.UNSAFE_componentWillUpdate == "function" && w.UNSAFE_componentWillUpdate(c, fe, A)), typeof w.componentDidUpdate == "function" && (n.flags |= 4), typeof w.getSnapshotBeforeUpdate == "function" && (n.flags |= 1024)) : (typeof w.componentDidUpdate != "function" || N === e.memoizedProps && Y === e.memoizedState || (n.flags |= 4), typeof w.getSnapshotBeforeUpdate != "function" || N === e.memoizedProps && Y === e.memoizedState || (n.flags |= 1024), n.memoizedProps = c, n.memoizedState = fe), w.props = c, w.state = fe, w.context = A, c = W) : (typeof w.componentDidUpdate != "function" || N === e.memoizedProps && Y === e.memoizedState || (n.flags |= 4), typeof w.getSnapshotBeforeUpdate != "function" || N === e.memoizedProps && Y === e.memoizedState || (n.flags |= 1024), c = !1) } return pc(e, n, i, c, g, h) } function pc(e, n, i, c, h, g) { Hh(e, n); var w = (n.flags & 128) !== 0; if (!c && !w) return h && Qf(n, i, !1), Cn(e, n, g); c = n.stateNode, Sw.current = n; var N = w && typeof i.getDerivedStateFromError != "function" ? null : c.render(); return n.flags |= 1, e !== null && w ? (n.child = ns(n, e.child, null, g), n.child = ns(n, null, N, g)) : _t(e, n, N, g), n.memoizedState = c.state, h && Qf(n, i, !0), n.child } function qh(e) { var n = e.stateNode; n.pendingContext ? Yf(e, n.pendingContext, n.pendingContext !== n.context) : n.context && Yf(e, n.context, !1), Ql(e, n.containerInfo) } function Gh(e, n, i, c, h) { return ts(), Wl(h), n.flags |= 256, _t(e, n, i, c), n.child } var mc = { dehydrated: null, treeContext: null, retryLane: 0 }; function gc(e) { return { baseLanes: e, cachePool: null, transitions: null } } function Yh(e, n, i) { var c = n.pendingProps, h = Ke.current, g = !1, w = (n.flags & 128) !== 0, N; if ((N = w) || (N = e !== null && e.memoizedState === null ? !1 : (h & 2) !== 0), N ? (g = !0, n.flags &= -129) : (e === null || e.memoizedState !== null) && (h |= 1), Fe(Ke, h & 1), e === null) return Vl(n), e = n.memoizedState, e !== null && (e = e.dehydrated, e !== null) ? ((n.mode & 1) === 0 ? n.lanes = 1 : e.data === "$!" ? n.lanes = 8 : n.lanes = 1073741824, null) : (w = c.children, e = c.fallback, g ? (c = n.mode, g = n.child, w = { mode: "hidden", children: w }, (c & 1) === 0 && g !== null ? (g.childLanes = 0, g.pendingProps = w) : g = Xi(w, c, 0, null), e = kr(e, c, i, null), g.return = n, e.return = n, g.sibling = e, n.child = g, n.child.memoizedState = gc(i), n.memoizedState = mc, e) : vc(n, w)); if (h = e.memoizedState, h !== null && (N = h.dehydrated, N !== null)) return kw(e, n, w, c, N, h, i); if (g) { g = c.fallback, w = n.mode, h = e.child, N = h.sibling; var A = { mode: "hidden", children: c.children }; return (w & 1) === 0 && n.child !== h ? (c = n.child, c.childLanes = 0, c.pendingProps = A, n.deletions = null) : (c = Jn(h, A), c.subtreeFlags = h.subtreeFlags & 14680064), N !== null ? g = Jn(N, g) : (g = kr(g, w, i, null), g.flags |= 2), g.return = n, c.return = n, c.sibling = g, n.child = c, c = g, g = n.child, w = e.child.memoizedState, w = w === null ? gc(i) : { baseLanes: w.baseLanes | i, cachePool: null, transitions: w.transitions }, g.memoizedState = w, g.childLanes = e.childLanes & ~i, n.memoizedState = mc, c } return g = e.child, e = g.sibling, c = Jn(g, { mode: "visible", children: c.children }), (n.mode & 1) === 0 && (c.lanes = i), c.return = n, c.sibling = null, e !== null && (i = n.deletions, i === null ? (n.deletions = [e], n.flags |= 16) : i.push(e)), n.child = c, n.memoizedState = null, c } function vc(e, n) { return n = Xi({ mode: "visible", children: n }, e.mode, 0, null), n.return = e, e.child = n } function Ui(e, n, i, c) { return c !== null && Wl(c), ns(n, e.child, null, i), e = vc(n, n.pendingProps.children), e.flags |= 2, n.memoizedState = null, e } function kw(e, n, i, c, h, g, w) { if (i) return n.flags & 256 ? (n.flags &= -257, c = dc(Error(s(422))), Ui(e, n, w, c)) : n.memoizedState !== null ? (n.child = e.child, n.flags |= 128, null) : (g = c.fallback, h = n.mode, c = Xi({ mode: "visible", children: c.children }, h, 0, null), g = kr(g, h, w, null), g.flags |= 2, c.return = n, g.return = n, c.sibling = g, n.child = c, (n.mode & 1) !== 0 && ns(n, e.child, null, w), n.child.memoizedState = gc(w), n.memoizedState = mc, g); if ((n.mode & 1) === 0) return Ui(e, n, w, null); if (h.data === "$!") { if (c = h.nextSibling && h.nextSibling.dataset, c) var N = c.dgst; return c = N, g = Error(s(419)), c = dc(g, c, void 0), Ui(e, n, w, c) } if (N = (w & e.childLanes) !== 0, jt || N) { if (c = lt, c !== null) { switch (w & -w) { case 4: h = 2; break; case 16: h = 8; break; case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: h = 32; break; case 536870912: h = 268435456; break; default: h = 0 }h = (h & (c.suspendedLanes | w)) !== 0 ? 0 : h, h !== 0 && h !== g.retryLane && (g.retryLane = h, En(e, h), tn(c, e, h, -1)) } return Oc(), c = dc(Error(s(421))), Ui(e, n, w, c) } return h.data === "$?" ? (n.flags |= 128, n.child = e.child, n = Lw.bind(null, e), h._reactRetry = n, null) : (e = g.treeContext, It = Un(h.nextSibling), Ot = n, He = !0, Qt = null, e !== null && (zt[Ft++] = Sn, zt[Ft++] = kn, zt[Ft++] = mr, Sn = e.id, kn = e.overflow, mr = n), n = vc(n, c.children), n.flags |= 4096, n) } function Jh(e, n, i) { e.lanes |= n; var c = e.alternate; c !== null && (c.lanes |= n), Gl(e.return, n, i) } function yc(e, n, i, c, h) { var g = e.memoizedState; g === null ? e.memoizedState = { isBackwards: n, rendering: null, renderingStartTime: 0, last: c, tail: i, tailMode: h } : (g.isBackwards = n, g.rendering = null, g.renderingStartTime = 0, g.last = c, g.tail = i, g.tailMode = h) } function Qh(e, n, i) { var c = n.pendingProps, h = c.revealOrder, g = c.tail; if (_t(e, n, c.children, i), c = Ke.current, (c & 2) !== 0) c = c & 1 | 2, n.flags |= 128; else { if (e !== null && (e.flags & 128) !== 0) e: for (e = n.child; e !== null;) { if (e.tag === 13) e.memoizedState !== null && Jh(e, i, n); else if (e.tag === 19) Jh(e, i, n); else if (e.child !== null) { e.child.return = e, e = e.child; continue } if (e === n) break e; for (; e.sibling === null;) { if (e.return === null || e.return === n) break e; e = e.return } e.sibling.return = e.return, e = e.sibling } c &= 1 } if (Fe(Ke, c), (n.mode & 1) === 0) n.memoizedState = null; else switch (h) { case "forwards": for (i = n.child, h = null; i !== null;)e = i.alternate, e !== null && Ai(e) === null && (h = i), i = i.sibling; i = h, i === null ? (h = n.child, n.child = null) : (h = i.sibling, i.sibling = null), yc(n, !1, h, i, g); break; case "backwards": for (i = null, h = n.child, n.child = null; h !== null;) { if (e = h.alternate, e !== null && Ai(e) === null) { n.child = h; break } e = h.sibling, h.sibling = i, i = h, h = e } yc(n, !0, i, null, g); break; case "together": yc(n, !1, null, null, void 0); break; default: n.memoizedState = null }return n.child } function zi(e, n) { (n.mode & 1) === 0 && e !== null && (e.alternate = null, n.alternate = null, n.flags |= 2) } function Cn(e, n, i) { if (e !== null && (n.dependencies = e.dependencies), xr |= n.lanes, (i & n.childLanes) === 0) return null; if (e !== null && n.child !== e.child) throw Error(s(153)); if (n.child !== null) { for (e = n.child, i = Jn(e, e.pendingProps), n.child = i, i.return = n; e.sibling !== null;)e = e.sibling, i = i.sibling = Jn(e, e.pendingProps), i.return = n; i.sibling = null } return n.child } function Ew(e, n, i) { switch (n.tag) { case 3: qh(n), ts(); break; case 5: dh(n); break; case 1: Et(n.type) && _i(n); break; case 4: Ql(n, n.stateNode.containerInfo); break; case 10: var c = n.type._context, h = n.memoizedProps.value; Fe(Ni, c._currentValue), c._currentValue = h; break; case 13: if (c = n.memoizedState, c !== null) return c.dehydrated !== null ? (Fe(Ke, Ke.current & 1), n.flags |= 128, null) : (i & n.child.childLanes) !== 0 ? Yh(e, n, i) : (Fe(Ke, Ke.current & 1), e = Cn(e, n, i), e !== null ? e.sibling : null); Fe(Ke, Ke.current & 1); break; case 19: if (c = (i & n.childLanes) !== 0, (e.flags & 128) !== 0) { if (c) return Qh(e, n, i); n.flags |= 128 } if (h = n.memoizedState, h !== null && (h.rendering = null, h.tail = null, h.lastEffect = null), Fe(Ke, Ke.current), c) break; return null; case 22: case 23: return n.lanes = 0, Wh(e, n, i) }return Cn(e, n, i) } var Xh, wc, Zh, ep; Xh = function (e, n) { for (var i = n.child; i !== null;) { if (i.tag === 5 || i.tag === 6) e.appendChild(i.stateNode); else if (i.tag !== 4 && i.child !== null) { i.child.return = i, i = i.child; continue } if (i === n) break; for (; i.sibling === null;) { if (i.return === null || i.return === n) return; i = i.return } i.sibling.return = i.return, i = i.sibling } }, wc = function () { }, Zh = function (e, n, i, c) { var h = e.memoizedProps; if (h !== c) { e = n.stateNode, yr(dn.current); var g = null; switch (i) { case "input": h = nt(e, h), c = nt(e, c), g = []; break; case "select": h = X({}, h, { value: void 0 }), c = X({}, c, { value: void 0 }), g = []; break; case "textarea": h = Qa(e, h), c = Qa(e, c), g = []; break; default: typeof h.onClick != "function" && typeof c.onClick == "function" && (e.onclick = wi) }Za(i, c); var w; i = null; for (W in h) if (!c.hasOwnProperty(W) && h.hasOwnProperty(W) && h[W] != null) if (W === "style") { var N = h[W]; for (w in N) N.hasOwnProperty(w) && (i || (i = {}), i[w] = "") } else W !== "dangerouslySetInnerHTML" && W !== "children" && W !== "suppressContentEditableWarning" && W !== "suppressHydrationWarning" && W !== "autoFocus" && (a.hasOwnProperty(W) ? g || (g = []) : (g = g || []).push(W, null)); for (W in c) { var A = c[W]; if (N = h?.[W], c.hasOwnProperty(W) && A !== N && (A != null || N != null)) if (W === "style") if (N) { for (w in N) !N.hasOwnProperty(w) || A && A.hasOwnProperty(w) || (i || (i = {}), i[w] = ""); for (w in A) A.hasOwnProperty(w) && N[w] !== A[w] && (i || (i = {}), i[w] = A[w]) } else i || (g || (g = []), g.push(W, i)), i = A; else W === "dangerouslySetInnerHTML" ? (A = A ? A.__html : void 0, N = N ? N.__html : void 0, A != null && N !== A && (g = g || []).push(W, A)) : W === "children" ? typeof A != "string" && typeof A != "number" || (g = g || []).push(W, "" + A) : W !== "suppressContentEditableWarning" && W !== "suppressHydrationWarning" && (a.hasOwnProperty(W) ? (A != null && W === "onScroll" && Ve("scroll", e), g || N === A || (g = [])) : (g = g || []).push(W, A)) } i && (g = g || []).push("style", i); var W = g; (n.updateQueue = W) && (n.flags |= 4) } }, ep = function (e, n, i, c) { i !== c && (n.flags |= 4) }; function Eo(e, n) { if (!He) switch (e.tailMode) { case "hidden": n = e.tail; for (var i = null; n !== null;)n.alternate !== null && (i = n), n = n.sibling; i === null ? e.tail = null : i.sibling = null; break; case "collapsed": i = e.tail; for (var c = null; i !== null;)i.alternate !== null && (c = i), i = i.sibling; c === null ? n || e.tail === null ? e.tail = null : e.tail.sibling = null : c.sibling = null } } function gt(e) { var n = e.alternate !== null && e.alternate.child === e.child, i = 0, c = 0; if (n) for (var h = e.child; h !== null;)i |= h.lanes | h.childLanes, c |= h.subtreeFlags & 14680064, c |= h.flags & 14680064, h.return = e, h = h.sibling; else for (h = e.child; h !== null;)i |= h.lanes | h.childLanes, c |= h.subtreeFlags, c |= h.flags, h.return = e, h = h.sibling; return e.subtreeFlags |= c, e.childLanes = i, n } function jw(e, n, i) { var c = n.pendingProps; switch (Fl(n), n.tag) { case 2: case 16: case 15: case 0: case 11: case 7: case 8: case 12: case 9: case 14: return gt(n), null; case 1: return Et(n.type) && bi(), gt(n), null; case 3: return c = n.stateNode, os(), We(kt), We(pt), ec(), c.pendingContext && (c.context = c.pendingContext, c.pendingContext = null), (e === null || e.child === null) && (ji(n) ? n.flags |= 4 : e === null || e.memoizedState.isDehydrated && (n.flags & 256) === 0 || (n.flags |= 1024, Qt !== null && (Pc(Qt), Qt = null))), wc(e, n), gt(n), null; case 5: Xl(n); var h = yr(xo.current); if (i = n.type, e !== null && n.stateNode != null) Zh(e, n, i, c, h), e.ref !== n.ref && (n.flags |= 512, n.flags |= 2097152); else { if (!c) { if (n.stateNode === null) throw Error(s(166)); return gt(n), null } if (e = yr(dn.current), ji(n)) { c = n.stateNode, i = n.type; var g = n.memoizedProps; switch (c[un] = n, c[mo] = g, e = (n.mode & 1) !== 0, i) { case "dialog": Ve("cancel", c), Ve("close", c); break; case "iframe": case "object": case "embed": Ve("load", c); break; case "video": case "audio": for (h = 0; h < fo.length; h++)Ve(fo[h], c); break; case "source": Ve("error", c); break; case "img": case "image": case "link": Ve("error", c), Ve("load", c); break; case "details": Ve("toggle", c); break; case "input": Mr(c, g), Ve("invalid", c); break; case "select": c._wrapperState = { wasMultiple: !!g.multiple }, Ve("invalid", c); break; case "textarea": $d(c, g), Ve("invalid", c) }Za(i, g), h = null; for (var w in g) if (g.hasOwnProperty(w)) { var N = g[w]; w === "children" ? typeof N == "string" ? c.textContent !== N && (g.suppressHydrationWarning !== !0 && yi(c.textContent, N, e), h = ["children", N]) : typeof N == "number" && c.textContent !== "" + N && (g.suppressHydrationWarning !== !0 && yi(c.textContent, N, e), h = ["children", "" + N]) : a.hasOwnProperty(w) && N != null && w === "onScroll" && Ve("scroll", c) } switch (i) { case "input": je(c), Dd(c, g, !0); break; case "textarea": je(c), Md(c); break; case "select": case "option": break; default: typeof g.onClick == "function" && (c.onclick = wi) }c = h, n.updateQueue = c, c !== null && (n.flags |= 4) } else { w = h.nodeType === 9 ? h : h.ownerDocument, e === "http://www.w3.org/1999/xhtml" && (e = Ud(i)), e === "http://www.w3.org/1999/xhtml" ? i === "script" ? (e = w.createElement("div"), e.innerHTML = "<script><\/script>", e = e.removeChild(e.firstChild)) : typeof c.is == "string" ? e = w.createElement(i, { is: c.is }) : (e = w.createElement(i), i === "select" && (w = e, c.multiple ? w.multiple = !0 : c.size && (w.size = c.size))) : e = w.createElementNS(e, i), e[un] = n, e[mo] = c, Xh(e, n, !1, !1), n.stateNode = e; e: { switch (w = el(i, c), i) { case "dialog": Ve("cancel", e), Ve("close", e), h = c; break; case "iframe": case "object": case "embed": Ve("load", e), h = c; break; case "video": case "audio": for (h = 0; h < fo.length; h++)Ve(fo[h], e); h = c; break; case "source": Ve("error", e), h = c; break; case "img": case "image": case "link": Ve("error", e), Ve("load", e), h = c; break; case "details": Ve("toggle", e), h = c; break; case "input": Mr(e, c), h = nt(e, c), Ve("invalid", e); break; case "option": h = c; break; case "select": e._wrapperState = { wasMultiple: !!c.multiple }, h = X({}, c, { value: void 0 }), Ve("invalid", e); break; case "textarea": $d(e, c), h = Qa(e, c), Ve("invalid", e); break; default: h = c }Za(i, h), N = h; for (g in N) if (N.hasOwnProperty(g)) { var A = N[g]; g === "style" ? Bd(e, A) : g === "dangerouslySetInnerHTML" ? (A = A ? A.__html : void 0, A != null && zd(e, A)) : g === "children" ? typeof A == "string" ? (i !== "textarea" || A !== "") && Ks(e, A) : typeof A == "number" && Ks(e, "" + A) : g !== "suppressContentEditableWarning" && g !== "suppressHydrationWarning" && g !== "autoFocus" && (a.hasOwnProperty(g) ? A != null && g === "onScroll" && Ve("scroll", e) : A != null && P(e, g, A, w)) } switch (i) { case "input": je(e), Dd(e, c, !1); break; case "textarea": je(e), Md(e); break; case "option": c.value != null && e.setAttribute("value", "" + le(c.value)); break; case "select": e.multiple = !!c.multiple, g = c.value, g != null ? zr(e, !!c.multiple, g, !1) : c.defaultValue != null && zr(e, !!c.multiple, c.defaultValue, !0); break; default: typeof h.onClick == "function" && (e.onclick = wi) }switch (i) { case "button": case "input": case "select": case "textarea": c = !!c.autoFocus; break e; case "img": c = !0; break e; default: c = !1 } } c && (n.flags |= 4) } n.ref !== null && (n.flags |= 512, n.flags |= 2097152) } return gt(n), null; case 6: if (e && n.stateNode != null) ep(e, n, e.memoizedProps, c); else { if (typeof c != "string" && n.stateNode === null) throw Error(s(166)); if (i = yr(xo.current), yr(dn.current), ji(n)) { if (c = n.stateNode, i = n.memoizedProps, c[un] = n, (g = c.nodeValue !== i) && (e = Ot, e !== null)) switch (e.tag) { case 3: yi(c.nodeValue, i, (e.mode & 1) !== 0); break; case 5: e.memoizedProps.suppressHydrationWarning !== !0 && yi(c.nodeValue, i, (e.mode & 1) !== 0) }g && (n.flags |= 4) } else c = (i.nodeType === 9 ? i : i.ownerDocument).createTextNode(c), c[un] = n, n.stateNode = c } return gt(n), null; case 13: if (We(Ke), c = n.memoizedState, e === null || e.memoizedState !== null && e.memoizedState.dehydrated !== null) { if (He && It !== null && (n.mode & 1) !== 0 && (n.flags & 128) === 0) rh(), ts(), n.flags |= 98560, g = !1; else if (g = ji(n), c !== null && c.dehydrated !== null) { if (e === null) { if (!g) throw Error(s(318)); if (g = n.memoizedState, g = g !== null ? g.dehydrated : null, !g) throw Error(s(317)); g[un] = n } else ts(), (n.flags & 128) === 0 && (n.memoizedState = null), n.flags |= 4; gt(n), g = !1 } else Qt !== null && (Pc(Qt), Qt = null), g = !0; if (!g) return n.flags & 65536 ? n : null } return (n.flags & 128) !== 0 ? (n.lanes = i, n) : (c = c !== null, c !== (e !== null && e.memoizedState !== null) && c && (n.child.flags |= 8192, (n.mode & 1) !== 0 && (e === null || (Ke.current & 1) !== 0 ? st === 0 && (st = 3) : Oc())), n.updateQueue !== null && (n.flags |= 4), gt(n), null); case 4: return os(), wc(e, n), e === null && ho(n.stateNode.containerInfo), gt(n), null; case 10: return ql(n.type._context), gt(n), null; case 17: return Et(n.type) && bi(), gt(n), null; case 19: if (We(Ke), g = n.memoizedState, g === null) return gt(n), null; if (c = (n.flags & 128) !== 0, w = g.rendering, w === null) if (c) Eo(g, !1); else { if (st !== 0 || e !== null && (e.flags & 128) !== 0) for (e = n.child; e !== null;) { if (w = Ai(e), w !== null) { for (n.flags |= 128, Eo(g, !1), c = w.updateQueue, c !== null && (n.updateQueue = c, n.flags |= 4), n.subtreeFlags = 0, c = i, i = n.child; i !== null;)g = i, e = c, g.flags &= 14680066, w = g.alternate, w === null ? (g.childLanes = 0, g.lanes = e, g.child = null, g.subtreeFlags = 0, g.memoizedProps = null, g.memoizedState = null, g.updateQueue = null, g.dependencies = null, g.stateNode = null) : (g.childLanes = w.childLanes, g.lanes = w.lanes, g.child = w.child, g.subtreeFlags = 0, g.deletions = null, g.memoizedProps = w.memoizedProps, g.memoizedState = w.memoizedState, g.updateQueue = w.updateQueue, g.type = w.type, e = w.dependencies, g.dependencies = e === null ? null : { lanes: e.lanes, firstContext: e.firstContext }), i = i.sibling; return Fe(Ke, Ke.current & 1 | 2), n.child } e = e.sibling } g.tail !== null && Ye() > cs && (n.flags |= 128, c = !0, Eo(g, !1), n.lanes = 4194304) } else { if (!c) if (e = Ai(w), e !== null) { if (n.flags |= 128, c = !0, i = e.updateQueue, i !== null && (n.updateQueue = i, n.flags |= 4), Eo(g, !0), g.tail === null && g.tailMode === "hidden" && !w.alternate && !He) return gt(n), null } else 2 * Ye() - g.renderingStartTime > cs && i !== 1073741824 && (n.flags |= 128, c = !0, Eo(g, !1), n.lanes = 4194304); g.isBackwards ? (w.sibling = n.child, n.child = w) : (i = g.last, i !== null ? i.sibling = w : n.child = w, g.last = w) } return g.tail !== null ? (n = g.tail, g.rendering = n, g.tail = n.sibling, g.renderingStartTime = Ye(), n.sibling = null, i = Ke.current, Fe(Ke, c ? i & 1 | 2 : i & 1), n) : (gt(n), null); case 22: case 23: return Ac(), c = n.memoizedState !== null, e !== null && e.memoizedState !== null !== c && (n.flags |= 8192), c && (n.mode & 1) !== 0 ? (Dt & 1073741824) !== 0 && (gt(n), n.subtreeFlags & 6 && (n.flags |= 8192)) : gt(n), null; case 24: return null; case 25: return null }throw Error(s(156, n.tag)) } function Cw(e, n) { switch (Fl(n), n.tag) { case 1: return Et(n.type) && bi(), e = n.flags, e & 65536 ? (n.flags = e & -65537 | 128, n) : null; case 3: return os(), We(kt), We(pt), ec(), e = n.flags, (e & 65536) !== 0 && (e & 128) === 0 ? (n.flags = e & -65537 | 128, n) : null; case 5: return Xl(n), null; case 13: if (We(Ke), e = n.memoizedState, e !== null && e.dehydrated !== null) { if (n.alternate === null) throw Error(s(340)); ts() } return e = n.flags, e & 65536 ? (n.flags = e & -65537 | 128, n) : null; case 19: return We(Ke), null; case 4: return os(), null; case 10: return ql(n.type._context), null; case 22: case 23: return Ac(), null; case 24: return null; default: return null } } var Fi = !1, vt = !1, Nw = typeof WeakSet == "function" ? WeakSet : Set, ce = null; function as(e, n) { var i = e.ref; if (i !== null) if (typeof i == "function") try { i(null) } catch (c) { Ge(e, n, c) } else i.current = null } function xc(e, n, i) { try { i() } catch (c) { Ge(e, n, c) } } var tp = !1; function Tw(e, n) { if (Al = ai, e = Of(), kl(e)) { if ("selectionStart" in e) var i = { start: e.selectionStart, end: e.selectionEnd }; else e: { i = (i = e.ownerDocument) && i.defaultView || window; var c = i.getSelection && i.getSelection(); if (c && c.rangeCount !== 0) { i = c.anchorNode; var h = c.anchorOffset, g = c.focusNode; c = c.focusOffset; try { i.nodeType, g.nodeType } catch { i = null; break e } var w = 0, N = -1, A = -1, W = 0, J = 0, Q = e, Y = null; t: for (; ;) { for (var ie; Q !== i || h !== 0 && Q.nodeType !== 3 || (N = w + h), Q !== g || c !== 0 && Q.nodeType !== 3 || (A = w + c), Q.nodeType === 3 && (w += Q.nodeValue.length), (ie = Q.firstChild) !== null;)Y = Q, Q = ie; for (; ;) { if (Q === e) break t; if (Y === i && ++W === h && (N = w), Y === g && ++J === c && (A = w), (ie = Q.nextSibling) !== null) break; Q = Y, Y = Q.parentNode } Q = ie } i = N === -1 || A === -1 ? null : { start: N, end: A } } else i = null } i = i || { start: 0, end: 0 } } else i = null; for (Ol = { focusedElem: e, selectionRange: i }, ai = !1, ce = n; ce !== null;)if (n = ce, e = n.child, (n.subtreeFlags & 1028) !== 0 && e !== null) e.return = n, ce = e; else for (; ce !== null;) { n = ce; try { var fe = n.alternate; if ((n.flags & 1024) !== 0) switch (n.tag) { case 0: case 11: case 15: break; case 1: if (fe !== null) { var me = fe.memoizedProps, Je = fe.memoizedState, z = n.stateNode, D = z.getSnapshotBeforeUpdate(n.elementType === n.type ? me : Xt(n.type, me), Je); z.__reactInternalSnapshotBeforeUpdate = D } break; case 3: var B = n.stateNode.containerInfo; B.nodeType === 1 ? B.textContent = "" : B.nodeType === 9 && B.documentElement && B.removeChild(B.documentElement); break; case 5: case 6: case 4: case 17: break; default: throw Error(s(163)) } } catch (Z) { Ge(n, n.return, Z) } if (e = n.sibling, e !== null) { e.return = n.return, ce = e; break } ce = n.return } return fe = tp, tp = !1, fe } function jo(e, n, i) { var c = n.updateQueue; if (c = c !== null ? c.lastEffect : null, c !== null) { var h = c = c.next; do { if ((h.tag & e) === e) { var g = h.destroy; h.destroy = void 0, g !== void 0 && xc(n, i, g) } h = h.next } while (h !== c) } } function Bi(e, n) { if (n = n.updateQueue, n = n !== null ? n.lastEffect : null, n !== null) { var i = n = n.next; do { if ((i.tag & e) === e) { var c = i.create; i.destroy = c() } i = i.next } while (i !== n) } } function bc(e) { var n = e.ref; if (n !== null) { var i = e.stateNode; switch (e.tag) { case 5: e = i; break; default: e = i }typeof n == "function" ? n(e) : n.current = e } } function np(e) { var n = e.alternate; n !== null && (e.alternate = null, np(n)), e.child = null, e.deletions = null, e.sibling = null, e.tag === 5 && (n = e.stateNode, n !== null && (delete n[un], delete n[mo], delete n[Ll], delete n[dw], delete n[fw])), e.stateNode = null, e.return = null, e.dependencies = null, e.memoizedProps = null, e.memoizedState = null, e.pendingProps = null, e.stateNode = null, e.updateQueue = null } function rp(e) { return e.tag === 5 || e.tag === 3 || e.tag === 4 } function sp(e) { e: for (; ;) { for (; e.sibling === null;) { if (e.return === null || rp(e.return)) return null; e = e.return } for (e.sibling.return = e.return, e = e.sibling; e.tag !== 5 && e.tag !== 6 && e.tag !== 18;) { if (e.flags & 2 || e.child === null || e.tag === 4) continue e; e.child.return = e, e = e.child } if (!(e.flags & 2)) return e.stateNode } } function _c(e, n, i) { var c = e.tag; if (c === 5 || c === 6) e = e.stateNode, n ? i.nodeType === 8 ? i.parentNode.insertBefore(e, n) : i.insertBefore(e, n) : (i.nodeType === 8 ? (n = i.parentNode, n.insertBefore(e, i)) : (n = i, n.appendChild(e)), i = i._reactRootContainer, i != null || n.onclick !== null || (n.onclick = wi)); else if (c !== 4 && (e = e.child, e !== null)) for (_c(e, n, i), e = e.sibling; e !== null;)_c(e, n, i), e = e.sibling } function Sc(e, n, i) { var c = e.tag; if (c === 5 || c === 6) e = e.stateNode, n ? i.insertBefore(e, n) : i.appendChild(e); else if (c !== 4 && (e = e.child, e !== null)) for (Sc(e, n, i), e = e.sibling; e !== null;)Sc(e, n, i), e = e.sibling } var dt = null, Zt = !1; function Hn(e, n, i) { for (i = i.child; i !== null;)op(e, n, i), i = i.sibling } function op(e, n, i) { if (cn && typeof cn.onCommitFiberUnmount == "function") try { cn.onCommitFiberUnmount(ti, i) } catch { } switch (i.tag) { case 5: vt || as(i, n); case 6: var c = dt, h = Zt; dt = null, Hn(e, n, i), dt = c, Zt = h, dt !== null && (Zt ? (e = dt, i = i.stateNode, e.nodeType === 8 ? e.parentNode.removeChild(i) : e.removeChild(i)) : dt.removeChild(i.stateNode)); break; case 18: dt !== null && (Zt ? (e = dt, i = i.stateNode, e.nodeType === 8 ? $l(e.parentNode, i) : e.nodeType === 1 && $l(e, i), ro(e)) : $l(dt, i.stateNode)); break; case 4: c = dt, h = Zt, dt = i.stateNode.containerInfo, Zt = !0, Hn(e, n, i), dt = c, Zt = h; break; case 0: case 11: case 14: case 15: if (!vt && (c = i.updateQueue, c !== null && (c = c.lastEffect, c !== null))) { h = c = c.next; do { var g = h, w = g.destroy; g = g.tag, w !== void 0 && ((g & 2) !== 0 || (g & 4) !== 0) && xc(i, n, w), h = h.next } while (h !== c) } Hn(e, n, i); break; case 1: if (!vt && (as(i, n), c = i.stateNode, typeof c.componentWillUnmount == "function")) try { c.props = i.memoizedProps, c.state = i.memoizedState, c.componentWillUnmount() } catch (N) { Ge(i, n, N) } Hn(e, n, i); break; case 21: Hn(e, n, i); break; case 22: i.mode & 1 ? (vt = (c = vt) || i.memoizedState !== null, Hn(e, n, i), vt = c) : Hn(e, n, i); break; default: Hn(e, n, i) } } function ip(e) { var n = e.updateQueue; if (n !== null) { e.updateQueue = null; var i = e.stateNode; i === null && (i = e.stateNode = new Nw), n.forEach(function (c) { var h = Mw.bind(null, e, c); i.has(c) || (i.add(c), c.then(h, h)) }) } } function en(e, n) { var i = n.deletions; if (i !== null) for (var c = 0; c < i.length; c++) { var h = i[c]; try { var g = e, w = n, N = w; e: for (; N !== null;) { switch (N.tag) { case 5: dt = N.stateNode, Zt = !1; break e; case 3: dt = N.stateNode.containerInfo, Zt = !0; break e; case 4: dt = N.stateNode.containerInfo, Zt = !0; break e }N = N.return } if (dt === null) throw Error(s(160)); op(g, w, h), dt = null, Zt = !1; var A = h.alternate; A !== null && (A.return = null), h.return = null } catch (W) { Ge(h, n, W) } } if (n.subtreeFlags & 12854) for (n = n.child; n !== null;)ap(n, e), n = n.sibling } function ap(e, n) { var i = e.alternate, c = e.flags; switch (e.tag) { case 0: case 11: case 14: case 15: if (en(n, e), hn(e), c & 4) { try { jo(3, e, e.return), Bi(3, e) } catch (me) { Ge(e, e.return, me) } try { jo(5, e, e.return) } catch (me) { Ge(e, e.return, me) } } break; case 1: en(n, e), hn(e), c & 512 && i !== null && as(i, i.return); break; case 5: if (en(n, e), hn(e), c & 512 && i !== null && as(i, i.return), e.flags & 32) { var h = e.stateNode; try { Ks(h, "") } catch (me) { Ge(e, e.return, me) } } if (c & 4 && (h = e.stateNode, h != null)) { var g = e.memoizedProps, w = i !== null ? i.memoizedProps : g, N = e.type, A = e.updateQueue; if (e.updateQueue = null, A !== null) try { N === "input" && g.type === "radio" && g.name != null && Ur(h, g), el(N, w); var W = el(N, g); for (w = 0; w < A.length; w += 2) { var J = A[w], Q = A[w + 1]; J === "style" ? Bd(h, Q) : J === "dangerouslySetInnerHTML" ? zd(h, Q) : J === "children" ? Ks(h, Q) : P(h, J, Q, W) } switch (N) { case "input": dr(h, g); break; case "textarea": Ld(h, g); break; case "select": var Y = h._wrapperState.wasMultiple; h._wrapperState.wasMultiple = !!g.multiple; var ie = g.value; ie != null ? zr(h, !!g.multiple, ie, !1) : Y !== !!g.multiple && (g.defaultValue != null ? zr(h, !!g.multiple, g.defaultValue, !0) : zr(h, !!g.multiple, g.multiple ? [] : "", !1)) }h[mo] = g } catch (me) { Ge(e, e.return, me) } } break; case 6: if (en(n, e), hn(e), c & 4) { if (e.stateNode === null) throw Error(s(162)); h = e.stateNode, g = e.memoizedProps; try { h.nodeValue = g } catch (me) { Ge(e, e.return, me) } } break; case 3: if (en(n, e), hn(e), c & 4 && i !== null && i.memoizedState.isDehydrated) try { ro(n.containerInfo) } catch (me) { Ge(e, e.return, me) } break; case 4: en(n, e), hn(e); break; case 13: en(n, e), hn(e), h = e.child, h.flags & 8192 && (g = h.memoizedState !== null, h.stateNode.isHidden = g, !g || h.alternate !== null && h.alternate.memoizedState !== null || (jc = Ye())), c & 4 && ip(e); break; case 22: if (J = i !== null && i.memoizedState !== null, e.mode & 1 ? (vt = (W = vt) || J, en(n, e), vt = W) : en(n, e), hn(e), c & 8192) { if (W = e.memoizedState !== null, (e.stateNode.isHidden = W) && !J && (e.mode & 1) !== 0) for (ce = e, J = e.child; J !== null;) { for (Q = ce = J; ce !== null;) { switch (Y = ce, ie = Y.child, Y.tag) { case 0: case 11: case 14: case 15: jo(4, Y, Y.return); break; case 1: as(Y, Y.return); var fe = Y.stateNode; if (typeof fe.componentWillUnmount == "function") { c = Y, i = Y.return; try { n = c, fe.props = n.memoizedProps, fe.state = n.memoizedState, fe.componentWillUnmount() } catch (me) { Ge(c, i, me) } } break; case 5: as(Y, Y.return); break; case 22: if (Y.memoizedState !== null) { up(Q); continue } }ie !== null ? (ie.return = Y, ce = ie) : up(Q) } J = J.sibling } e: for (J = null, Q = e; ;) { if (Q.tag === 5) { if (J === null) { J = Q; try { h = Q.stateNode, W ? (g = h.style, typeof g.setProperty == "function" ? g.setProperty("display", "none", "important") : g.display = "none") : (N = Q.stateNode, A = Q.memoizedProps.style, w = A != null && A.hasOwnProperty("display") ? A.display : null, N.style.display = Fd("display", w)) } catch (me) { Ge(e, e.return, me) } } } else if (Q.tag === 6) { if (J === null) try { Q.stateNode.nodeValue = W ? "" : Q.memoizedProps } catch (me) { Ge(e, e.return, me) } } else if ((Q.tag !== 22 && Q.tag !== 23 || Q.memoizedState === null || Q === e) && Q.child !== null) { Q.child.return = Q, Q = Q.child; continue } if (Q === e) break e; for (; Q.sibling === null;) { if (Q.return === null || Q.return === e) break e; J === Q && (J = null), Q = Q.return } J === Q && (J = null), Q.sibling.return = Q.return, Q = Q.sibling } } break; case 19: en(n, e), hn(e), c & 4 && ip(e); break; case 21: break; default: en(n, e), hn(e) } } function hn(e) { var n = e.flags; if (n & 2) { try { e: { for (var i = e.return; i !== null;) { if (rp(i)) { var c = i; break e } i = i.return } throw Error(s(160)) } switch (c.tag) { case 5: var h = c.stateNode; c.flags & 32 && (Ks(h, ""), c.flags &= -33); var g = sp(e); Sc(e, g, h); break; case 3: case 4: var w = c.stateNode.containerInfo, N = sp(e); _c(e, N, w); break; default: throw Error(s(161)) } } catch (A) { Ge(e, e.return, A) } e.flags &= -3 } n & 4096 && (e.flags &= -4097) } function Pw(e, n, i) { ce = e, lp(e) } function lp(e, n, i) { for (var c = (e.mode & 1) !== 0; ce !== null;) { var h = ce, g = h.child; if (h.tag === 22 && c) { var w = h.memoizedState !== null || Fi; if (!w) { var N = h.alternate, A = N !== null && N.memoizedState !== null || vt; N = Fi; var W = vt; if (Fi = w, (vt = A) && !W) for (ce = h; ce !== null;)w = ce, A = w.child, w.tag === 22 && w.memoizedState !== null ? dp(h) : A !== null ? (A.return = w, ce = A) : dp(h); for (; g !== null;)ce = g, lp(g), g = g.sibling; ce = h, Fi = N, vt = W } cp(e) } else (h.subtreeFlags & 8772) !== 0 && g !== null ? (g.return = h, ce = g) : cp(e) } } function cp(e) { for (; ce !== null;) { var n = ce; if ((n.flags & 8772) !== 0) { var i = n.alternate; try { if ((n.flags & 8772) !== 0) switch (n.tag) { case 0: case 11: case 15: vt || Bi(5, n); break; case 1: var c = n.stateNode; if (n.flags & 4 && !vt) if (i === null) c.componentDidMount(); else { var h = n.elementType === n.type ? i.memoizedProps : Xt(n.type, i.memoizedProps); c.componentDidUpdate(h, i.memoizedState, c.__reactInternalSnapshotBeforeUpdate) } var g = n.updateQueue; g !== null && uh(n, g, c); break; case 3: var w = n.updateQueue; if (w !== null) { if (i = null, n.child !== null) switch (n.child.tag) { case 5: i = n.child.stateNode; break; case 1: i = n.child.stateNode }uh(n, w, i) } break; case 5: var N = n.stateNode; if (i === null && n.flags & 4) { i = N; var A = n.memoizedProps; switch (n.type) { case "button": case "input": case "select": case "textarea": A.autoFocus && i.focus(); break; case "img": A.src && (i.src = A.src) } } break; case 6: break; case 4: break; case 12: break; case 13: if (n.memoizedState === null) { var W = n.alternate; if (W !== null) { var J = W.memoizedState; if (J !== null) { var Q = J.dehydrated; Q !== null && ro(Q) } } } break; case 19: case 17: case 21: case 22: case 23: case 25: break; default: throw Error(s(163)) }vt || n.flags & 512 && bc(n) } catch (Y) { Ge(n, n.return, Y) } } if (n === e) { ce = null; break } if (i = n.sibling, i !== null) { i.return = n.return, ce = i; break } ce = n.return } } function up(e) { for (; ce !== null;) { var n = ce; if (n === e) { ce = null; break } var i = n.sibling; if (i !== null) { i.return = n.return, ce = i; break } ce = n.return } } function dp(e) { for (; ce !== null;) { var n = ce; try { switch (n.tag) { case 0: case 11: case 15: var i = n.return; try { Bi(4, n) } catch (A) { Ge(n, i, A) } break; case 1: var c = n.stateNode; if (typeof c.componentDidMount == "function") { var h = n.return; try { c.componentDidMount() } catch (A) { Ge(n, h, A) } } var g = n.return; try { bc(n) } catch (A) { Ge(n, g, A) } break; case 5: var w = n.return; try { bc(n) } catch (A) { Ge(n, w, A) } } } catch (A) { Ge(n, n.return, A) } if (n === e) { ce = null; break } var N = n.sibling; if (N !== null) { N.return = n.return, ce = N; break } ce = n.return } } var Rw = Math.ceil, Vi = I.ReactCurrentDispatcher, kc = I.ReactCurrentOwner, Wt = I.ReactCurrentBatchConfig, Oe = 0, lt = null, Ze = null, ft = 0, Dt = 0, ls = zn(0), st = 0, Co = null, xr = 0, Wi = 0, Ec = 0, No = null, Ct = null, jc = 0, cs = 1 / 0, Nn = null, Hi = !1, Cc = null, Kn = null, Ki = !1, qn = null, qi = 0, To = 0, Nc = null, Gi = -1, Yi = 0; function St() { return (Oe & 6) !== 0 ? Ye() : Gi !== -1 ? Gi : Gi = Ye() } function Gn(e) { return (e.mode & 1) === 0 ? 1 : (Oe & 2) !== 0 && ft !== 0 ? ft & -ft : pw.transition !== null ? (Yi === 0 && (Yi = rf()), Yi) : (e = Me, e !== 0 || (e = window.event, e = e === void 0 ? 16 : hf(e.type)), e) } function tn(e, n, i, c) { if (50 < To) throw To = 0, Nc = null, Error(s(185)); Xs(e, i, c), ((Oe & 2) === 0 || e !== lt) && (e === lt && ((Oe & 2) === 0 && (Wi |= i), st === 4 && Yn(e, ft)), Nt(e, c), i === 1 && Oe === 0 && (n.mode & 1) === 0 && (cs = Ye() + 500, Si && Bn())) } function Nt(e, n) { var i = e.callbackNode; p0(e, n); var c = si(e, e === lt ? ft : 0); if (c === 0) i !== null && ef(i), e.callbackNode = null, e.callbackPriority = 0; else if (n = c & -c, e.callbackPriority !== n) { if (i != null && ef(i), n === 1) e.tag === 0 ? hw(hp.bind(null, e)) : Xf(hp.bind(null, e)), cw(function () { (Oe & 6) === 0 && Bn() }), i = null; else { switch (sf(c)) { case 1: i = al; break; case 4: i = tf; break; case 16: i = ei; break; case 536870912: i = nf; break; default: i = ei }i = bp(i, fp.bind(null, e)) } e.callbackPriority = n, e.callbackNode = i } } function fp(e, n) { if (Gi = -1, Yi = 0, (Oe & 6) !== 0) throw Error(s(327)); var i = e.callbackNode; if (us() && e.callbackNode !== i) return null; var c = si(e, e === lt ? ft : 0); if (c === 0) return null; if ((c & 30) !== 0 || (c & e.expiredLanes) !== 0 || n) n = Ji(e, c); else { n = c; var h = Oe; Oe |= 2; var g = mp(); (lt !== e || ft !== n) && (Nn = null, cs = Ye() + 500, _r(e, n)); do try { Iw(); break } catch (N) { pp(e, N) } while (!0); Kl(), Vi.current = g, Oe = h, Ze !== null ? n = 0 : (lt = null, ft = 0, n = st) } if (n !== 0) { if (n === 2 && (h = ll(e), h !== 0 && (c = h, n = Tc(e, h))), n === 1) throw i = Co, _r(e, 0), Yn(e, c), Nt(e, Ye()), i; if (n === 6) Yn(e, c); else { if (h = e.current.alternate, (c & 30) === 0 && !Aw(h) && (n = Ji(e, c), n === 2 && (g = ll(e), g !== 0 && (c = g, n = Tc(e, g))), n === 1)) throw i = Co, _r(e, 0), Yn(e, c), Nt(e, Ye()), i; switch (e.finishedWork = h, e.finishedLanes = c, n) { case 0: case 1: throw Error(s(345)); case 2: Sr(e, Ct, Nn); break; case 3: if (Yn(e, c), (c & 130023424) === c && (n = jc + 500 - Ye(), 10 < n)) { if (si(e, 0) !== 0) break; if (h = e.suspendedLanes, (h & c) !== c) { St(), e.pingedLanes |= e.suspendedLanes & h; break } e.timeoutHandle = Dl(Sr.bind(null, e, Ct, Nn), n); break } Sr(e, Ct, Nn); break; case 4: if (Yn(e, c), (c & 4194240) === c) break; for (n = e.eventTimes, h = -1; 0 < c;) { var w = 31 - Yt(c); g = 1 << w, w = n[w], w > h && (h = w), c &= ~g } if (c = h, c = Ye() - c, c = (120 > c ? 120 : 480 > c ? 480 : 1080 > c ? 1080 : 1920 > c ? 1920 : 3e3 > c ? 3e3 : 4320 > c ? 4320 : 1960 * Rw(c / 1960)) - c, 10 < c) { e.timeoutHandle = Dl(Sr.bind(null, e, Ct, Nn), c); break } Sr(e, Ct, Nn); break; case 5: Sr(e, Ct, Nn); break; default: throw Error(s(329)) } } } return Nt(e, Ye()), e.callbackNode === i ? fp.bind(null, e) : null } function Tc(e, n) { var i = No; return e.current.memoizedState.isDehydrated && (_r(e, n).flags |= 256), e = Ji(e, n), e !== 2 && (n = Ct, Ct = i, n !== null && Pc(n)), e } function Pc(e) { Ct === null ? Ct = e : Ct.push.apply(Ct, e) } function Aw(e) { for (var n = e; ;) { if (n.flags & 16384) { var i = n.updateQueue; if (i !== null && (i = i.stores, i !== null)) for (var c = 0; c < i.length; c++) { var h = i[c], g = h.getSnapshot; h = h.value; try { if (!Jt(g(), h)) return !1 } catch { return !1 } } } if (i = n.child, n.subtreeFlags & 16384 && i !== null) i.return = n, n = i; else { if (n === e) break; for (; n.sibling === null;) { if (n.return === null || n.return === e) return !0; n = n.return } n.sibling.return = n.return, n = n.sibling } } return !0 } function Yn(e, n) { for (n &= ~Ec, n &= ~Wi, e.suspendedLanes |= n, e.pingedLanes &= ~n, e = e.expirationTimes; 0 < n;) { var i = 31 - Yt(n), c = 1 << i; e[i] = -1, n &= ~c } } function hp(e) { if ((Oe & 6) !== 0) throw Error(s(327)); us(); var n = si(e, 0); if ((n & 1) === 0) return Nt(e, Ye()), null; var i = Ji(e, n); if (e.tag !== 0 && i === 2) { var c = ll(e); c !== 0 && (n = c, i = Tc(e, c)) } if (i === 1) throw i = Co, _r(e, 0), Yn(e, n), Nt(e, Ye()), i; if (i === 6) throw Error(s(345)); return e.finishedWork = e.current.alternate, e.finishedLanes = n, Sr(e, Ct, Nn), Nt(e, Ye()), null } function Rc(e, n) { var i = Oe; Oe |= 1; try { return e(n) } finally { Oe = i, Oe === 0 && (cs = Ye() + 500, Si && Bn()) } } function br(e) { qn !== null && qn.tag === 0 && (Oe & 6) === 0 && us(); var n = Oe; Oe |= 1; var i = Wt.transition, c = Me; try { if (Wt.transition = null, Me = 1, e) return e() } finally { Me = c, Wt.transition = i, Oe = n, (Oe & 6) === 0 && Bn() } } function Ac() { Dt = ls.current, We(ls) } function _r(e, n) { e.finishedWork = null, e.finishedLanes = 0; var i = e.timeoutHandle; if (i !== -1 && (e.timeoutHandle = -1, lw(i)), Ze !== null) for (i = Ze.return; i !== null;) { var c = i; switch (Fl(c), c.tag) { case 1: c = c.type.childContextTypes, c != null && bi(); break; case 3: os(), We(kt), We(pt), ec(); break; case 5: Xl(c); break; case 4: os(); break; case 13: We(Ke); break; case 19: We(Ke); break; case 10: ql(c.type._context); break; case 22: case 23: Ac() }i = i.return } if (lt = e, Ze = e = Jn(e.current, null), ft = Dt = n, st = 0, Co = null, Ec = Wi = xr = 0, Ct = No = null, vr !== null) { for (n = 0; n < vr.length; n++)if (i = vr[n], c = i.interleaved, c !== null) { i.interleaved = null; var h = c.next, g = i.pending; if (g !== null) { var w = g.next; g.next = h, c.next = w } i.pending = c } vr = null } return e } function pp(e, n) { do { var i = Ze; try { if (Kl(), Oi.current = Li, Ii) { for (var c = qe.memoizedState; c !== null;) { var h = c.queue; h !== null && (h.pending = null), c = c.next } Ii = !1 } if (wr = 0, at = rt = qe = null, bo = !1, _o = 0, kc.current = null, i === null || i.return === null) { st = 1, Co = n, Ze = null; break } e: { var g = e, w = i.return, N = i, A = n; if (n = ft, N.flags |= 32768, A !== null && typeof A == "object" && typeof A.then == "function") { var W = A, J = N, Q = J.tag; if ((J.mode & 1) === 0 && (Q === 0 || Q === 11 || Q === 15)) { var Y = J.alternate; Y ? (J.updateQueue = Y.updateQueue, J.memoizedState = Y.memoizedState, J.lanes = Y.lanes) : (J.updateQueue = null, J.memoizedState = null) } var ie = Uh(w); if (ie !== null) { ie.flags &= -257, zh(ie, w, N, g, n), ie.mode & 1 && Mh(g, W, n), n = ie, A = W; var fe = n.updateQueue; if (fe === null) { var me = new Set; me.add(A), n.updateQueue = me } else fe.add(A); break e } else { if ((n & 1) === 0) { Mh(g, W, n), Oc(); break e } A = Error(s(426)) } } else if (He && N.mode & 1) { var Je = Uh(w); if (Je !== null) { (Je.flags & 65536) === 0 && (Je.flags |= 256), zh(Je, w, N, g, n), Wl(is(A, N)); break e } } g = A = is(A, N), st !== 4 && (st = 2), No === null ? No = [g] : No.push(g), g = w; do { switch (g.tag) { case 3: g.flags |= 65536, n &= -n, g.lanes |= n; var z = $h(g, A, n); ch(g, z); break e; case 1: N = A; var D = g.type, B = g.stateNode; if ((g.flags & 128) === 0 && (typeof D.getDerivedStateFromError == "function" || B !== null && typeof B.componentDidCatch == "function" && (Kn === null || !Kn.has(B)))) { g.flags |= 65536, n &= -n, g.lanes |= n; var Z = Lh(g, N, n); ch(g, Z); break e } }g = g.return } while (g !== null) } vp(i) } catch (ge) { n = ge, Ze === i && i !== null && (Ze = i = i.return); continue } break } while (!0) } function mp() { var e = Vi.current; return Vi.current = Li, e === null ? Li : e } function Oc() { (st === 0 || st === 3 || st === 2) && (st = 4), lt === null || (xr & 268435455) === 0 && (Wi & 268435455) === 0 || Yn(lt, ft) } function Ji(e, n) { var i = Oe; Oe |= 2; var c = mp(); (lt !== e || ft !== n) && (Nn = null, _r(e, n)); do try { Ow(); break } catch (h) { pp(e, h) } while (!0); if (Kl(), Oe = i, Vi.current = c, Ze !== null) throw Error(s(261)); return lt = null, ft = 0, st } function Ow() { for (; Ze !== null;)gp(Ze) } function Iw() { for (; Ze !== null && !o0();)gp(Ze) } function gp(e) { var n = xp(e.alternate, e, Dt); e.memoizedProps = e.pendingProps, n === null ? vp(e) : Ze = n, kc.current = null } function vp(e) { var n = e; do { var i = n.alternate; if (e = n.return, (n.flags & 32768) === 0) { if (i = jw(i, n, Dt), i !== null) { Ze = i; return } } else { if (i = Cw(i, n), i !== null) { i.flags &= 32767, Ze = i; return } if (e !== null) e.flags |= 32768, e.subtreeFlags = 0, e.deletions = null; else { st = 6, Ze = null; return } } if (n = n.sibling, n !== null) { Ze = n; return } Ze = n = e } while (n !== null); st === 0 && (st = 5) } function Sr(e, n, i) { var c = Me, h = Wt.transition; try { Wt.transition = null, Me = 1, Dw(e, n, i, c) } finally { Wt.transition = h, Me = c } return null } function Dw(e, n, i, c) { do us(); while (qn !== null); if ((Oe & 6) !== 0) throw Error(s(327)); i = e.finishedWork; var h = e.finishedLanes; if (i === null) return null; if (e.finishedWork = null, e.finishedLanes = 0, i === e.current) throw Error(s(177)); e.callbackNode = null, e.callbackPriority = 0; var g = i.lanes | i.childLanes; if (m0(e, g), e === lt && (Ze = lt = null, ft = 0), (i.subtreeFlags & 2064) === 0 && (i.flags & 2064) === 0 || Ki || (Ki = !0, bp(ei, function () { return us(), null })), g = (i.flags & 15990) !== 0, (i.subtreeFlags & 15990) !== 0 || g) { g = Wt.transition, Wt.transition = null; var w = Me; Me = 1; var N = Oe; Oe |= 4, kc.current = null, Tw(e, i), ap(i, e), tw(Ol), ai = !!Al, Ol = Al = null, e.current = i, Pw(i), i0(), Oe = N, Me = w, Wt.transition = g } else e.current = i; if (Ki && (Ki = !1, qn = e, qi = h), g = e.pendingLanes, g === 0 && (Kn = null), c0(i.stateNode), Nt(e, Ye()), n !== null) for (c = e.onRecoverableError, i = 0; i < n.length; i++)h = n[i], c(h.value, { componentStack: h.stack, digest: h.digest }); if (Hi) throw Hi = !1, e = Cc, Cc = null, e; return (qi & 1) !== 0 && e.tag !== 0 && us(), g = e.pendingLanes, (g & 1) !== 0 ? e === Nc ? To++ : (To = 0, Nc = e) : To = 0, Bn(), null } function us() { if (qn !== null) { var e = sf(qi), n = Wt.transition, i = Me; try { if (Wt.transition = null, Me = 16 > e ? 16 : e, qn === null) var c = !1; else { if (e = qn, qn = null, qi = 0, (Oe & 6) !== 0) throw Error(s(331)); var h = Oe; for (Oe |= 4, ce = e.current; ce !== null;) { var g = ce, w = g.child; if ((ce.flags & 16) !== 0) { var N = g.deletions; if (N !== null) { for (var A = 0; A < N.length; A++) { var W = N[A]; for (ce = W; ce !== null;) { var J = ce; switch (J.tag) { case 0: case 11: case 15: jo(8, J, g) }var Q = J.child; if (Q !== null) Q.return = J, ce = Q; else for (; ce !== null;) { J = ce; var Y = J.sibling, ie = J.return; if (np(J), J === W) { ce = null; break } if (Y !== null) { Y.return = ie, ce = Y; break } ce = ie } } } var fe = g.alternate; if (fe !== null) { var me = fe.child; if (me !== null) { fe.child = null; do { var Je = me.sibling; me.sibling = null, me = Je } while (me !== null) } } ce = g } } if ((g.subtreeFlags & 2064) !== 0 && w !== null) w.return = g, ce = w; else e: for (; ce !== null;) { if (g = ce, (g.flags & 2048) !== 0) switch (g.tag) { case 0: case 11: case 15: jo(9, g, g.return) }var z = g.sibling; if (z !== null) { z.return = g.return, ce = z; break e } ce = g.return } } var D = e.current; for (ce = D; ce !== null;) { w = ce; var B = w.child; if ((w.subtreeFlags & 2064) !== 0 && B !== null) B.return = w, ce = B; else e: for (w = D; ce !== null;) { if (N = ce, (N.flags & 2048) !== 0) try { switch (N.tag) { case 0: case 11: case 15: Bi(9, N) } } catch (ge) { Ge(N, N.return, ge) } if (N === w) { ce = null; break e } var Z = N.sibling; if (Z !== null) { Z.return = N.return, ce = Z; break e } ce = N.return } } if (Oe = h, Bn(), cn && typeof cn.onPostCommitFiberRoot == "function") try { cn.onPostCommitFiberRoot(ti, e) } catch { } c = !0 } return c } finally { Me = i, Wt.transition = n } } return !1 } function yp(e, n, i) { n = is(i, n), n = $h(e, n, 1), e = Wn(e, n, 1), n = St(), e !== null && (Xs(e, 1, n), Nt(e, n)) } function Ge(e, n, i) { if (e.tag === 3) yp(e, e, i); else for (; n !== null;) { if (n.tag === 3) { yp(n, e, i); break } else if (n.tag === 1) { var c = n.stateNode; if (typeof n.type.getDerivedStateFromError == "function" || typeof c.componentDidCatch == "function" && (Kn === null || !Kn.has(c))) { e = is(i, e), e = Lh(n, e, 1), n = Wn(n, e, 1), e = St(), n !== null && (Xs(n, 1, e), Nt(n, e)); break } } n = n.return } } function $w(e, n, i) { var c = e.pingCache; c !== null && c.delete(n), n = St(), e.pingedLanes |= e.suspendedLanes & i, lt === e && (ft & i) === i && (st === 4 || st === 3 && (ft & 130023424) === ft && 500 > Ye() - jc ? _r(e, 0) : Ec |= i), Nt(e, n) } function wp(e, n) { n === 0 && ((e.mode & 1) === 0 ? n = 1 : (n = ri, ri <<= 1, (ri & 130023424) === 0 && (ri = 4194304))); var i = St(); e = En(e, n), e !== null && (Xs(e, n, i), Nt(e, i)) } function Lw(e) { var n = e.memoizedState, i = 0; n !== null && (i = n.retryLane), wp(e, i) } function Mw(e, n) { var i = 0; switch (e.tag) { case 13: var c = e.stateNode, h = e.memoizedState; h !== null && (i = h.retryLane); break; case 19: c = e.stateNode; break; default: throw Error(s(314)) }c !== null && c.delete(n), wp(e, i) } var xp; xp = function (e, n, i) { if (e !== null) if (e.memoizedProps !== n.pendingProps || kt.current) jt = !0; else { if ((e.lanes & i) === 0 && (n.flags & 128) === 0) return jt = !1, Ew(e, n, i); jt = (e.flags & 131072) !== 0 } else jt = !1, He && (n.flags & 1048576) !== 0 && Zf(n, Ei, n.index); switch (n.lanes = 0, n.tag) { case 2: var c = n.type; zi(e, n), e = n.pendingProps; var h = Xr(n, pt.current); ss(n, i), h = rc(null, n, c, e, h, i); var g = sc(); return n.flags |= 1, typeof h == "object" && h !== null && typeof h.render == "function" && h.$$typeof === void 0 ? (n.tag = 1, n.memoizedState = null, n.updateQueue = null, Et(c) ? (g = !0, _i(n)) : g = !1, n.memoizedState = h.state !== null && h.state !== void 0 ? h.state : null, Jl(n), h.updater = Mi, n.stateNode = h, h._reactInternals = n, uc(n, c, e, i), n = pc(null, n, c, !0, g, i)) : (n.tag = 0, He && g && zl(n), _t(null, n, h, i), n = n.child), n; case 16: c = n.elementType; e: { switch (zi(e, n), e = n.pendingProps, h = c._init, c = h(c._payload), n.type = c, h = n.tag = zw(c), e = Xt(c, e), h) { case 0: n = hc(null, n, c, e, i); break e; case 1: n = Kh(null, n, c, e, i); break e; case 11: n = Fh(null, n, c, e, i); break e; case 14: n = Bh(null, n, c, Xt(c.type, e), i); break e }throw Error(s(306, c, "")) } return n; case 0: return c = n.type, h = n.pendingProps, h = n.elementType === c ? h : Xt(c, h), hc(e, n, c, h, i); case 1: return c = n.type, h = n.pendingProps, h = n.elementType === c ? h : Xt(c, h), Kh(e, n, c, h, i); case 3: e: { if (qh(n), e === null) throw Error(s(387)); c = n.pendingProps, g = n.memoizedState, h = g.element, lh(e, n), Ri(n, c, null, i); var w = n.memoizedState; if (c = w.element, g.isDehydrated) if (g = { element: c, isDehydrated: !1, cache: w.cache, pendingSuspenseBoundaries: w.pendingSuspenseBoundaries, transitions: w.transitions }, n.updateQueue.baseState = g, n.memoizedState = g, n.flags & 256) { h = is(Error(s(423)), n), n = Gh(e, n, c, i, h); break e } else if (c !== h) { h = is(Error(s(424)), n), n = Gh(e, n, c, i, h); break e } else for (It = Un(n.stateNode.containerInfo.firstChild), Ot = n, He = !0, Qt = null, i = ih(n, null, c, i), n.child = i; i;)i.flags = i.flags & -3 | 4096, i = i.sibling; else { if (ts(), c === h) { n = Cn(e, n, i); break e } _t(e, n, c, i) } n = n.child } return n; case 5: return dh(n), e === null && Vl(n), c = n.type, h = n.pendingProps, g = e !== null ? e.memoizedProps : null, w = h.children, Il(c, h) ? w = null : g !== null && Il(c, g) && (n.flags |= 32), Hh(e, n), _t(e, n, w, i), n.child; case 6: return e === null && Vl(n), null; case 13: return Yh(e, n, i); case 4: return Ql(n, n.stateNode.containerInfo), c = n.pendingProps, e === null ? n.child = ns(n, null, c, i) : _t(e, n, c, i), n.child; case 11: return c = n.type, h = n.pendingProps, h = n.elementType === c ? h : Xt(c, h), Fh(e, n, c, h, i); case 7: return _t(e, n, n.pendingProps, i), n.child; case 8: return _t(e, n, n.pendingProps.children, i), n.child; case 12: return _t(e, n, n.pendingProps.children, i), n.child; case 10: e: { if (c = n.type._context, h = n.pendingProps, g = n.memoizedProps, w = h.value, Fe(Ni, c._currentValue), c._currentValue = w, g !== null) if (Jt(g.value, w)) { if (g.children === h.children && !kt.current) { n = Cn(e, n, i); break e } } else for (g = n.child, g !== null && (g.return = n); g !== null;) { var N = g.dependencies; if (N !== null) { w = g.child; for (var A = N.firstContext; A !== null;) { if (A.context === c) { if (g.tag === 1) { A = jn(-1, i & -i), A.tag = 2; var W = g.updateQueue; if (W !== null) { W = W.shared; var J = W.pending; J === null ? A.next = A : (A.next = J.next, J.next = A), W.pending = A } } g.lanes |= i, A = g.alternate, A !== null && (A.lanes |= i), Gl(g.return, i, n), N.lanes |= i; break } A = A.next } } else if (g.tag === 10) w = g.type === n.type ? null : g.child; else if (g.tag === 18) { if (w = g.return, w === null) throw Error(s(341)); w.lanes |= i, N = w.alternate, N !== null && (N.lanes |= i), Gl(w, i, n), w = g.sibling } else w = g.child; if (w !== null) w.return = g; else for (w = g; w !== null;) { if (w === n) { w = null; break } if (g = w.sibling, g !== null) { g.return = w.return, w = g; break } w = w.return } g = w } _t(e, n, h.children, i), n = n.child } return n; case 9: return h = n.type, c = n.pendingProps.children, ss(n, i), h = Bt(h), c = c(h), n.flags |= 1, _t(e, n, c, i), n.child; case 14: return c = n.type, h = Xt(c, n.pendingProps), h = Xt(c.type, h), Bh(e, n, c, h, i); case 15: return Vh(e, n, n.type, n.pendingProps, i); case 17: return c = n.type, h = n.pendingProps, h = n.elementType === c ? h : Xt(c, h), zi(e, n), n.tag = 1, Et(c) ? (e = !0, _i(n)) : e = !1, ss(n, i), Ih(n, c, h), uc(n, c, h, i), pc(null, n, c, !0, e, i); case 19: return Qh(e, n, i); case 22: return Wh(e, n, i) }throw Error(s(156, n.tag)) }; function bp(e, n) { return Zd(e, n) } function Uw(e, n, i, c) { this.tag = e, this.key = i, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = n, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = c, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null } function Ht(e, n, i, c) { return new Uw(e, n, i, c) } function Ic(e) { return e = e.prototype, !(!e || !e.isReactComponent) } function zw(e) { if (typeof e == "function") return Ic(e) ? 1 : 0; if (e != null) { if (e = e.$$typeof, e === G) return 11; if (e === ue) return 14 } return 2 } function Jn(e, n) { var i = e.alternate; return i === null ? (i = Ht(e.tag, n, e.key, e.mode), i.elementType = e.elementType, i.type = e.type, i.stateNode = e.stateNode, i.alternate = e, e.alternate = i) : (i.pendingProps = n, i.type = e.type, i.flags = 0, i.subtreeFlags = 0, i.deletions = null), i.flags = e.flags & 14680064, i.childLanes = e.childLanes, i.lanes = e.lanes, i.child = e.child, i.memoizedProps = e.memoizedProps, i.memoizedState = e.memoizedState, i.updateQueue = e.updateQueue, n = e.dependencies, i.dependencies = n === null ? null : { lanes: n.lanes, firstContext: n.firstContext }, i.sibling = e.sibling, i.index = e.index, i.ref = e.ref, i } function Qi(e, n, i, c, h, g) { var w = 2; if (c = e, typeof e == "function") Ic(e) && (w = 1); else if (typeof e == "string") w = 5; else e: switch (e) { case M: return kr(i.children, h, g, n); case R: w = 8, h |= 8; break; case L: return e = Ht(12, i, n, h | 2), e.elementType = L, e.lanes = g, e; case oe: return e = Ht(13, i, n, h), e.elementType = oe, e.lanes = g, e; case ae: return e = Ht(19, i, n, h), e.elementType = ae, e.lanes = g, e; case ne: return Xi(i, h, g, n); default: if (typeof e == "object" && e !== null) switch (e.$$typeof) { case F: w = 10; break e; case K: w = 9; break e; case G: w = 11; break e; case ue: w = 14; break e; case te: w = 16, c = null; break e }throw Error(s(130, e == null ? e : typeof e, "")) }return n = Ht(w, i, n, h), n.elementType = e, n.type = c, n.lanes = g, n } function kr(e, n, i, c) { return e = Ht(7, e, c, n), e.lanes = i, e } function Xi(e, n, i, c) { return e = Ht(22, e, c, n), e.elementType = ne, e.lanes = i, e.stateNode = { isHidden: !1 }, e } function Dc(e, n, i) { return e = Ht(6, e, null, n), e.lanes = i, e } function $c(e, n, i) { return n = Ht(4, e.children !== null ? e.children : [], e.key, n), n.lanes = i, n.stateNode = { containerInfo: e.containerInfo, pendingChildren: null, implementation: e.implementation }, n } function Fw(e, n, i, c, h) { this.tag = n, this.containerInfo = e, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = cl(0), this.expirationTimes = cl(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = cl(0), this.identifierPrefix = c, this.onRecoverableError = h, this.mutableSourceEagerHydrationData = null } function Lc(e, n, i, c, h, g, w, N, A) { return e = new Fw(e, n, i, N, A), n === 1 ? (n = 1, g === !0 && (n |= 8)) : n = 0, g = Ht(3, null, null, n), e.current = g, g.stateNode = e, g.memoizedState = { element: c, isDehydrated: i, cache: null, transitions: null, pendingSuspenseBoundaries: null }, Jl(g), e } function Bw(e, n, i) { var c = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null; return { $$typeof: V, key: c == null ? null : "" + c, children: e, containerInfo: n, implementation: i } } function _p(e) { if (!e) return Fn; e = e._reactInternals; e: { if (fr(e) !== e || e.tag !== 1) throw Error(s(170)); var n = e; do { switch (n.tag) { case 3: n = n.stateNode.context; break e; case 1: if (Et(n.type)) { n = n.stateNode.__reactInternalMemoizedMergedChildContext; break e } }n = n.return } while (n !== null); throw Error(s(171)) } if (e.tag === 1) { var i = e.type; if (Et(i)) return Jf(e, i, n) } return n } function Sp(e, n, i, c, h, g, w, N, A) { return e = Lc(i, c, !0, e, h, g, w, N, A), e.context = _p(null), i = e.current, c = St(), h = Gn(i), g = jn(c, h), g.callback = n ?? null, Wn(i, g, h), e.current.lanes = h, Xs(e, h, c), Nt(e, c), e } function Zi(e, n, i, c) { var h = n.current, g = St(), w = Gn(h); return i = _p(i), n.context === null ? n.context = i : n.pendingContext = i, n = jn(g, w), n.payload = { element: e }, c = c === void 0 ? null : c, c !== null && (n.callback = c), e = Wn(h, n, w), e !== null && (tn(e, h, w, g), Pi(e, h, w)), w } function ea(e) { if (e = e.current, !e.child) return null; switch (e.child.tag) { case 5: return e.child.stateNode; default: return e.child.stateNode } } function kp(e, n) { if (e = e.memoizedState, e !== null && e.dehydrated !== null) { var i = e.retryLane; e.retryLane = i !== 0 && i < n ? i : n } } function Mc(e, n) { kp(e, n), (e = e.alternate) && kp(e, n) } function Vw() { return null } var Ep = typeof reportError == "function" ? reportError : function (e) { console.error(e) }; function Uc(e) { this._internalRoot = e } ta.prototype.render = Uc.prototype.render = function (e) { var n = this._internalRoot; if (n === null) throw Error(s(409)); Zi(e, n, null, null) }, ta.prototype.unmount = Uc.prototype.unmount = function () { var e = this._internalRoot; if (e !== null) { this._internalRoot = null; var n = e.containerInfo; br(function () { Zi(null, e, null, null) }), n[bn] = null } }; function ta(e) { this._internalRoot = e } ta.prototype.unstable_scheduleHydration = function (e) { if (e) { var n = lf(); e = { blockedOn: null, target: e, priority: n }; for (var i = 0; i < $n.length && n !== 0 && n < $n[i].priority; i++); $n.splice(i, 0, e), i === 0 && df(e) } }; function zc(e) { return !(!e || e.nodeType !== 1 && e.nodeType !== 9 && e.nodeType !== 11) } function na(e) { return !(!e || e.nodeType !== 1 && e.nodeType !== 9 && e.nodeType !== 11 && (e.nodeType !== 8 || e.nodeValue !== " react-mount-point-unstable ")) } function jp() { } function Ww(e, n, i, c, h) { if (h) { if (typeof c == "function") { var g = c; c = function () { var W = ea(w); g.call(W) } } var w = Sp(n, c, e, 0, null, !1, !1, "", jp); return e._reactRootContainer = w, e[bn] = w.current, ho(e.nodeType === 8 ? e.parentNode : e), br(), w } for (; h = e.lastChild;)e.removeChild(h); if (typeof c == "function") { var N = c; c = function () { var W = ea(A); N.call(W) } } var A = Lc(e, 0, !1, null, null, !1, !1, "", jp); return e._reactRootContainer = A, e[bn] = A.current, ho(e.nodeType === 8 ? e.parentNode : e), br(function () { Zi(n, A, i, c) }), A } function ra(e, n, i, c, h) { var g = i._reactRootContainer; if (g) { var w = g; if (typeof h == "function") { var N = h; h = function () { var A = ea(w); N.call(A) } } Zi(n, w, e, h) } else w = Ww(i, n, e, h, c); return ea(w) } of = function (e) { switch (e.tag) { case 3: var n = e.stateNode; if (n.current.memoizedState.isDehydrated) { var i = Qs(n.pendingLanes); i !== 0 && (ul(n, i | 1), Nt(n, Ye()), (Oe & 6) === 0 && (cs = Ye() + 500, Bn())) } break; case 13: br(function () { var c = En(e, 1); if (c !== null) { var h = St(); tn(c, e, 1, h) } }), Mc(e, 1) } }, dl = function (e) { if (e.tag === 13) { var n = En(e, 134217728); if (n !== null) { var i = St(); tn(n, e, 134217728, i) } Mc(e, 134217728) } }, af = function (e) { if (e.tag === 13) { var n = Gn(e), i = En(e, n); if (i !== null) { var c = St(); tn(i, e, n, c) } Mc(e, n) } }, lf = function () { return Me }, cf = function (e, n) { var i = Me; try { return Me = e, n() } finally { Me = i } }, rl = function (e, n, i) { switch (n) { case "input": if (dr(e, i), n = i.name, i.type === "radio" && n != null) { for (i = e; i.parentNode;)i = i.parentNode; for (i = i.querySelectorAll("input[name=" + JSON.stringify("" + n) + '][type="radio"]'), n = 0; n < i.length; n++) { var c = i[n]; if (c !== e && c.form === e.form) { var h = xi(c); if (!h) throw Error(s(90)); Le(c), dr(c, h) } } } break; case "textarea": Ld(e, i); break; case "select": n = i.value, n != null && zr(e, !!i.multiple, n, !1) } }, Kd = Rc, qd = br; var Hw = { usingClientEntryPoint: !1, Events: [go, Jr, xi, Wd, Hd, Rc] }, Po = { findFiberByHostInstance: hr, bundleType: 0, version: "18.3.1", rendererPackageName: "react-dom" }, Kw = { bundleType: Po.bundleType, version: Po.version, rendererPackageName: Po.rendererPackageName, rendererConfig: Po.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: I.ReactCurrentDispatcher, findHostInstanceByFiber: function (e) { return e = Qd(e), e === null ? null : e.stateNode }, findFiberByHostInstance: Po.findFiberByHostInstance || Vw, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.3.1-next-f1338f8080-20240426" }; if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") { var sa = __REACT_DEVTOOLS_GLOBAL_HOOK__; if (!sa.isDisabled && sa.supportsFiber) try { ti = sa.inject(Kw), cn = sa } catch { } } return Tt.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = Hw, Tt.createPortal = function (e, n) { var i = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null; if (!zc(n)) throw Error(s(200)); return Bw(e, n, null, i) }, Tt.createRoot = function (e, n) { if (!zc(e)) throw Error(s(299)); var i = !1, c = "", h = Ep; return n != null && (n.unstable_strictMode === !0 && (i = !0), n.identifierPrefix !== void 0 && (c = n.identifierPrefix), n.onRecoverableError !== void 0 && (h = n.onRecoverableError)), n = Lc(e, 1, !1, null, null, i, !1, c, h), e[bn] = n.current, ho(e.nodeType === 8 ? e.parentNode : e), new Uc(n) }, Tt.findDOMNode = function (e) { if (e == null) return null; if (e.nodeType === 1) return e; var n = e._reactInternals; if (n === void 0) throw typeof e.render == "function" ? Error(s(188)) : (e = Object.keys(e).join(","), Error(s(268, e))); return e = Qd(n), e = e === null ? null : e.stateNode, e }, Tt.flushSync = function (e) { return br(e) }, Tt.hydrate = function (e, n, i) { if (!na(n)) throw Error(s(200)); return ra(null, e, n, !0, i) }, Tt.hydrateRoot = function (e, n, i) { if (!zc(e)) throw Error(s(405)); var c = i != null && i.hydratedSources || null, h = !1, g = "", w = Ep; if (i != null && (i.unstable_strictMode === !0 && (h = !0), i.identifierPrefix !== void 0 && (g = i.identifierPrefix), i.onRecoverableError !== void 0 && (w = i.onRecoverableError)), n = Sp(n, null, e, 1, i ?? null, h, !1, g, w), e[bn] = n.current, ho(e), c) for (e = 0; e < c.length; e++)i = c[e], h = i._getVersion, h = h(i._source), n.mutableSourceEagerHydrationData == null ? n.mutableSourceEagerHydrationData = [i, h] : n.mutableSourceEagerHydrationData.push(i, h); return new ta(n) }, Tt.render = function (e, n, i) { if (!na(n)) throw Error(s(200)); return ra(null, e, n, !1, i) }, Tt.unmountComponentAtNode = function (e) { if (!na(e)) throw Error(s(40)); return e._reactRootContainer ? (br(function () { ra(null, null, e, !1, function () { e._reactRootContainer = null, e[bn] = null }) }), !0) : !1 }, Tt.unstable_batchedUpdates = Rc, Tt.unstable_renderSubtreeIntoContainer = function (e, n, i, c) { if (!na(i)) throw Error(s(200)); if (e == null || e._reactInternals === void 0) throw Error(s(38)); return ra(e, n, i, !1, c) }, Tt.version = "18.3.1-next-f1338f8080-20240426", Tt
} var Ip; function qm() { if (Ip) return Vc.exports; Ip = 1; function r() { if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")) try { __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(r) } catch (t) { console.error(t) } } return r(), Vc.exports = tx(), Vc.exports } var Dp; function nx() { if (Dp) return oa; Dp = 1; var r = qm(); return oa.createRoot = r.createRoot, oa.hydrateRoot = r.hydrateRoot, oa } var rx = nx(), x = Yu(); const Lt = Gu(x), Gm = Gw({ __proto__: null, default: Lt }, [x]), Kc = { fire: [{ id: "fire-1", title: "지하철 화재 발생 시 초기 대응", description: "지하철에서 화재가 발생했을 때 승무원이 취해야 할 초기 대응 방법을 학습합니다.", youtubeId: "dQw4w9WgXcQ", videoType: "youtube", duration: 330, thumbnail: "https://img.youtube.com/vi/dQw4w9WgXcQ/mqdefault.jpg", category: "fire" }, { id: "fire-2", title: "승객 대피 유도 방법", description: "화재 발생 시 승객을 안전하게 대피시키는 방법과 유의사항을 학습합니다.", youtubeId: "dQw4w9WgXcQ", videoType: "youtube", duration: 435, thumbnail: "https://img.youtube.com/vi/dQw4w9WgXcQ/mqdefault.jpg", category: "fire" }], troubleshooting: [{ id: "js-1", title: "JavaScript 변수와 데이터 타입", description: "JavaScript의 기본 변수 선언 방법과 다양한 데이터 타입에 대해 알아봅니다. let, const, var의 차이점과 원시 타입, 참조 타입의 특징을 학습합니다.", youtubeId: "W6NZfCO5SIk", videoType: "youtube", duration: 1200, thumbnail: "https://img.youtube.com/vi/W6NZfCO5SIk/mqdefault.jpg", category: "troubleshooting" }], basic: [{ id: "react-1", title: "React 시작하기", description: "React의 기본 개념과 컴포넌트 기반 개발 방식을 이해합니다. JSX 문법과 가상 DOM의 동작 원리를 학습합니다.", youtubeId: "Ke90Tje7VS0", videoType: "youtube", duration: 1680, thumbnail: "https://img.youtube.com/vi/Ke90Tje7VS0/mqdefault.jpg", category: "react" }, { id: "react-2", title: "State와 Props", description: "React 컴포넌트의 state와 props를 활용한 데이터 관리 방법을 학습합니다.", youtubeId: "O6P86uwfdR0", videoType: "youtube", duration: 1440, thumbnail: "https://img.youtube.com/vi/O6P86uwfdR0/mqdefault.jpg", category: "react" }, { id: "react-3", title: "React Hooks 완전정복", description: "useState, useEffect를 비롯한 다양한 React Hooks의 사용법을 마스터합니다.", youtubeId: "TNhaISOUy6Q", videoType: "youtube", duration: 2400, thumbnail: "https://img.youtube.com/vi/TNhaISOUy6Q/mqdefault.jpg", category: "react" }] }; function Ym(r) { var t, s, o = ""; if (typeof r == "string" || typeof r == "number") o += r; else if (typeof r == "object") if (Array.isArray(r)) { var a = r.length; for (t = 0; t < a; t++)r[t] && (s = Ym(r[t])) && (o && (o += " "), o += s) } else for (s in r) r[s] && (o && (o += " "), o += s); return o } function Ju() { for (var r, t, s = 0, o = "", a = arguments.length; s < a; s++)(r = arguments[s]) && (t = Ym(r)) && (o && (o += " "), o += t); return o } const Qu = "-", sx = r => { const t = ix(r), { conflictingClassGroups: s, conflictingClassGroupModifiers: o } = r; return { getClassGroupId: u => { const f = u.split(Qu); return f[0] === "" && f.length !== 1 && f.shift(), Jm(f, t) || ox(u) }, getConflictingClassGroupIds: (u, f) => { const p = s[u] || []; return f && o[u] ? [...p, ...o[u]] : p } } }, Jm = (r, t) => { if (r.length === 0) return t.classGroupId; const s = r[0], o = t.nextPart.get(s), a = o ? Jm(r.slice(1), o) : void 0; if (a) return a; if (t.validators.length === 0) return; const l = r.join(Qu); return t.validators.find(({ validator: u }) => u(l))?.classGroupId }, $p = /^\[(.+)\]$/, ox = r => { if ($p.test(r)) { const t = $p.exec(r)[1], s = t?.substring(0, t.indexOf(":")); if (s) return "arbitrary.." + s } }, ix = r => { const { theme: t, classGroups: s } = r, o = { nextPart: new Map, validators: [] }; for (const a in s) mu(s[a], o, a, t); return o }, mu = (r, t, s, o) => { r.forEach(a => { if (typeof a == "string") { const l = a === "" ? t : Lp(t, a); l.classGroupId = s; return } if (typeof a == "function") { if (ax(a)) { mu(a(o), t, s, o); return } t.validators.push({ validator: a, classGroupId: s }); return } Object.entries(a).forEach(([l, u]) => { mu(u, Lp(t, l), s, o) }) }) }, Lp = (r, t) => { let s = r; return t.split(Qu).forEach(o => { s.nextPart.has(o) || s.nextPart.set(o, { nextPart: new Map, validators: [] }), s = s.nextPart.get(o) }), s }, ax = r => r.isThemeGetter, lx = r => { if (r < 1) return { get: () => { }, set: () => { } }; let t = 0, s = new Map, o = new Map; const a = (l, u) => { s.set(l, u), t++, t > r && (t = 0, o = s, s = new Map) }; return { get(l) { let u = s.get(l); if (u !== void 0) return u; if ((u = o.get(l)) !== void 0) return a(l, u), u }, set(l, u) { s.has(l) ? s.set(l, u) : a(l, u) } } }, gu = "!", vu = ":", cx = vu.length, ux = r => { const { prefix: t, experimentalParseClassName: s } = r; let o = a => { const l = []; let u = 0, f = 0, p = 0, m; for (let E = 0; E < a.length; E++) { let b = a[E]; if (u === 0 && f === 0) { if (b === vu) { l.push(a.slice(p, E)), p = E + cx; continue } if (b === "/") { m = E; continue } } b === "[" ? u++ : b === "]" ? u-- : b === "(" ? f++ : b === ")" && f-- } const v = l.length === 0 ? a : a.substring(p), y = dx(v), _ = y !== v, S = m && m > p ? m - p : void 0; return { modifiers: l, hasImportantModifier: _, baseClassName: y, maybePostfixModifierPosition: S } }; if (t) { const a = t + vu, l = o; o = u => u.startsWith(a) ? l(u.substring(a.length)) : { isExternal: !0, modifiers: [], hasImportantModifier: !1, baseClassName: u, maybePostfixModifierPosition: void 0 } } if (s) { const a = o; o = l => s({ className: l, parseClassName: a }) } return o }, dx = r => r.endsWith(gu) ? r.substring(0, r.length - 1) : r.startsWith(gu) ? r.substring(1) : r, fx = r => { const t = Object.fromEntries(r.orderSensitiveModifiers.map(o => [o, !0])); return o => { if (o.length <= 1) return o; const a = []; let l = []; return o.forEach(u => { u[0] === "[" || t[u] ? (a.push(...l.sort(), u), l = []) : l.push(u) }), a.push(...l.sort()), a } }, hx = r => ({ cache: lx(r.cacheSize), parseClassName: ux(r), sortModifiers: fx(r), ...sx(r) }), px = /\s+/, mx = (r, t) => { const { parseClassName: s, getClassGroupId: o, getConflictingClassGroupIds: a, sortModifiers: l } = t, u = [], f = r.trim().split(px); let p = ""; for (let m = f.length - 1; m >= 0; m -= 1) { const v = f[m], { isExternal: y, modifiers: _, hasImportantModifier: S, baseClassName: E, maybePostfixModifierPosition: b } = s(v); if (y) { p = v + (p.length > 0 ? " " + p : p); continue } let k = !!b, C = o(k ? E.substring(0, b) : E); if (!C) { if (!k) { p = v + (p.length > 0 ? " " + p : p); continue } if (C = o(E), !C) { p = v + (p.length > 0 ? " " + p : p); continue } k = !1 } const T = l(_).join(":"), P = S ? T + gu : T, I = P + C; if (u.includes(I)) continue; u.push(I); const O = a(C, k); for (let V = 0; V < O.length; ++V) { const M = O[V]; u.push(P + M) } p = v + (p.length > 0 ? " " + p : p) } return p }; function gx() { let r = 0, t, s, o = ""; for (; r < arguments.length;)(t = arguments[r++]) && (s = Qm(t)) && (o && (o += " "), o += s); return o } const Qm = r => { if (typeof r == "string") return r; let t, s = ""; for (let o = 0; o < r.length; o++)r[o] && (t = Qm(r[o])) && (s && (s += " "), s += t); return s }; function vx(r, ...t) { let s, o, a, l = u; function u(p) { const m = t.reduce((v, y) => y(v), r()); return s = hx(m), o = s.cache.get, a = s.cache.set, l = f, f(p) } function f(p) { const m = o(p); if (m) return m; const v = mx(p, s); return a(p, v), v } return function () { return l(gx.apply(null, arguments)) } } const ot = r => { const t = s => s[r] || []; return t.isThemeGetter = !0, t }, Xm = /^\[(?:(\w[\w-]*):)?(.+)\]$/i, Zm = /^\((?:(\w[\w-]*):)?(.+)\)$/i, yx = /^\d+\/\d+$/, wx = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/, xx = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/, bx = /^(rgba?|hsla?|hwb|(ok)?(lab|lch)|color-mix)\(.+\)$/, _x = /^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/, Sx = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/, ds = r => yx.test(r), Ce = r => !!r && !Number.isNaN(Number(r)), Xn = r => !!r && Number.isInteger(Number(r)), qc = r => r.endsWith("%") && Ce(r.slice(0, -1)), Tn = r => wx.test(r), kx = () => !0, Ex = r => xx.test(r) && !bx.test(r), eg = () => !1, jx = r => _x.test(r), Cx = r => Sx.test(r), Nx = r => !he(r) && !pe(r), Tx = r => Ms(r, rg, eg), he = r => Xm.test(r), Er = r => Ms(r, sg, Ex), Gc = r => Ms(r, Ix, Ce), Mp = r => Ms(r, tg, eg), Px = r => Ms(r, ng, Cx), ia = r => Ms(r, og, jx), pe = r => Zm.test(r), Ao = r => Us(r, sg), Rx = r => Us(r, Dx), Up = r => Us(r, tg), Ax = r => Us(r, rg), Ox = r => Us(r, ng), aa = r => Us(r, og, !0), Ms = (r, t, s) => { const o = Xm.exec(r); return o ? o[1] ? t(o[1]) : s(o[2]) : !1 }, Us = (r, t, s = !1) => { const o = Zm.exec(r); return o ? o[1] ? t(o[1]) : s : !1 }, tg = r => r === "position" || r === "percentage", ng = r => r === "image" || r === "url", rg = r => r === "length" || r === "size" || r === "bg-size", sg = r => r === "length", Ix = r => r === "number", Dx = r => r === "family-name", og = r => r === "shadow", $x = () => { const r = ot("color"), t = ot("font"), s = ot("text"), o = ot("font-weight"), a = ot("tracking"), l = ot("leading"), u = ot("breakpoint"), f = ot("container"), p = ot("spacing"), m = ot("radius"), v = ot("shadow"), y = ot("inset-shadow"), _ = ot("text-shadow"), S = ot("drop-shadow"), E = ot("blur"), b = ot("perspective"), k = ot("aspect"), C = ot("ease"), T = ot("animate"), P = () => ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"], I = () => ["center", "top", "bottom", "left", "right", "top-left", "left-top", "top-right", "right-top", "bottom-right", "right-bottom", "bottom-left", "left-bottom"], O = () => [...I(), pe, he], V = () => ["auto", "hidden", "clip", "visible", "scroll"], M = () => ["auto", "contain", "none"], R = () => [pe, he, p], L = () => [ds, "full", "auto", ...R()], F = () => [Xn, "none", "subgrid", pe, he], K = () => ["auto", { span: ["full", Xn, pe, he] }, Xn, pe, he], G = () => [Xn, "auto", pe, he], oe = () => ["auto", "min", "max", "fr", pe, he], ae = () => ["start", "end", "center", "between", "around", "evenly", "stretch", "baseline", "center-safe", "end-safe"], ue = () => ["start", "end", "center", "stretch", "center-safe", "end-safe"], te = () => ["auto", ...R()], ne = () => [ds, "auto", "full", "dvw", "dvh", "lvw", "lvh", "svw", "svh", "min", "max", "fit", ...R()], $ = () => [r, pe, he], ee = () => [...I(), Up, Mp, { position: [pe, he] }], X = () => ["no-repeat", { repeat: ["", "x", "y", "space", "round"] }], j = () => ["auto", "cover", "contain", Ax, Tx, { size: [pe, he] }], U = () => [qc, Ao, Er], re = () => ["", "none", "full", m, pe, he], H = () => ["", Ce, Ao, Er], se = () => ["solid", "dashed", "dotted", "double"], de = () => ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity"], q = () => [Ce, qc, Up, Mp], le = () => ["", "none", E, pe, he], ve = () => ["none", Ce, pe, he], be = () => ["none", Ce, pe, he], je = () => [Ce, pe, he], Le = () => [ds, "full", ...R()]; return { cacheSize: 500, theme: { animate: ["spin", "ping", "pulse", "bounce"], aspect: ["video"], blur: [Tn], breakpoint: [Tn], color: [kx], container: [Tn], "drop-shadow": [Tn], ease: ["in", "out", "in-out"], font: [Nx], "font-weight": ["thin", "extralight", "light", "normal", "medium", "semibold", "bold", "extrabold", "black"], "inset-shadow": [Tn], leading: ["none", "tight", "snug", "normal", "relaxed", "loose"], perspective: ["dramatic", "near", "normal", "midrange", "distant", "none"], radius: [Tn], shadow: [Tn], spacing: ["px", Ce], text: [Tn], "text-shadow": [Tn], tracking: ["tighter", "tight", "normal", "wide", "wider", "widest"] }, classGroups: { aspect: [{ aspect: ["auto", "square", ds, he, pe, k] }], container: ["container"], columns: [{ columns: [Ce, he, pe, f] }], "break-after": [{ "break-after": P() }], "break-before": [{ "break-before": P() }], "break-inside": [{ "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"] }], "box-decoration": [{ "box-decoration": ["slice", "clone"] }], box: [{ box: ["border", "content"] }], display: ["block", "inline-block", "inline", "flex", "inline-flex", "table", "inline-table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row-group", "table-row", "flow-root", "grid", "inline-grid", "contents", "list-item", "hidden"], sr: ["sr-only", "not-sr-only"], float: [{ float: ["right", "left", "none", "start", "end"] }], clear: [{ clear: ["left", "right", "both", "none", "start", "end"] }], isolation: ["isolate", "isolation-auto"], "object-fit": [{ object: ["contain", "cover", "fill", "none", "scale-down"] }], "object-position": [{ object: O() }], overflow: [{ overflow: V() }], "overflow-x": [{ "overflow-x": V() }], "overflow-y": [{ "overflow-y": V() }], overscroll: [{ overscroll: M() }], "overscroll-x": [{ "overscroll-x": M() }], "overscroll-y": [{ "overscroll-y": M() }], position: ["static", "fixed", "absolute", "relative", "sticky"], inset: [{ inset: L() }], "inset-x": [{ "inset-x": L() }], "inset-y": [{ "inset-y": L() }], start: [{ start: L() }], end: [{ end: L() }], top: [{ top: L() }], right: [{ right: L() }], bottom: [{ bottom: L() }], left: [{ left: L() }], visibility: ["visible", "invisible", "collapse"], z: [{ z: [Xn, "auto", pe, he] }], basis: [{ basis: [ds, "full", "auto", f, ...R()] }], "flex-direction": [{ flex: ["row", "row-reverse", "col", "col-reverse"] }], "flex-wrap": [{ flex: ["nowrap", "wrap", "wrap-reverse"] }], flex: [{ flex: [Ce, ds, "auto", "initial", "none", he] }], grow: [{ grow: ["", Ce, pe, he] }], shrink: [{ shrink: ["", Ce, pe, he] }], order: [{ order: [Xn, "first", "last", "none", pe, he] }], "grid-cols": [{ "grid-cols": F() }], "col-start-end": [{ col: K() }], "col-start": [{ "col-start": G() }], "col-end": [{ "col-end": G() }], "grid-rows": [{ "grid-rows": F() }], "row-start-end": [{ row: K() }], "row-start": [{ "row-start": G() }], "row-end": [{ "row-end": G() }], "grid-flow": [{ "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"] }], "auto-cols": [{ "auto-cols": oe() }], "auto-rows": [{ "auto-rows": oe() }], gap: [{ gap: R() }], "gap-x": [{ "gap-x": R() }], "gap-y": [{ "gap-y": R() }], "justify-content": [{ justify: [...ae(), "normal"] }], "justify-items": [{ "justify-items": [...ue(), "normal"] }], "justify-self": [{ "justify-self": ["auto", ...ue()] }], "align-content": [{ content: ["normal", ...ae()] }], "align-items": [{ items: [...ue(), { baseline: ["", "last"] }] }], "align-self": [{ self: ["auto", ...ue(), { baseline: ["", "last"] }] }], "place-content": [{ "place-content": ae() }], "place-items": [{ "place-items": [...ue(), "baseline"] }], "place-self": [{ "place-self": ["auto", ...ue()] }], p: [{ p: R() }], px: [{ px: R() }], py: [{ py: R() }], ps: [{ ps: R() }], pe: [{ pe: R() }], pt: [{ pt: R() }], pr: [{ pr: R() }], pb: [{ pb: R() }], pl: [{ pl: R() }], m: [{ m: te() }], mx: [{ mx: te() }], my: [{ my: te() }], ms: [{ ms: te() }], me: [{ me: te() }], mt: [{ mt: te() }], mr: [{ mr: te() }], mb: [{ mb: te() }], ml: [{ ml: te() }], "space-x": [{ "space-x": R() }], "space-x-reverse": ["space-x-reverse"], "space-y": [{ "space-y": R() }], "space-y-reverse": ["space-y-reverse"], size: [{ size: ne() }], w: [{ w: [f, "screen", ...ne()] }], "min-w": [{ "min-w": [f, "screen", "none", ...ne()] }], "max-w": [{ "max-w": [f, "screen", "none", "prose", { screen: [u] }, ...ne()] }], h: [{ h: ["screen", "lh", ...ne()] }], "min-h": [{ "min-h": ["screen", "lh", "none", ...ne()] }], "max-h": [{ "max-h": ["screen", "lh", ...ne()] }], "font-size": [{ text: ["base", s, Ao, Er] }], "font-smoothing": ["antialiased", "subpixel-antialiased"], "font-style": ["italic", "not-italic"], "font-weight": [{ font: [o, pe, Gc] }], "font-stretch": [{ "font-stretch": ["ultra-condensed", "extra-condensed", "condensed", "semi-condensed", "normal", "semi-expanded", "expanded", "extra-expanded", "ultra-expanded", qc, he] }], "font-family": [{ font: [Rx, he, t] }], "fvn-normal": ["normal-nums"], "fvn-ordinal": ["ordinal"], "fvn-slashed-zero": ["slashed-zero"], "fvn-figure": ["lining-nums", "oldstyle-nums"], "fvn-spacing": ["proportional-nums", "tabular-nums"], "fvn-fraction": ["diagonal-fractions", "stacked-fractions"], tracking: [{ tracking: [a, pe, he] }], "line-clamp": [{ "line-clamp": [Ce, "none", pe, Gc] }], leading: [{ leading: [l, ...R()] }], "list-image": [{ "list-image": ["none", pe, he] }], "list-style-position": [{ list: ["inside", "outside"] }], "list-style-type": [{ list: ["disc", "decimal", "none", pe, he] }], "text-alignment": [{ text: ["left", "center", "right", "justify", "start", "end"] }], "placeholder-color": [{ placeholder: $() }], "text-color": [{ text: $() }], "text-decoration": ["underline", "overline", "line-through", "no-underline"], "text-decoration-style": [{ decoration: [...se(), "wavy"] }], "text-decoration-thickness": [{ decoration: [Ce, "from-font", "auto", pe, Er] }], "text-decoration-color": [{ decoration: $() }], "underline-offset": [{ "underline-offset": [Ce, "auto", pe, he] }], "text-transform": ["uppercase", "lowercase", "capitalize", "normal-case"], "text-overflow": ["truncate", "text-ellipsis", "text-clip"], "text-wrap": [{ text: ["wrap", "nowrap", "balance", "pretty"] }], indent: [{ indent: R() }], "vertical-align": [{ align: ["baseline", "top", "middle", "bottom", "text-top", "text-bottom", "sub", "super", pe, he] }], whitespace: [{ whitespace: ["normal", "nowrap", "pre", "pre-line", "pre-wrap", "break-spaces"] }], break: [{ break: ["normal", "words", "all", "keep"] }], wrap: [{ wrap: ["break-word", "anywhere", "normal"] }], hyphens: [{ hyphens: ["none", "manual", "auto"] }], content: [{ content: ["none", pe, he] }], "bg-attachment": [{ bg: ["fixed", "local", "scroll"] }], "bg-clip": [{ "bg-clip": ["border", "padding", "content", "text"] }], "bg-origin": [{ "bg-origin": ["border", "padding", "content"] }], "bg-position": [{ bg: ee() }], "bg-repeat": [{ bg: X() }], "bg-size": [{ bg: j() }], "bg-image": [{ bg: ["none", { linear: [{ to: ["t", "tr", "r", "br", "b", "bl", "l", "tl"] }, Xn, pe, he], radial: ["", pe, he], conic: [Xn, pe, he] }, Ox, Px] }], "bg-color": [{ bg: $() }], "gradient-from-pos": [{ from: U() }], "gradient-via-pos": [{ via: U() }], "gradient-to-pos": [{ to: U() }], "gradient-from": [{ from: $() }], "gradient-via": [{ via: $() }], "gradient-to": [{ to: $() }], rounded: [{ rounded: re() }], "rounded-s": [{ "rounded-s": re() }], "rounded-e": [{ "rounded-e": re() }], "rounded-t": [{ "rounded-t": re() }], "rounded-r": [{ "rounded-r": re() }], "rounded-b": [{ "rounded-b": re() }], "rounded-l": [{ "rounded-l": re() }], "rounded-ss": [{ "rounded-ss": re() }], "rounded-se": [{ "rounded-se": re() }], "rounded-ee": [{ "rounded-ee": re() }], "rounded-es": [{ "rounded-es": re() }], "rounded-tl": [{ "rounded-tl": re() }], "rounded-tr": [{ "rounded-tr": re() }], "rounded-br": [{ "rounded-br": re() }], "rounded-bl": [{ "rounded-bl": re() }], "border-w": [{ border: H() }], "border-w-x": [{ "border-x": H() }], "border-w-y": [{ "border-y": H() }], "border-w-s": [{ "border-s": H() }], "border-w-e": [{ "border-e": H() }], "border-w-t": [{ "border-t": H() }], "border-w-r": [{ "border-r": H() }], "border-w-b": [{ "border-b": H() }], "border-w-l": [{ "border-l": H() }], "divide-x": [{ "divide-x": H() }], "divide-x-reverse": ["divide-x-reverse"], "divide-y": [{ "divide-y": H() }], "divide-y-reverse": ["divide-y-reverse"], "border-style": [{ border: [...se(), "hidden", "none"] }], "divide-style": [{ divide: [...se(), "hidden", "none"] }], "border-color": [{ border: $() }], "border-color-x": [{ "border-x": $() }], "border-color-y": [{ "border-y": $() }], "border-color-s": [{ "border-s": $() }], "border-color-e": [{ "border-e": $() }], "border-color-t": [{ "border-t": $() }], "border-color-r": [{ "border-r": $() }], "border-color-b": [{ "border-b": $() }], "border-color-l": [{ "border-l": $() }], "divide-color": [{ divide: $() }], "outline-style": [{ outline: [...se(), "none", "hidden"] }], "outline-offset": [{ "outline-offset": [Ce, pe, he] }], "outline-w": [{ outline: ["", Ce, Ao, Er] }], "outline-color": [{ outline: $() }], shadow: [{ shadow: ["", "none", v, aa, ia] }], "shadow-color": [{ shadow: $() }], "inset-shadow": [{ "inset-shadow": ["none", y, aa, ia] }], "inset-shadow-color": [{ "inset-shadow": $() }], "ring-w": [{ ring: H() }], "ring-w-inset": ["ring-inset"], "ring-color": [{ ring: $() }], "ring-offset-w": [{ "ring-offset": [Ce, Er] }], "ring-offset-color": [{ "ring-offset": $() }], "inset-ring-w": [{ "inset-ring": H() }], "inset-ring-color": [{ "inset-ring": $() }], "text-shadow": [{ "text-shadow": ["none", _, aa, ia] }], "text-shadow-color": [{ "text-shadow": $() }], opacity: [{ opacity: [Ce, pe, he] }], "mix-blend": [{ "mix-blend": [...de(), "plus-darker", "plus-lighter"] }], "bg-blend": [{ "bg-blend": de() }], "mask-clip": [{ "mask-clip": ["border", "padding", "content", "fill", "stroke", "view"] }, "mask-no-clip"], "mask-composite": [{ mask: ["add", "subtract", "intersect", "exclude"] }], "mask-image-linear-pos": [{ "mask-linear": [Ce] }], "mask-image-linear-from-pos": [{ "mask-linear-from": q() }], "mask-image-linear-to-pos": [{ "mask-linear-to": q() }], "mask-image-linear-from-color": [{ "mask-linear-from": $() }], "mask-image-linear-to-color": [{ "mask-linear-to": $() }], "mask-image-t-from-pos": [{ "mask-t-from": q() }], "mask-image-t-to-pos": [{ "mask-t-to": q() }], "mask-image-t-from-color": [{ "mask-t-from": $() }], "mask-image-t-to-color": [{ "mask-t-to": $() }], "mask-image-r-from-pos": [{ "mask-r-from": q() }], "mask-image-r-to-pos": [{ "mask-r-to": q() }], "mask-image-r-from-color": [{ "mask-r-from": $() }], "mask-image-r-to-color": [{ "mask-r-to": $() }], "mask-image-b-from-pos": [{ "mask-b-from": q() }], "mask-image-b-to-pos": [{ "mask-b-to": q() }], "mask-image-b-from-color": [{ "mask-b-from": $() }], "mask-image-b-to-color": [{ "mask-b-to": $() }], "mask-image-l-from-pos": [{ "mask-l-from": q() }], "mask-image-l-to-pos": [{ "mask-l-to": q() }], "mask-image-l-from-color": [{ "mask-l-from": $() }], "mask-image-l-to-color": [{ "mask-l-to": $() }], "mask-image-x-from-pos": [{ "mask-x-from": q() }], "mask-image-x-to-pos": [{ "mask-x-to": q() }], "mask-image-x-from-color": [{ "mask-x-from": $() }], "mask-image-x-to-color": [{ "mask-x-to": $() }], "mask-image-y-from-pos": [{ "mask-y-from": q() }], "mask-image-y-to-pos": [{ "mask-y-to": q() }], "mask-image-y-from-color": [{ "mask-y-from": $() }], "mask-image-y-to-color": [{ "mask-y-to": $() }], "mask-image-radial": [{ "mask-radial": [pe, he] }], "mask-image-radial-from-pos": [{ "mask-radial-from": q() }], "mask-image-radial-to-pos": [{ "mask-radial-to": q() }], "mask-image-radial-from-color": [{ "mask-radial-from": $() }], "mask-image-radial-to-color": [{ "mask-radial-to": $() }], "mask-image-radial-shape": [{ "mask-radial": ["circle", "ellipse"] }], "mask-image-radial-size": [{ "mask-radial": [{ closest: ["side", "corner"], farthest: ["side", "corner"] }] }], "mask-image-radial-pos": [{ "mask-radial-at": I() }], "mask-image-conic-pos": [{ "mask-conic": [Ce] }], "mask-image-conic-from-pos": [{ "mask-conic-from": q() }], "mask-image-conic-to-pos": [{ "mask-conic-to": q() }], "mask-image-conic-from-color": [{ "mask-conic-from": $() }], "mask-image-conic-to-color": [{ "mask-conic-to": $() }], "mask-mode": [{ mask: ["alpha", "luminance", "match"] }], "mask-origin": [{ "mask-origin": ["border", "padding", "content", "fill", "stroke", "view"] }], "mask-position": [{ mask: ee() }], "mask-repeat": [{ mask: X() }], "mask-size": [{ mask: j() }], "mask-type": [{ "mask-type": ["alpha", "luminance"] }], "mask-image": [{ mask: ["none", pe, he] }], filter: [{ filter: ["", "none", pe, he] }], blur: [{ blur: le() }], brightness: [{ brightness: [Ce, pe, he] }], contrast: [{ contrast: [Ce, pe, he] }], "drop-shadow": [{ "drop-shadow": ["", "none", S, aa, ia] }], "drop-shadow-color": [{ "drop-shadow": $() }], grayscale: [{ grayscale: ["", Ce, pe, he] }], "hue-rotate": [{ "hue-rotate": [Ce, pe, he] }], invert: [{ invert: ["", Ce, pe, he] }], saturate: [{ saturate: [Ce, pe, he] }], sepia: [{ sepia: ["", Ce, pe, he] }], "backdrop-filter": [{ "backdrop-filter": ["", "none", pe, he] }], "backdrop-blur": [{ "backdrop-blur": le() }], "backdrop-brightness": [{ "backdrop-brightness": [Ce, pe, he] }], "backdrop-contrast": [{ "backdrop-contrast": [Ce, pe, he] }], "backdrop-grayscale": [{ "backdrop-grayscale": ["", Ce, pe, he] }], "backdrop-hue-rotate": [{ "backdrop-hue-rotate": [Ce, pe, he] }], "backdrop-invert": [{ "backdrop-invert": ["", Ce, pe, he] }], "backdrop-opacity": [{ "backdrop-opacity": [Ce, pe, he] }], "backdrop-saturate": [{ "backdrop-saturate": [Ce, pe, he] }], "backdrop-sepia": [{ "backdrop-sepia": ["", Ce, pe, he] }], "border-collapse": [{ border: ["collapse", "separate"] }], "border-spacing": [{ "border-spacing": R() }], "border-spacing-x": [{ "border-spacing-x": R() }], "border-spacing-y": [{ "border-spacing-y": R() }], "table-layout": [{ table: ["auto", "fixed"] }], caption: [{ caption: ["top", "bottom"] }], transition: [{ transition: ["", "all", "colors", "opacity", "shadow", "transform", "none", pe, he] }], "transition-behavior": [{ transition: ["normal", "discrete"] }], duration: [{ duration: [Ce, "initial", pe, he] }], ease: [{ ease: ["linear", "initial", C, pe, he] }], delay: [{ delay: [Ce, pe, he] }], animate: [{ animate: ["none", T, pe, he] }], backface: [{ backface: ["hidden", "visible"] }], perspective: [{ perspective: [b, pe, he] }], "perspective-origin": [{ "perspective-origin": O() }], rotate: [{ rotate: ve() }], "rotate-x": [{ "rotate-x": ve() }], "rotate-y": [{ "rotate-y": ve() }], "rotate-z": [{ "rotate-z": ve() }], scale: [{ scale: be() }], "scale-x": [{ "scale-x": be() }], "scale-y": [{ "scale-y": be() }], "scale-z": [{ "scale-z": be() }], "scale-3d": ["scale-3d"], skew: [{ skew: je() }], "skew-x": [{ "skew-x": je() }], "skew-y": [{ "skew-y": je() }], transform: [{ transform: [pe, he, "", "none", "gpu", "cpu"] }], "transform-origin": [{ origin: O() }], "transform-style": [{ transform: ["3d", "flat"] }], translate: [{ translate: Le() }], "translate-x": [{ "translate-x": Le() }], "translate-y": [{ "translate-y": Le() }], "translate-z": [{ "translate-z": Le() }], "translate-none": ["translate-none"], accent: [{ accent: $() }], appearance: [{ appearance: ["none", "auto"] }], "caret-color": [{ caret: $() }], "color-scheme": [{ scheme: ["normal", "dark", "light", "light-dark", "only-dark", "only-light"] }], cursor: [{ cursor: ["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out", pe, he] }], "field-sizing": [{ "field-sizing": ["fixed", "content"] }], "pointer-events": [{ "pointer-events": ["auto", "none"] }], resize: [{ resize: ["none", "", "y", "x"] }], "scroll-behavior": [{ scroll: ["auto", "smooth"] }], "scroll-m": [{ "scroll-m": R() }], "scroll-mx": [{ "scroll-mx": R() }], "scroll-my": [{ "scroll-my": R() }], "scroll-ms": [{ "scroll-ms": R() }], "scroll-me": [{ "scroll-me": R() }], "scroll-mt": [{ "scroll-mt": R() }], "scroll-mr": [{ "scroll-mr": R() }], "scroll-mb": [{ "scroll-mb": R() }], "scroll-ml": [{ "scroll-ml": R() }], "scroll-p": [{ "scroll-p": R() }], "scroll-px": [{ "scroll-px": R() }], "scroll-py": [{ "scroll-py": R() }], "scroll-ps": [{ "scroll-ps": R() }], "scroll-pe": [{ "scroll-pe": R() }], "scroll-pt": [{ "scroll-pt": R() }], "scroll-pr": [{ "scroll-pr": R() }], "scroll-pb": [{ "scroll-pb": R() }], "scroll-pl": [{ "scroll-pl": R() }], "snap-align": [{ snap: ["start", "end", "center", "align-none"] }], "snap-stop": [{ snap: ["normal", "always"] }], "snap-type": [{ snap: ["none", "x", "y", "both"] }], "snap-strictness": [{ snap: ["mandatory", "proximity"] }], touch: [{ touch: ["auto", "none", "manipulation"] }], "touch-x": [{ "touch-pan": ["x", "left", "right"] }], "touch-y": [{ "touch-pan": ["y", "up", "down"] }], "touch-pz": ["touch-pinch-zoom"], select: [{ select: ["none", "text", "all", "auto"] }], "will-change": [{ "will-change": ["auto", "scroll", "contents", "transform", pe, he] }], fill: [{ fill: ["none", ...$()] }], "stroke-w": [{ stroke: [Ce, Ao, Er, Gc] }], stroke: [{ stroke: ["none", ...$()] }], "forced-color-adjust": [{ "forced-color-adjust": ["auto", "none"] }] }, conflictingClassGroups: { overflow: ["overflow-x", "overflow-y"], overscroll: ["overscroll-x", "overscroll-y"], inset: ["inset-x", "inset-y", "start", "end", "top", "right", "bottom", "left"], "inset-x": ["right", "left"], "inset-y": ["top", "bottom"], flex: ["basis", "grow", "shrink"], gap: ["gap-x", "gap-y"], p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"], px: ["pr", "pl"], py: ["pt", "pb"], m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"], mx: ["mr", "ml"], my: ["mt", "mb"], size: ["w", "h"], "font-size": ["leading"], "fvn-normal": ["fvn-ordinal", "fvn-slashed-zero", "fvn-figure", "fvn-spacing", "fvn-fraction"], "fvn-ordinal": ["fvn-normal"], "fvn-slashed-zero": ["fvn-normal"], "fvn-figure": ["fvn-normal"], "fvn-spacing": ["fvn-normal"], "fvn-fraction": ["fvn-normal"], "line-clamp": ["display", "overflow"], rounded: ["rounded-s", "rounded-e", "rounded-t", "rounded-r", "rounded-b", "rounded-l", "rounded-ss", "rounded-se", "rounded-ee", "rounded-es", "rounded-tl", "rounded-tr", "rounded-br", "rounded-bl"], "rounded-s": ["rounded-ss", "rounded-es"], "rounded-e": ["rounded-se", "rounded-ee"], "rounded-t": ["rounded-tl", "rounded-tr"], "rounded-r": ["rounded-tr", "rounded-br"], "rounded-b": ["rounded-br", "rounded-bl"], "rounded-l": ["rounded-tl", "rounded-bl"], "border-spacing": ["border-spacing-x", "border-spacing-y"], "border-w": ["border-w-x", "border-w-y", "border-w-s", "border-w-e", "border-w-t", "border-w-r", "border-w-b", "border-w-l"], "border-w-x": ["border-w-r", "border-w-l"], "border-w-y": ["border-w-t", "border-w-b"], "border-color": ["border-color-x", "border-color-y", "border-color-s", "border-color-e", "border-color-t", "border-color-r", "border-color-b", "border-color-l"], "border-color-x": ["border-color-r", "border-color-l"], "border-color-y": ["border-color-t", "border-color-b"], translate: ["translate-x", "translate-y", "translate-none"], "translate-none": ["translate", "translate-x", "translate-y", "translate-z"], "scroll-m": ["scroll-mx", "scroll-my", "scroll-ms", "scroll-me", "scroll-mt", "scroll-mr", "scroll-mb", "scroll-ml"], "scroll-mx": ["scroll-mr", "scroll-ml"], "scroll-my": ["scroll-mt", "scroll-mb"], "scroll-p": ["scroll-px", "scroll-py", "scroll-ps", "scroll-pe", "scroll-pt", "scroll-pr", "scroll-pb", "scroll-pl"], "scroll-px": ["scroll-pr", "scroll-pl"], "scroll-py": ["scroll-pt", "scroll-pb"], touch: ["touch-x", "touch-y", "touch-pz"], "touch-x": ["touch"], "touch-y": ["touch"], "touch-pz": ["touch"] }, conflictingClassGroupModifiers: { "font-size": ["leading"] }, orderSensitiveModifiers: ["*", "**", "after", "backdrop", "before", "details-content", "file", "first-letter", "first-line", "marker", "placeholder", "selection"] } }, ig = vx($x); function Pe(...r) { return ig(Ju(r)) } function ht({ className: r, ...t }) { return d.jsx("div", { "data-slot": "card", className: Pe("bg-card text-card-foreground flex flex-col gap-6 rounded-xl border", r), ...t }) } function qt({ className: r, ...t }) { return d.jsx("div", { "data-slot": "card-header", className: Pe("@container/card-header grid auto-rows-min grid-rows-[auto_auto] items-start gap-1.5 px-6 pt-6 has-data-[slot=card-action]:grid-cols-[1fr_auto] [.border-b]:pb-6", r), ...t }) } function Gt({ className: r, ...t }) { return d.jsx("h4", { "data-slot": "card-title", className: Pe("leading-none", r), ...t }) } function Ar({ className: r, ...t }) { return d.jsx("p", { "data-slot": "card-description", className: Pe("text-muted-foreground", r), ...t }) } function xt({ className: r, ...t }) { return d.jsx("div", { "data-slot": "card-content", className: Pe("px-6 [&:last-child]:pb-6", r), ...t }) } function zp(r, t) { if (typeof r == "function") return r(t); r != null && (r.current = t) } function ag(...r) { return t => { let s = !1; const o = r.map(a => { const l = zp(a, t); return !s && typeof l == "function" && (s = !0), l }); if (s) return () => { for (let a = 0; a < o.length; a++) { const l = o[a]; typeof l == "function" ? l() : zp(r[a], null) } } } } function ze(...r) { return x.useCallback(ag(...r), r) } function Os(r) { const t = Lx(r), s = x.forwardRef((o, a) => { const { children: l, ...u } = o, f = x.Children.toArray(l), p = f.find(Ux); if (p) { const m = p.props.children, v = f.map(y => y === p ? x.Children.count(m) > 1 ? x.Children.only(null) : x.isValidElement(m) ? m.props.children : null : y); return d.jsx(t, { ...u, ref: a, children: x.isValidElement(m) ? x.cloneElement(m, void 0, v) : null }) } return d.jsx(t, { ...u, ref: a, children: l }) }); return s.displayName = `${r}.Slot`, s } var lg = Os("Slot"); function Lx(r) { const t = x.forwardRef((s, o) => { const { children: a, ...l } = s; if (x.isValidElement(a)) { const u = Fx(a), f = zx(l, a.props); return a.type !== x.Fragment && (f.ref = o ? ag(o, u) : u), x.cloneElement(a, f) } return x.Children.count(a) > 1 ? x.Children.only(null) : null }); return t.displayName = `${r}.SlotClone`, t } var Mx = Symbol("radix.slottable"); function Ux(r) { return x.isValidElement(r) && typeof r.type == "function" && "__radixId" in r.type && r.type.__radixId === Mx } function zx(r, t) { const s = { ...t }; for (const o in t) { const a = r[o], l = t[o]; /^on[A-Z]/.test(o) ? a && l ? s[o] = (...f) => { const p = l(...f); return a(...f), p } : a && (s[o] = a) : o === "style" ? s[o] = { ...a, ...l } : o === "className" && (s[o] = [a, l].filter(Boolean).join(" ")) } return { ...r, ...s } } function Fx(r) { let t = Object.getOwnPropertyDescriptor(r.props, "ref")?.get, s = t && "isReactWarning" in t && t.isReactWarning; return s ? r.ref : (t = Object.getOwnPropertyDescriptor(r, "ref")?.get, s = t && "isReactWarning" in t && t.isReactWarning, s ? r.props.ref : r.props.ref || r.ref) } const Fp = r => typeof r == "boolean" ? `${r}` : r === 0 ? "0" : r, Bp = Ju, Xu = (r, t) => s => { var o; if (t?.variants == null) return Bp(r, s?.class, s?.className); const { variants: a, defaultVariants: l } = t, u = Object.keys(a).map(m => { const v = s?.[m], y = l?.[m]; if (v === null) return null; const _ = Fp(v) || Fp(y); return a[m][_] }), f = s && Object.entries(s).reduce((m, v) => { let [y, _] = v; return _ === void 0 || (m[y] = _), m }, {}), p = t == null || (o = t.compoundVariants) === null || o === void 0 ? void 0 : o.reduce((m, v) => { let { class: y, className: _, ...S } = v; return Object.entries(S).every(E => { let [b, k] = E; return Array.isArray(k) ? k.includes({ ...l, ...f }[b]) : { ...l, ...f }[b] === k }) ? [...m, y, _] : m }, []); return Bp(r, u, p, s?.class, s?.className) }, Bx = Xu("inline-flex items-center justify-center rounded-md border px-2 py-0.5 text-xs font-medium w-fit whitespace-nowrap shrink-0 [&>svg]:size-3 gap-1 [&>svg]:pointer-events-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive transition-[color,box-shadow] overflow-hidden", { variants: { variant: { default: "border-transparent bg-primary text-primary-foreground [a&]:hover:bg-primary/90", secondary: "border-transparent bg-secondary text-secondary-foreground [a&]:hover:bg-secondary/90", destructive: "border-transparent bg-destructive text-white [a&]:hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60", outline: "text-foreground [a&]:hover:bg-accent [a&]:hover:text-accent-foreground" } }, defaultVariants: { variant: "default" } }); function yn({ className: r, variant: t, asChild: s = !1, ...o }) { const a = s ? lg : "span"; return d.jsx(a, { "data-slot": "badge", className: Pe(Bx({ variant: t }), r), ...o }) } function Vx(r, t) { const s = x.createContext(t), o = l => { const { children: u, ...f } = l, p = x.useMemo(() => f, Object.values(f)); return d.jsx(s.Provider, { value: p, children: u }) }; o.displayName = r + "Provider"; function a(l) { const u = x.useContext(s); if (u) return u; if (t !== void 0) return t; throw new Error(`\`${l}\` must be used within \`${r}\``) } return [o, a] } function ar(r, t = []) { let s = []; function o(l, u) { const f = x.createContext(u), p = s.length; s = [...s, u]; const m = y => { const { scope: _, children: S, ...E } = y, b = _?.[r]?.[p] || f, k = x.useMemo(() => E, Object.values(E)); return d.jsx(b.Provider, { value: k, children: S }) }; m.displayName = l + "Provider"; function v(y, _) { const S = _?.[r]?.[p] || f, E = x.useContext(S); if (E) return E; if (u !== void 0) return u; throw new Error(`\`${y}\` must be used within \`${l}\``) } return [m, v] } const a = () => { const l = s.map(u => x.createContext(u)); return function (f) { const p = f?.[r] || l; return x.useMemo(() => ({ [`__scope${r}`]: { ...f, [r]: p } }), [f, p]) } }; return a.scopeName = r, [o, Wx(a, ...t)] } function Wx(...r) { const t = r[0]; if (r.length === 1) return t; const s = () => { const o = r.map(a => ({ useScope: a(), scopeName: a.scopeName })); return function (l) { const u = o.reduce((f, { useScope: p, scopeName: m }) => { const y = p(l)[`__scope${m}`]; return { ...f, ...y } }, {}); return x.useMemo(() => ({ [`__scope${t.scopeName}`]: u }), [u]) } }; return s.scopeName = t.scopeName, s } var Ho = qm(); const Hx = Gu(Ho); var Kx = ["a", "button", "div", "form", "h2", "h3", "img", "input", "label", "li", "nav", "ol", "p", "select", "span", "svg", "ul"], Ee = Kx.reduce((r, t) => { const s = Os(`Primitive.${t}`), o = x.forwardRef((a, l) => { const { asChild: u, ...f } = a, p = u ? s : t; return typeof window < "u" && (window[Symbol.for("radix-ui")] = !0), d.jsx(p, { ...f, ref: l }) }); return o.displayName = `Primitive.${t}`, { ...r, [t]: o } }, {}); function qx(r, t) { r && Ho.flushSync(() => r.dispatchEvent(t)) } var Zu = "Progress", ed = 100, [Gx] = ar(Zu), [Yx, Jx] = Gx(Zu), cg = x.forwardRef((r, t) => { const { __scopeProgress: s, value: o = null, max: a, getValueLabel: l = Qx, ...u } = r; (a || a === 0) && !Vp(a) && console.error(Xx(`${a}`, "Progress")); const f = Vp(a) ? a : ed; o !== null && !Wp(o, f) && console.error(Zx(`${o}`, "Progress")); const p = Wp(o, f) ? o : null, m = _a(p) ? l(p, f) : void 0; return d.jsx(Yx, { scope: s, value: p, max: f, children: d.jsx(Ee.div, { "aria-valuemax": f, "aria-valuemin": 0, "aria-valuenow": _a(p) ? p : void 0, "aria-valuetext": m, role: "progressbar", "data-state": fg(p, f), "data-value": p ?? void 0, "data-max": f, ...u, ref: t }) }) }); cg.displayName = Zu; var ug = "ProgressIndicator", dg = x.forwardRef((r, t) => { const { __scopeProgress: s, ...o } = r, a = Jx(ug, s); return d.jsx(Ee.div, { "data-state": fg(a.value, a.max), "data-value": a.value ?? void 0, "data-max": a.max, ...o, ref: t }) }); dg.displayName = ug; function Qx(r, t) { return `${Math.round(r / t * 100)}%` } function fg(r, t) { return r == null ? "indeterminate" : r === t ? "complete" : "loading" } function _a(r) { return typeof r == "number" } function Vp(r) { return _a(r) && !isNaN(r) && r > 0 } function Wp(r, t) { return _a(r) && !isNaN(r) && r <= t && r >= 0 } function Xx(r, t) { return `Invalid prop \`max\` of value \`${r}\` supplied to \`${t}\`. Only numbers greater than 0 are valid max values. Defaulting to \`${ed}\`.` } function Zx(r, t) {
  return `Invalid prop \`value\` of value \`${r}\` supplied to \`${t}\`. The \`value\` prop must be:
  - a positive number
  - less than the value passed to \`max\` (or ${ed} if no \`max\` prop is set)
  - \`null\` or \`undefined\` if the progress is indeterminate.

Defaulting to \`null\`.`} var hg = cg, eb = dg; function tb(...r) { return ig(Ju(r)) } const Is = x.forwardRef(({ className: r, value: t, ...s }, o) => d.jsx(hg, { ref: o, className: tb("relative h-2 w-full overflow-hidden rounded-full bg-primary/20", r), ...s, children: d.jsx(eb, { className: "h-full w-full flex-1 bg-primary transition-all", style: { transform: `translateX(-${100 - (t || 0)}%)` } }) })); Is.displayName = hg.displayName; const Re = "nkowcjmjqaszwtrvgedt", $e = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im5rb3djam1qcWFzend0cnZnZWR0Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjAwOTk3MTMsImV4cCI6MjA3NTY3NTcxM30.y3wgX9ndQFrplUT8A7C0unZbe6E-H1Ygz1hpiJW2am4", nb = () => { try { const t = localStorage.getItem("currentUser"); if (t) { const s = JSON.parse(t); if (s?.employeeId) { const o = String(s.employeeId).trim(); if (o) { const a = `employee_${o}`; return localStorage.getItem("learningHubid") !== a && localStorage.setItem("learningHubid", a), a } } } } catch (t) { console.warn("currentUser 파싱 오류:", t) } let r = localStorage.getItem("learningHubid"); return r || (r = `user_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`, localStorage.setItem("learningHubid", r)), r }, Hp = async (r, t, s, o) => { const a = nb(); let l = "", u = ""; try { const m = localStorage.getItem("currentUser"); if (m) { const v = JSON.parse(m); l = (v.name || "").trim(), u = (v.employeeId || "").trim() } } catch (m) { console.warn("currentUser 파싱 오류:", m) } console.log("💾 progressTracker.saveProgress called:", { id: a, userName: l, employeeId: u, videoId: r, categoryId: t, progress: s, watchTime: o }); const f = `progress_${r}`, p = { id: a, userName: l, employeeId: u, videoId: r, categoryId: t, progress: s, watchTime: o, lastWatched: new Date().toISOString() }; localStorage.setItem(f, JSON.stringify(p)), console.log("✅ Saved to localStorage with key:", f); try { const m = Date.now(); console.log("🌐 Attempting backend save to:", `https://${Re}.supabase.co/functions/v1/make-server-a8898ff1/progress?v=${m}`); const v = await fetch(`https://${Re}.supabase.co/functions/v1/make-server-a8898ff1/progress?v=${m}`, { method: "POST", cache: "no-store", headers: { "Content-Type": "application/json", Authorization: `Bearer ${$e}`, "Cache-Control": "no-cache" }, body: JSON.stringify({ id: a, userName: l, employeeId: u, videoId: r, categoryId: t, progress: s, watchTime: o }) }); v.ok ? console.log("✅ Backend save successful") : console.error("❌ Backend save failed with status:", v.status) } catch (m) { console.error("❌ Backend save error:", m) } }, Da = () => { const [r, t] = x.useState({}), s = () => { const f = localStorage.getItem("currentUser"); if (f) try { return JSON.parse(f) } catch (p) { console.error("Failed to parse current user:", p) } return null }; x.useEffect(() => { const f = s(), p = f ? `video-progress-${f.employeeId}` : "video-progress", m = localStorage.getItem(p); if (m) try { t(JSON.parse(m)) } catch (v) { console.error("Failed to parse progress data:", v) } else t({}) }, []); const o = x.useCallback(f => { const p = s(), m = p ? `video-progress-${p.employeeId}` : "video-progress"; localStorage.setItem(m, JSON.stringify(f)), t(f) }, []), a = x.useCallback(async (f, p, m, v) => { const y = p >= m * .9, _ = Math.min(p / m * 100, 100); console.log("💾 Saving progress:", { videoId: f, watchedSeconds: p, totalDuration: m, progressPercentage: _.toFixed(1) + "%", categoryId: v, completed: y }); const S = { videoId: f, watchedSeconds: p, completed: y, lastWatchedAt: new Date().toISOString() }, E = { ...r, [f]: S }; if (o(E), console.log("✅ Saved to localStorage"), v) try { console.log("🌐 Attempting backend save..."), await Hp(f, v, _, p), console.log("✅ Backend save successful") } catch (b) { console.error("❌ Failed to save progress to backend:", b) } else console.log("⚠️ No categoryId provided, skipping backend save") }, [r, Hp]), l = x.useCallback(f => r[f] || null, [r]), u = x.useCallback((f, p) => { const m = l(f); return m ? Math.min(m.watchedSeconds / p * 100, 100) : 0 }, [l]); return { updateProgress: a, getProgress: l, getProgressPercentage: u, progressData: r } };/**
 * @license lucide-react v0.487.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const rb = r => r.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase(), sb = r => r.replace(/^([A-Z])|[\s-_]+(\w)/g, (t, s, o) => o ? o.toUpperCase() : s.toLowerCase()), Kp = r => { const t = sb(r); return t.charAt(0).toUpperCase() + t.slice(1) }, pg = (...r) => r.filter((t, s, o) => !!t && t.trim() !== "" && o.indexOf(t) === s).join(" ").trim();/**
 * @license lucide-react v0.487.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */var ob = { xmlns: "http://www.w3.org/2000/svg", width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: 2, strokeLinecap: "round", strokeLinejoin: "round" };/**
 * @license lucide-react v0.487.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const ib = x.forwardRef(({ color: r = "currentColor", size: t = 24, strokeWidth: s = 2, absoluteStrokeWidth: o, className: a = "", children: l, iconNode: u, ...f }, p) => x.createElement("svg", { ref: p, ...ob, width: t, height: t, stroke: r, strokeWidth: o ? Number(s) * 24 / Number(t) : s, className: pg("lucide", a), ...f }, [...u.map(([m, v]) => x.createElement(m, v)), ...Array.isArray(l) ? l : [l]]));/**
 * @license lucide-react v0.487.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const Ae = (r, t) => { const s = x.forwardRef(({ className: o, ...a }, l) => x.createElement(ib, { ref: l, iconNode: t, className: pg(`lucide-${rb(Kp(r))}`, `lucide-${r}`, o), ...a })); return s.displayName = Kp(r), s };/**
 * @license lucide-react v0.487.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const ab = [["path", { d: "m12 19-7-7 7-7", key: "1l729n" }], ["path", { d: "M19 12H5", key: "x3x0zl" }]], td = Ae("arrow-left", ab);/**
 * @license lucide-react v0.487.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const lb = [["path", { d: "M20 6 9 17l-5-5", key: "1gmf2c" }]], cb = Ae("check", lb);/**
 * @license lucide-react v0.487.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const ub = [["path", { d: "m6 9 6 6 6-6", key: "qrunsl" }]], mg = Ae("chevron-down", ub);/**
 * @license lucide-react v0.487.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const db = [["path", { d: "m18 15-6-6-6 6", key: "153udz" }]], fb = Ae("chevron-up", db);/**
 * @license lucide-react v0.487.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const hb = [["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }], ["line", { x1: "12", x2: "12", y1: "8", y2: "12", key: "1pkeuh" }], ["line", { x1: "12", x2: "12.01", y1: "16", y2: "16", key: "4dfq90" }]], pb = Ae("circle-alert", hb);/**
 * @license lucide-react v0.487.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const mb = [["path", { d: "M21.801 10A10 10 0 1 1 17 3.335", key: "yps3ct" }], ["path", { d: "m9 11 3 3L22 4", key: "1pflzl" }]], gg = Ae("circle-check-big", mb);/**
 * @license lucide-react v0.487.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const gb = [["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }], ["polygon", { points: "10 8 16 12 10 16 10 8", key: "1cimsy" }]], vg = Ae("circle-play", gb);/**
 * @license lucide-react v0.487.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const vb = [["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }], ["polyline", { points: "12 6 12 12 16 14", key: "68esgv" }]], yu = Ae("clock", vb);/**
 * @license lucide-react v0.487.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const yb = [["path", { d: "M15 3h6v6", key: "1q9fwt" }], ["path", { d: "M10 14 21 3", key: "gplh6r" }], ["path", { d: "M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6", key: "a6xqqp" }]], wu = Ae("external-link", yb);/**
 * @license lucide-react v0.487.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const wb = [["path", { d: "M2.062 12.348a1 1 0 0 1 0-.696 10.75 10.75 0 0 1 19.876 0 1 1 0 0 1 0 .696 10.75 10.75 0 0 1-19.876 0", key: "1nclc0" }], ["circle", { cx: "12", cy: "12", r: "3", key: "1v7zrd" }]], xb = Ae("eye", wb);/**
 * @license lucide-react v0.487.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const bb = [["path", { d: "M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z", key: "1rqfz7" }], ["path", { d: "M14 2v4a2 2 0 0 0 2 2h4", key: "tnqrlb" }], ["path", { d: "m10 11 5 3-5 3v-6Z", key: "7ntvm4" }]], la = Ae("file-video", bb);/**
 * @license lucide-react v0.487.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const _b = [["path", { d: "m6 14 1.5-2.9A2 2 0 0 1 9.24 10H20a2 2 0 0 1 1.94 2.5l-1.54 6a2 2 0 0 1-1.95 1.5H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h3.9a2 2 0 0 1 1.69.9l.81 1.2a2 2 0 0 0 1.67.9H18a2 2 0 0 1 2 2v2", key: "usdka0" }]], yg = Ae("folder-open", _b);/**
 * @license lucide-react v0.487.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const Sb = [["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }], ["path", { d: "M12 16v-4", key: "1dtifu" }], ["path", { d: "M12 8h.01", key: "e9boi3" }]], qp = Ae("info", Sb);/**
 * @license lucide-react v0.487.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const kb = [["path", { d: "M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4", key: "1uf3rs" }], ["polyline", { points: "16 17 21 12 16 7", key: "1gabdz" }], ["line", { x1: "21", x2: "9", y1: "12", y2: "12", key: "1uyos4" }]], wg = Ae("log-out", kb);/**
 * @license lucide-react v0.487.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const Eb = [["path", { d: "M8 3H5a2 2 0 0 0-2 2v3", key: "1dcmit" }], ["path", { d: "M21 8V5a2 2 0 0 0-2-2h-3", key: "1e4gt3" }], ["path", { d: "M3 16v3a2 2 0 0 0 2 2h3", key: "wsl5sc" }], ["path", { d: "M16 21h3a2 2 0 0 0 2-2v-3", key: "18trek" }]], jb = Ae("maximize", Eb);/**
 * @license lucide-react v0.487.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const Cb = [["rect", { x: "14", y: "4", width: "4", height: "16", rx: "1", key: "zuxfzm" }], ["rect", { x: "6", y: "4", width: "4", height: "16", rx: "1", key: "1okwgv" }]], Nb = Ae("pause", Cb);/**
 * @license lucide-react v0.487.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const Tb = [["polygon", { points: "6 3 20 12 6 21 6 3", key: "1oa8hb" }]], Sa = Ae("play", Tb);/**
 * @license lucide-react v0.487.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const Pb = [["path", { d: "M5 12h14", key: "1ays0h" }], ["path", { d: "M12 5v14", key: "s699le" }]], nd = Ae("plus", Pb);/**
 * @license lucide-react v0.487.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const Rb = [["path", { d: "M21 12a9 9 0 0 0-9-9 9.75 9.75 0 0 0-6.74 2.74L3 8", key: "14sxne" }], ["path", { d: "M3 3v5h5", key: "1xhq8a" }], ["path", { d: "M3 12a9 9 0 0 0 9 9 9.75 9.75 0 0 0 6.74-2.74L21 16", key: "1hlbsb" }], ["path", { d: "M16 16h5v5", key: "ccwih5" }]], Ab = Ae("refresh-ccw", Rb);/**
 * @license lucide-react v0.487.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const Ob = [["path", { d: "M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8", key: "1357e3" }], ["path", { d: "M3 3v5h5", key: "1xhq8a" }]], Ib = Ae("rotate-ccw", Ob);/**
 * @license lucide-react v0.487.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const Db = [["circle", { cx: "11", cy: "11", r: "8", key: "4ej97u" }], ["path", { d: "m21 21-4.3-4.3", key: "1qie3q" }]], $b = Ae("search", Db);/**
 * @license lucide-react v0.487.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const Lb = [["path", { d: "M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.08a2 2 0 0 1-1-1.74v-.5a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z", key: "1qme2f" }], ["circle", { cx: "12", cy: "12", r: "3", key: "1v7zrd" }]], xg = Ae("settings", Lb);/**
 * @license lucide-react v0.487.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const Mb = [["path", { d: "M20 13c0 5-3.5 7.5-7.66 8.95a1 1 0 0 1-.67-.01C7.5 20.5 4 18 4 13V6a1 1 0 0 1 1-1c2 0 4.5-1.2 6.24-2.72a1.17 1.17 0 0 1 1.52 0C14.51 3.81 17 5 19 5a1 1 0 0 1 1 1z", key: "oel41y" }]], Ub = Ae("shield", Mb);/**
 * @license lucide-react v0.487.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const zb = [["path", { d: "M12 3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7", key: "1m0v6g" }], ["path", { d: "M18.375 2.625a1 1 0 0 1 3 3l-9.013 9.014a2 2 0 0 1-.853.505l-2.873.84a.5.5 0 0 1-.62-.62l.84-2.873a2 2 0 0 1 .506-.852z", key: "ohrbg2" }]], rd = Ae("square-pen", zb);/**
 * @license lucide-react v0.487.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const Fb = [["path", { d: "M3 6h18", key: "d0wm0j" }], ["path", { d: "M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6", key: "4alrt4" }], ["path", { d: "M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2", key: "v07s0e" }], ["line", { x1: "10", x2: "10", y1: "11", y2: "17", key: "1uufr5" }], ["line", { x1: "14", x2: "14", y1: "11", y2: "17", key: "xtxkd" }]], sd = Ae("trash-2", Fb);/**
 * @license lucide-react v0.487.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const Bb = [["path", { d: "m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3", key: "wmoenq" }], ["path", { d: "M12 9v4", key: "juzpu7" }], ["path", { d: "M12 17h.01", key: "p32p05" }]], Vb = Ae("triangle-alert", Bb);/**
 * @license lucide-react v0.487.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const Wb = [["path", { d: "M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4", key: "ih7n3h" }], ["polyline", { points: "17 8 12 3 7 8", key: "t8dd8p" }], ["line", { x1: "12", x2: "12", y1: "3", y2: "15", key: "widbto" }]], bg = Ae("upload", Wb);/**
 * @license lucide-react v0.487.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const Hb = [["path", { d: "M19 21v-2a4 4 0 0 0-4-4H9a4 4 0 0 0-4 4v2", key: "975kel" }], ["circle", { cx: "12", cy: "7", r: "4", key: "17ys0d" }]], _g = Ae("user", Hb);/**
 * @license lucide-react v0.487.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const Kb = [["path", { d: "M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2", key: "1yyitq" }], ["circle", { cx: "9", cy: "7", r: "4", key: "nufk8" }], ["path", { d: "M22 21v-2a4 4 0 0 0-3-3.87", key: "kshegd" }], ["path", { d: "M16 3.13a4 4 0 0 1 0 7.75", key: "1da9ce" }]], Sg = Ae("users", Kb);/**
 * @license lucide-react v0.487.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const qb = [["path", { d: "m16 13 5.223 3.482a.5.5 0 0 0 .777-.416V7.87a.5.5 0 0 0-.752-.432L16 10.5", key: "ftymec" }], ["rect", { x: "2", y: "6", width: "14", height: "12", rx: "2", key: "158x01" }]], kg = Ae("video", qb);/**
 * @license lucide-react v0.487.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const Gb = [["path", { d: "M11 4.702a.705.705 0 0 0-1.203-.498L6.413 7.587A1.4 1.4 0 0 1 5.416 8H3a1 1 0 0 0-1 1v6a1 1 0 0 0 1 1h2.416a1.4 1.4 0 0 1 .997.413l3.383 3.384A.705.705 0 0 0 11 19.298z", key: "uqj9uw" }], ["path", { d: "M16 9a5 5 0 0 1 0 6", key: "1q6k2b" }], ["path", { d: "M19.364 18.364a9 9 0 0 0 0-12.728", key: "ijwkga" }]], Yb = Ae("volume-2", Gb);/**
 * @license lucide-react v0.487.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const Jb = [["path", { d: "M11 4.702a.705.705 0 0 0-1.203-.498L6.413 7.587A1.4 1.4 0 0 1 5.416 8H3a1 1 0 0 0-1 1v6a1 1 0 0 0 1 1h2.416a1.4 1.4 0 0 1 .997.413l3.383 3.384A.705.705 0 0 0 11 19.298z", key: "uqj9uw" }], ["line", { x1: "22", x2: "16", y1: "9", y2: "15", key: "1ewh16" }], ["line", { x1: "16", x2: "22", y1: "9", y2: "15", key: "5ykzw1" }]], Qb = Ae("volume-x", Jb);/**
 * @license lucide-react v0.487.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const Xb = [["path", { d: "M18 6 6 18", key: "1bl5f8" }], ["path", { d: "m6 6 12 12", key: "d8bk6v" }]], Eg = Ae("x", Xb);/**
 * @license lucide-react v0.487.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const Zb = [["path", { d: "M2.5 17a24.12 24.12 0 0 1 0-10 2 2 0 0 1 1.4-1.4 49.56 49.56 0 0 1 16.2 0A2 2 0 0 1 21.5 7a24.12 24.12 0 0 1 0 10 2 2 0 0 1-1.4 1.4 49.55 49.55 0 0 1-16.2 0A2 2 0 0 1 2.5 17", key: "1q2vi4" }], ["path", { d: "m10 15 5-3-5-3z", key: "1jp15x" }]], Yc = Ae("youtube", Zb), Gp = ({ video: r, onSelect: t }) => { const { getProgressPercentage: s, getProgress: o } = Da(), a = s(r.id, r.duration), u = o(r.id)?.completed || !1, f = p => { const m = Math.floor(p / 60), v = p % 60; return `${m}:${v.toString().padStart(2, "0")}` }; return d.jsx(ht, { className: "cursor-pointer hover:shadow-md transition-shadow duration-200 overflow-hidden", onClick: () => t(r), children: d.jsxs("div", { className: "flex gap-4 p-4", children: [d.jsxs("div", { className: "relative flex-shrink-0", children: [d.jsxs("div", { className: "w-40 h-24 rounded-lg overflow-hidden bg-muted", children: [d.jsx("img", { src: r.thumbnail, alt: r.title, className: "w-full h-full object-cover" }), d.jsx("div", { className: "absolute inset-0 flex items-center justify-center", children: u ? d.jsx(gg, { className: "w-8 h-8 text-green-500" }) : d.jsx(vg, { className: "w-8 h-8 text-white/90" }) })] }), d.jsx(yn, { variant: "secondary", className: "absolute bottom-1 right-1 text-md", children: f(r.duration) })] }), d.jsxs("div", { className: "flex-1 min-w-0", children: [d.jsxs("div", { className: "flex items-start gap-2 mb-2", children: [d.jsx("h3", { className: "line-clamp-2 flex-1", children: r.title }), u && d.jsx(yn, { variant: "default", className: "shrink-0 bg-green-500", children: "완료" })] }), d.jsx("p", { className: "text-muted-foreground line-clamp-2 mb-3", children: r.description }), a > 0 && d.jsxs("div", { className: "space-y-1", children: [d.jsxs("div", { className: "flex items-center justify-between", children: [d.jsx("span", { className: "text-sm text-muted-foreground", children: "시청 진행률" }), d.jsxs("span", { className: "text-sm", children: [Math.round(a), "%"] })] }), d.jsx(Is, { value: a, className: "h-2" })] })] })] }) }) }, e_ = Xu("inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive", { variants: { variant: { default: "bg-primary text-primary-foreground hover:bg-primary/90", destructive: "bg-destructive text-white hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60", outline: "border bg-background text-foreground hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50", secondary: "bg-secondary text-secondary-foreground hover:bg-secondary/80", ghost: "hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50", link: "text-primary underline-offset-4 hover:underline" }, size: { default: "h-9 px-4 py-2 has-[>svg]:px-3", sm: "h-8 rounded-md gap-1.5 px-3 has-[>svg]:px-2.5", lg: "h-10 rounded-md px-6 has-[>svg]:px-4", icon: "size-9 rounded-md" } }, defaultVariants: { variant: "default", size: "default" } }); function Ne({ className: r, variant: t, size: s, asChild: o = !1, ...a }) { const l = o ? lg : "button"; return d.jsx(l, { "data-slot": "button", className: Pe(e_({ variant: t, size: s, className: r })), ...a }) } function ka(r, [t, s]) { return Math.min(s, Math.max(t, r)) } function ke(r, t, { checkForDefaultPrevented: s = !0 } = {}) { return function (a) { if (r?.(a), s === !1 || !a.defaultPrevented) return t?.(a) } } var bt = globalThis?.document ? x.useLayoutEffect : () => { }, t_ = Gm[" useInsertionEffect ".trim().toString()] || bt; function Ds({ prop: r, defaultProp: t, onChange: s = () => { }, caller: o }) { const [a, l, u] = n_({ defaultProp: t, onChange: s }), f = r !== void 0, p = f ? r : a; { const v = x.useRef(r !== void 0); x.useEffect(() => { const y = v.current; y !== f && console.warn(`${o} is changing from ${y ? "controlled" : "uncontrolled"} to ${f ? "controlled" : "uncontrolled"}. Components should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled value for the lifetime of the component.`), v.current = f }, [f, o]) } const m = x.useCallback(v => { if (f) { const y = r_(v) ? v(r) : v; y !== r && u.current?.(y) } else l(v) }, [f, r, l, u]); return [p, m] } function n_({ defaultProp: r, onChange: t }) { const [s, o] = x.useState(r), a = x.useRef(s), l = x.useRef(t); return t_(() => { l.current = t }, [t]), x.useEffect(() => { a.current !== s && (l.current?.(s), a.current = s) }, [s, a]), [s, o, l] } function r_(r) { return typeof r == "function" } var s_ = x.createContext(void 0); function $a(r) { const t = x.useContext(s_); return r || t || "ltr" } function jg(r) { const t = x.useRef({ value: r, previous: r }); return x.useMemo(() => (t.current.value !== r && (t.current.previous = t.current.value, t.current.value = r), t.current.previous), [r]) } function Cg(r) { const [t, s] = x.useState(void 0); return bt(() => { if (r) { s({ width: r.offsetWidth, height: r.offsetHeight }); const o = new ResizeObserver(a => { if (!Array.isArray(a) || !a.length) return; const l = a[0]; let u, f; if ("borderBoxSize" in l) { const p = l.borderBoxSize, m = Array.isArray(p) ? p[0] : p; u = m.inlineSize, f = m.blockSize } else u = r.offsetWidth, f = r.offsetHeight; s({ width: u, height: f }) }); return o.observe(r, { box: "border-box" }), () => o.unobserve(r) } else s(void 0) }, [r]), t } function od(r) { const t = r + "CollectionProvider", [s, o] = ar(t), [a, l] = s(t, { collectionRef: { current: null }, itemMap: new Map }), u = b => { const { scope: k, children: C } = b, T = Lt.useRef(null), P = Lt.useRef(new Map).current; return d.jsx(a, { scope: k, itemMap: P, collectionRef: T, children: C }) }; u.displayName = t; const f = r + "CollectionSlot", p = Os(f), m = Lt.forwardRef((b, k) => { const { scope: C, children: T } = b, P = l(f, C), I = ze(k, P.collectionRef); return d.jsx(p, { ref: I, children: T }) }); m.displayName = f; const v = r + "CollectionItemSlot", y = "data-radix-collection-item", _ = Os(v), S = Lt.forwardRef((b, k) => { const { scope: C, children: T, ...P } = b, I = Lt.useRef(null), O = ze(k, I), V = l(v, C); return Lt.useEffect(() => (V.itemMap.set(I, { ref: I, ...P }), () => void V.itemMap.delete(I))), d.jsx(_, { [y]: "", ref: O, children: T }) }); S.displayName = v; function E(b) { const k = l(r + "CollectionConsumer", b); return Lt.useCallback(() => { const T = k.collectionRef.current; if (!T) return []; const P = Array.from(T.querySelectorAll(`[${y}]`)); return Array.from(k.itemMap.values()).sort((V, M) => P.indexOf(V.ref.current) - P.indexOf(M.ref.current)) }, [k.collectionRef, k.itemMap]) } return [{ Provider: u, Slot: m, ItemSlot: S }, E, o] } var Ng = ["PageUp", "PageDown"], Tg = ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"], Pg = { "from-left": ["Home", "PageDown", "ArrowDown", "ArrowLeft"], "from-right": ["Home", "PageDown", "ArrowDown", "ArrowRight"], "from-bottom": ["Home", "PageDown", "ArrowDown", "ArrowLeft"], "from-top": ["Home", "PageDown", "ArrowUp", "ArrowLeft"] }, zs = "Slider", [xu, o_, i_] = od(zs), [Rg] = ar(zs, [i_]), [a_, La] = Rg(zs), Ag = x.forwardRef((r, t) => { const { name: s, min: o = 0, max: a = 100, step: l = 1, orientation: u = "horizontal", disabled: f = !1, minStepsBetweenThumbs: p = 0, defaultValue: m = [o], value: v, onValueChange: y = () => { }, onValueCommit: _ = () => { }, inverted: S = !1, form: E, ...b } = r, k = x.useRef(new Set), C = x.useRef(0), P = u === "horizontal" ? l_ : c_, [I = [], O] = Ds({ prop: v, defaultProp: m, onChange: K => { [...k.current][C.current]?.focus(), y(K) } }), V = x.useRef(I); function M(K) { const G = p_(I, K); F(K, G) } function R(K) { F(K, C.current) } function L() { const K = V.current[C.current]; I[C.current] !== K && _(I) } function F(K, G, { commit: oe } = { commit: !1 }) { const ae = y_(l), ue = w_(Math.round((K - o) / l) * l + o, ae), te = ka(ue, [o, a]); O((ne = []) => { const $ = f_(ne, te, G); if (v_($, p * l)) { C.current = $.indexOf(te); const ee = String($) !== String(ne); return ee && oe && _($), ee ? $ : ne } else return ne }) } return d.jsx(a_, { scope: r.__scopeSlider, name: s, disabled: f, min: o, max: a, valueIndexToChangeRef: C, thumbs: k.current, values: I, orientation: u, form: E, children: d.jsx(xu.Provider, { scope: r.__scopeSlider, children: d.jsx(xu.Slot, { scope: r.__scopeSlider, children: d.jsx(P, { "aria-disabled": f, "data-disabled": f ? "" : void 0, ...b, ref: t, onPointerDown: ke(b.onPointerDown, () => { f || (V.current = I) }), min: o, max: a, inverted: S, onSlideStart: f ? void 0 : M, onSlideMove: f ? void 0 : R, onSlideEnd: f ? void 0 : L, onHomeKeyDown: () => !f && F(o, 0, { commit: !0 }), onEndKeyDown: () => !f && F(a, I.length - 1, { commit: !0 }), onStepKeyDown: ({ event: K, direction: G }) => { if (!f) { const ue = Ng.includes(K.key) || K.shiftKey && Tg.includes(K.key) ? 10 : 1, te = C.current, ne = I[te], $ = l * ue * G; F(ne + $, te, { commit: !0 }) } } }) }) }) }) }); Ag.displayName = zs; var [Og, Ig] = Rg(zs, { startEdge: "left", endEdge: "right", size: "width", direction: 1 }), l_ = x.forwardRef((r, t) => { const { min: s, max: o, dir: a, inverted: l, onSlideStart: u, onSlideMove: f, onSlideEnd: p, onStepKeyDown: m, ...v } = r, [y, _] = x.useState(null), S = ze(t, P => _(P)), E = x.useRef(void 0), b = $a(a), k = b === "ltr", C = k && !l || !k && l; function T(P) { const I = E.current || y.getBoundingClientRect(), O = [0, I.width], M = id(O, C ? [s, o] : [o, s]); return E.current = I, M(P - I.left) } return d.jsx(Og, { scope: r.__scopeSlider, startEdge: C ? "left" : "right", endEdge: C ? "right" : "left", direction: C ? 1 : -1, size: "width", children: d.jsx(Dg, { dir: b, "data-orientation": "horizontal", ...v, ref: S, style: { ...v.style, "--radix-slider-thumb-transform": "translateX(-50%)" }, onSlideStart: P => { const I = T(P.clientX); u?.(I) }, onSlideMove: P => { const I = T(P.clientX); f?.(I) }, onSlideEnd: () => { E.current = void 0, p?.() }, onStepKeyDown: P => { const O = Pg[C ? "from-left" : "from-right"].includes(P.key); m?.({ event: P, direction: O ? -1 : 1 }) } }) }) }), c_ = x.forwardRef((r, t) => { const { min: s, max: o, inverted: a, onSlideStart: l, onSlideMove: u, onSlideEnd: f, onStepKeyDown: p, ...m } = r, v = x.useRef(null), y = ze(t, v), _ = x.useRef(void 0), S = !a; function E(b) { const k = _.current || v.current.getBoundingClientRect(), C = [0, k.height], P = id(C, S ? [o, s] : [s, o]); return _.current = k, P(b - k.top) } return d.jsx(Og, { scope: r.__scopeSlider, startEdge: S ? "bottom" : "top", endEdge: S ? "top" : "bottom", size: "height", direction: S ? 1 : -1, children: d.jsx(Dg, { "data-orientation": "vertical", ...m, ref: y, style: { ...m.style, "--radix-slider-thumb-transform": "translateY(50%)" }, onSlideStart: b => { const k = E(b.clientY); l?.(k) }, onSlideMove: b => { const k = E(b.clientY); u?.(k) }, onSlideEnd: () => { _.current = void 0, f?.() }, onStepKeyDown: b => { const C = Pg[S ? "from-bottom" : "from-top"].includes(b.key); p?.({ event: b, direction: C ? -1 : 1 }) } }) }) }), Dg = x.forwardRef((r, t) => { const { __scopeSlider: s, onSlideStart: o, onSlideMove: a, onSlideEnd: l, onHomeKeyDown: u, onEndKeyDown: f, onStepKeyDown: p, ...m } = r, v = La(zs, s); return d.jsx(Ee.span, { ...m, ref: t, onKeyDown: ke(r.onKeyDown, y => { y.key === "Home" ? (u(y), y.preventDefault()) : y.key === "End" ? (f(y), y.preventDefault()) : Ng.concat(Tg).includes(y.key) && (p(y), y.preventDefault()) }), onPointerDown: ke(r.onPointerDown, y => { const _ = y.target; _.setPointerCapture(y.pointerId), y.preventDefault(), v.thumbs.has(_) ? _.focus() : o(y) }), onPointerMove: ke(r.onPointerMove, y => { y.target.hasPointerCapture(y.pointerId) && a(y) }), onPointerUp: ke(r.onPointerUp, y => { const _ = y.target; _.hasPointerCapture(y.pointerId) && (_.releasePointerCapture(y.pointerId), l(y)) }) }) }), $g = "SliderTrack", Lg = x.forwardRef((r, t) => { const { __scopeSlider: s, ...o } = r, a = La($g, s); return d.jsx(Ee.span, { "data-disabled": a.disabled ? "" : void 0, "data-orientation": a.orientation, ...o, ref: t }) }); Lg.displayName = $g; var bu = "SliderRange", Mg = x.forwardRef((r, t) => { const { __scopeSlider: s, ...o } = r, a = La(bu, s), l = Ig(bu, s), u = x.useRef(null), f = ze(t, u), p = a.values.length, m = a.values.map(_ => Fg(_, a.min, a.max)), v = p > 1 ? Math.min(...m) : 0, y = 100 - Math.max(...m); return d.jsx(Ee.span, { "data-orientation": a.orientation, "data-disabled": a.disabled ? "" : void 0, ...o, ref: f, style: { ...r.style, [l.startEdge]: v + "%", [l.endEdge]: y + "%" } }) }); Mg.displayName = bu; var _u = "SliderThumb", Ug = x.forwardRef((r, t) => { const s = o_(r.__scopeSlider), [o, a] = x.useState(null), l = ze(t, f => a(f)), u = x.useMemo(() => o ? s().findIndex(f => f.ref.current === o) : -1, [s, o]); return d.jsx(u_, { ...r, ref: l, index: u }) }), u_ = x.forwardRef((r, t) => { const { __scopeSlider: s, index: o, name: a, ...l } = r, u = La(_u, s), f = Ig(_u, s), [p, m] = x.useState(null), v = ze(t, T => m(T)), y = p ? u.form || !!p.closest("form") : !0, _ = Cg(p), S = u.values[o], E = S === void 0 ? 0 : Fg(S, u.min, u.max), b = h_(o, u.values.length), k = _?.[f.size], C = k ? m_(k, E, f.direction) : 0; return x.useEffect(() => { if (p) return u.thumbs.add(p), () => { u.thumbs.delete(p) } }, [p, u.thumbs]), d.jsxs("span", { style: { transform: "var(--radix-slider-thumb-transform)", position: "absolute", [f.startEdge]: `calc(${E}% + ${C}px)` }, children: [d.jsx(xu.ItemSlot, { scope: r.__scopeSlider, children: d.jsx(Ee.span, { role: "slider", "aria-label": r["aria-label"] || b, "aria-valuemin": u.min, "aria-valuenow": S, "aria-valuemax": u.max, "aria-orientation": u.orientation, "data-orientation": u.orientation, "data-disabled": u.disabled ? "" : void 0, tabIndex: u.disabled ? void 0 : 0, ...l, ref: v, style: S === void 0 ? { display: "none" } : r.style, onFocus: ke(r.onFocus, () => { u.valueIndexToChangeRef.current = o }) }) }), y && d.jsx(zg, { name: a ?? (u.name ? u.name + (u.values.length > 1 ? "[]" : "") : void 0), form: u.form, value: S }, o)] }) }); Ug.displayName = _u; var d_ = "RadioBubbleInput", zg = x.forwardRef(({ __scopeSlider: r, value: t, ...s }, o) => { const a = x.useRef(null), l = ze(a, o), u = jg(t); return x.useEffect(() => { const f = a.current; if (!f) return; const p = window.HTMLInputElement.prototype, v = Object.getOwnPropertyDescriptor(p, "value").set; if (u !== t && v) { const y = new Event("input", { bubbles: !0 }); v.call(f, t), f.dispatchEvent(y) } }, [u, t]), d.jsx(Ee.input, { style: { display: "none" }, ...s, ref: l, defaultValue: t }) }); zg.displayName = d_; function f_(r = [], t, s) { const o = [...r]; return o[s] = t, o.sort((a, l) => a - l) } function Fg(r, t, s) { const l = 100 / (s - t) * (r - t); return ka(l, [0, 100]) } function h_(r, t) { return t > 2 ? `Value ${r + 1} of ${t}` : t === 2 ? ["Minimum", "Maximum"][r] : void 0 } function p_(r, t) { if (r.length === 1) return 0; const s = r.map(a => Math.abs(a - t)), o = Math.min(...s); return s.indexOf(o) } function m_(r, t, s) { const o = r / 2, l = id([0, 50], [0, o]); return (o - l(t) * s) * s } function g_(r) { return r.slice(0, -1).map((t, s) => r[s + 1] - t) } function v_(r, t) { if (t > 0) { const s = g_(r); return Math.min(...s) >= t } return !0 } function id(r, t) { return s => { if (r[0] === r[1] || t[0] === t[1]) return t[0]; const o = (t[1] - t[0]) / (r[1] - r[0]); return t[0] + o * (s - r[0]) } } function y_(r) { return (String(r).split(".")[1] || "").length } function w_(r, t) { const s = Math.pow(10, t); return Math.round(r * s) / s } var x_ = Ag, b_ = Lg, __ = Mg, S_ = Ug; function Yp({ className: r, defaultValue: t, value: s, min: o = 0, max: a = 100, ...l }) { const u = x.useMemo(() => Array.isArray(s) ? s : Array.isArray(t) ? t : [o, a], [s, t, o, a]); return d.jsxs(x_, { "data-slot": "slider", defaultValue: t, value: s, min: o, max: a, className: Pe("relative flex w-full touch-none items-center select-none data-[disabled]:opacity-50 data-[orientation=vertical]:h-full data-[orientation=vertical]:min-h-44 data-[orientation=vertical]:w-auto data-[orientation=vertical]:flex-col", r), ...l, children: [d.jsx(b_, { "data-slot": "slider-track", className: Pe("bg-muted relative grow overflow-hidden rounded-full data-[orientation=horizontal]:h-4 data-[orientation=horizontal]:w-full data-[orientation=vertical]:h-full data-[orientation=vertical]:w-1.5"), children: d.jsx(__, { "data-slot": "slider-range", className: Pe("bg-primary absolute data-[orientation=horizontal]:h-full data-[orientation=vertical]:w-full") }) }), Array.from({ length: u.length }, (f, p) => d.jsx(S_, { "data-slot": "slider-thumb", className: "border-primary bg-background ring-ring/50 block size-4 shrink-0 rounded-full border shadow-sm transition-[color,box-shadow] hover:ring-4 focus-visible:ring-4 focus-visible:outline-hidden disabled:pointer-events-none disabled:opacity-50" }, p))] }) } const k_ = ({ video: r, categoryId: t }) => { const s = x.useRef(null), o = x.useRef(null), a = x.useRef(null), [l, u] = x.useState(!1), [f, p] = x.useState(!1), [m, v] = x.useState(!1), [y, _] = x.useState(0), [S, E] = x.useState(0), [b, k] = x.useState(1), { updateProgress: C } = Da(), T = x.useRef(); x.useEffect(() => { if (r.videoType !== "youtube") return; if (window.YT) { u(!0); return } const G = document.createElement("script"); G.src = "https://www.youtube.com/iframe_api"; const oe = document.getElementsByTagName("script")[0]; oe.parentNode?.insertBefore(G, oe), window.onYouTubeIframeAPIReady = () => { u(!0) } }, [r.videoType]), x.useEffect(() => { if (!(r.videoType !== "youtube" || !l || !a.current || !r.youtubeId)) return s.current = new window.YT.Player(a.current, { height: "100%", width: "100%", videoId: r.youtubeId, playerVars: { autoplay: 0, controls: 1, modestbranding: 1, rel: 0 }, events: { onReady: () => { console.log("YouTube Player ready") }, onStateChange: G => { G.data === window.YT.PlayerState.PLAYING ? (p(!0), P()) : (p(!1), I()) } } }), () => { s.current && s.current.destroy(), I() } }, [l, r.youtubeId, r.videoType]), x.useEffect(() => { if (r.videoType !== "local" || !o.current) return; const G = o.current, oe = () => { E(G.duration) }, ae = () => { _(G.currentTime) }, ue = () => { p(!0), P() }, te = () => { p(!1), I() }, ne = () => { k(G.volume), v(G.muted) }; return G.addEventListener("loadedmetadata", oe), G.addEventListener("timeupdate", ae), G.addEventListener("play", ue), G.addEventListener("pause", te), G.addEventListener("volumechange", ne), () => { G.removeEventListener("loadedmetadata", oe), G.removeEventListener("timeupdate", ae), G.removeEventListener("play", ue), G.removeEventListener("pause", te), G.removeEventListener("volumechange", ne), I() } }, [r.videoType, r.videoUrl]); const P = () => { console.log("🎬 Starting progress tracking for video:", r.id, "categoryId:", t), I(), T.current = setInterval(() => { let G = 0; r.videoType === "youtube" && s.current && s.current.getCurrentTime ? G = s.current.getCurrentTime() : r.videoType === "local" && o.current && (G = o.current.currentTime), console.log("📊 Progress update:", { videoId: r.id, currentSeconds: Math.floor(G), duration: r.duration, categoryId: t }), C(r.id, Math.floor(G), r.duration, t) }, 5e3) }, I = () => { T.current && (clearInterval(T.current), T.current = void 0) }, O = () => { o.current && (f ? o.current.pause() : o.current.play()) }, V = () => { o.current && (o.current.muted = !o.current.muted) }, M = G => { o.current && (o.current.currentTime = G[0]) }, R = G => { o.current && (o.current.volume = G[0]) }, L = () => { o.current && (document.fullscreenElement ? document.exitFullscreen() : o.current.requestFullscreen()) }, F = G => { const oe = Math.floor(G / 60), ae = Math.floor(G % 60); return `${oe}:${ae.toString().padStart(2, "0")}` }, K = () => { r.videoType === "youtube" && s.current ? (s.current.seekTo(0), s.current.playVideo()) : r.videoType === "local" && o.current && (o.current.currentTime = 0, o.current.play()) }; return r.videoType === "youtube" ? d.jsx("div", { className: "aspect-video w-full bg-black rounded-lg overflow-hidden", children: d.jsx("div", { ref: a, className: "w-full h-full" }) }) : d.jsxs("div", { className: "aspect-video w-full bg-black rounded-lg overflow-hidden relative group", children: [d.jsx("video", { ref: o, src: r.videoUrl, className: "w-full h-full object-contain", onClick: O }), d.jsxs("div", { className: "absolute bottom-0 left-0 right-0 bg-gradient-to-t from-black/80 to-transparent p-4 opacity-0 group-hover:opacity-100 transition-opacity", children: [d.jsxs("div", { className: "mb-3", children: [d.jsx(Yp, { value: [y], max: S, step: 1, onValueChange: M, className: "w-full" }), d.jsxs("div", { className: "flex justify-between text-xs text-white/80 mt-1", children: [d.jsx("span", { children: F(y) }), d.jsx("span", { children: F(S) })] })] }), d.jsxs("div", { className: "flex items-center justify-between", children: [d.jsxs("div", { className: "flex items-center gap-2", children: [d.jsx(Ne, { variant: "ghost", size: "sm", onClick: O, className: "text-white hover:text-white hover:bg-white/20", children: f ? d.jsx(Nb, { className: "w-4 h-4" }) : d.jsx(Sa, { className: "w-4 h-4" }) }), d.jsx(Ne, { variant: "ghost", size: "sm", onClick: K, className: "text-white hover:text-white hover:bg-white/20", children: d.jsx(Ib, { className: "w-4 h-4" }) }), d.jsxs("div", { className: "flex items-center gap-2", children: [d.jsx(Ne, { variant: "ghost", size: "sm", onClick: V, className: "text-white hover:text-white hover:bg-white/20", children: m ? d.jsx(Qb, { className: "w-4 h-4" }) : d.jsx(Yb, { className: "w-4 h-4" }) }), d.jsx("div", { className: "w-20", children: d.jsx(Yp, { value: [m ? 0 : b], max: 1, step: .1, onValueChange: R, className: "w-full" }) })] })] }), d.jsx(Ne, { variant: "ghost", size: "sm", onClick: L, className: "text-white hover:text-white hover:bg-white/20", children: d.jsx(jb, { className: "w-4 h-4" }) })] })] }), !f && d.jsx("div", { className: "absolute inset-0 flex items-center justify-center", children: d.jsx(Ne, { variant: "ghost", size: "lg", onClick: O, className: "text-white bg-black/50 hover:bg-black/70 rounded-full w-16 h-16", children: d.jsx(Sa, { className: "w-8 h-8" }) }) })] }) }, E_ = ({ video: r }) => { const { getProgressPercentage: t, getProgress: s } = Da(), o = t(r.id, r.duration), a = s(r.id), l = a?.completed || !1, u = p => { const m = Math.floor(p / 60), v = p % 60; return `${m}분 ${v}초` }, f = p => { const m = new Date(p), y = Math.floor((new Date().getTime() - m.getTime()) / (1e3 * 60 * 60)); return y < 1 ? "방금 전" : y < 24 ? `${y}시간 전` : `${Math.floor(y / 24)}일 전` }; return d.jsxs(ht, { children: [d.jsx(qt, { children: d.jsxs("div", { className: "flex items-start justify-between gap-4", children: [d.jsx(Gt, { className: "flex-1 text-xl font-bold", children: r.title }), d.jsxs("div", { className: "flex items-center gap-2 shrink-0", children: [d.jsxs(yn, { variant: "outline", className: "flex items-center gap-1 text-lg", children: [d.jsx(yu, { className: "w-3 h-3" }), u(r.duration)] }), l && d.jsxs(yn, { variant: "default", className: "bg-green-500 flex items-center gap-1", children: [d.jsx(gg, { className: "w-3 h-3" }), "완료"] })] })] }) }), d.jsxs(xt, { className: "space-y-4", children: [d.jsx("p", { className: "leading-relaxed", children: r.description }), o > 0 && d.jsxs("div", { className: "space-y-2 p-4 bg-muted rounded-lg", children: [d.jsxs("div", { className: "flex items-center justify-between", children: [d.jsx("h4", { children: "시청 진행률" }), d.jsxs("span", { children: [Math.round(o), "%"] })] }), d.jsx(Is, { value: o, className: "h-2" }), a?.lastWatchedAt && d.jsxs("p", { className: "text-sm text-muted-foreground", children: ["마지막 시청: ", f(a.lastWatchedAt)] })] })] })] }) }; function wt({ className: r, type: t, ...s }) { return d.jsx("input", { type: t, "data-slot": "input", className: Pe("file:text-foreground placeholder:text-muted-foreground selection:bg-primary selection:text-primary-foreground dark:bg-input/30 border-input flex h-9 w-full min-w-0 rounded-md border px-3 py-1 text-base bg-input-background transition-[color,box-shadow] outline-none file:inline-flex file:h-7 file:border-0 file:bg-transparent file:text-sm file:font-medium disabled:pointer-events-none disabled:cursor-not-allowed disabled:opacity-50 md:text-sm", "focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px]", "aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive", r), ...s }) } var j_ = "Label", Bg = x.forwardRef((r, t) => d.jsx(Ee.label, { ...r, ref: t, onMouseDown: s => { s.target.closest("button, input, select, textarea") || (r.onMouseDown?.(s), !s.defaultPrevented && s.detail > 1 && s.preventDefault()) } })); Bg.displayName = j_; var C_ = Bg; function Qe({ className: r, ...t }) { return d.jsx(C_, { "data-slot": "label", className: Pe("flex items-center gap-2 text-sm leading-none font-medium select-none group-data-[disabled=true]:pointer-events-none group-data-[disabled=true]:opacity-50 peer-disabled:cursor-not-allowed peer-disabled:opacity-50", r), ...t }) } const Ma = "/assets/logo-D2uBM-SJ.png"; function N_({ onLogin: r, onBack: t }) { const [s, o] = x.useState(""), [a, l] = x.useState(""), [u, f] = x.useState(""), [p, m] = x.useState(!1), [v, y] = x.useState(null), _ = async S => { S.preventDefault(), f(""), m(!0), y("checking"); try { const E = `https://${Re}.supabase.co/functions/v1/make-server-a8898ff1/admin/login`; console.log("Attempting login to:", E); const b = await fetch(E, { method: "POST", headers: { "Content-Type": "application/json", Authorization: `Bearer ${$e}` }, body: JSON.stringify({ employeeId: s, password: a }) }); if (console.log("Response status:", b.status), y("online"), !b.ok) { const C = await b.text(); console.error("Response error:", C), b.status === 401 ? f("사번 또는 비밀번호가 올바르지 않습니다.") : b.status === 404 ? (y("offline"), f("서버를 찾을 수 없습니다. Supabase Edge Function이 배포되지 않았습니다.")) : f(`서버 오류가 발생했습니다 (상태 코드: ${b.status})`), m(!1); return } const k = await b.json(); console.log("Login response:", k), k.success ? r(k.admin) : f(k.error || "로그인에 실패했습니다.") } catch (E) { console.error("Login error:", E), y("offline"), E instanceof TypeError && E.message.includes("fetch") ? f("네트워크 오류: 서버에 연결할 수 없습니다. Supabase Edge Function이 배포되어 있는지 확인해주세요.") : f("로그인 중 오류가 발생했습니다: " + (E instanceof Error ? E.message : "알 수 없는 오류")) } finally { m(!1) } }; return d.jsx("div", { className: "min-h-screen flex items-center justify-center bg-gray-50 px-4", children: d.jsxs(ht, { className: "w-full max-w-md", children: [d.jsxs(qt, { className: "space-y-1", children: [t && d.jsxs(Ne, { variant: "ghost", size: "sm", onClick: t, className: "flex items-center gap-2 w-fit mb-2", children: [d.jsx(td, { className: "w-4 h-4" }), "뒤로"] }), d.jsx("div", { className: "flex justify-center mb-4", children: d.jsx("img", { src: Ma, alt: "서울교통공사", className: "h-12 w-auto" }) }), d.jsx(Gt, { className: "text-2xl text-center", children: "관리자 로그인" }), d.jsx(Ar, { className: "text-center", children: "서울교통공사 불안제로 관리자 페이지" })] }), d.jsx(xt, { children: d.jsxs("form", { onSubmit: _, className: "space-y-4", children: [d.jsxs("div", { className: "space-y-2", children: [d.jsx(Qe, { htmlFor: "employeeId", children: "사번" }), d.jsx(wt, { id: "employeeId", type: "text", placeholder: "사번을 입력하세요", value: s, onChange: S => o(S.target.value), required: !0 })] }), d.jsxs("div", { className: "space-y-2", children: [d.jsx(Qe, { htmlFor: "password", children: "비밀번호" }), d.jsx(wt, { id: "password", type: "password", placeholder: "비밀번호를 입력하세요", value: a, onChange: S => l(S.target.value), required: !0 })] }), v && d.jsxs("div", { className: `flex items-center space-x-2 text-sm p-3 rounded-lg ${v === "checking" ? "bg-gray-100 text-gray-700" : v === "online" ? "bg-green-50 text-green-700" : "bg-red-50 text-red-700"}`, children: [d.jsx("div", { className: `w-2 h-2 rounded-full ${v === "checking" ? "bg-gray-500 animate-pulse" : v === "online" ? "bg-green-500" : "bg-red-500"}` }), d.jsxs("span", { children: [v === "checking" && "서버 연결 확인 중...", v === "online" && "서버 연결됨", v === "offline" && "서버 연결 실패"] })] }), u && d.jsxs("div", { className: "flex items-center space-x-2 text-red-600 bg-red-50 p-3 rounded-lg", children: [d.jsx(pb, { className: "h-4 w-4 flex-shrink-0" }), d.jsx("span", { className: "text-sm", children: u })] }), d.jsx(Ne, { type: "submit", className: "w-full bg-blue-600 hover:bg-blue-700", disabled: p, children: p ? "로그인 중..." : "로그인" })] }) })] }) }) } var T_ = Gm[" useId ".trim().toString()] || (() => { }), P_ = 0; function rr(r) { const [t, s] = x.useState(T_()); return bt(() => { s(o => o ?? String(P_++)) }, [r]), r || (t ? `radix-${t}` : "") } function sr(r) { const t = x.useRef(r); return x.useEffect(() => { t.current = r }), x.useMemo(() => (...s) => t.current?.(...s), []) } var Jc = "rovingFocusGroup.onEntryFocus", R_ = { bubbles: !1, cancelable: !0 }, Ko = "RovingFocusGroup", [Su, Vg, A_] = od(Ko), [O_, Wg] = ar(Ko, [A_]), [I_, D_] = O_(Ko), Hg = x.forwardRef((r, t) => d.jsx(Su.Provider, { scope: r.__scopeRovingFocusGroup, children: d.jsx(Su.Slot, { scope: r.__scopeRovingFocusGroup, children: d.jsx($_, { ...r, ref: t }) }) })); Hg.displayName = Ko; var $_ = x.forwardRef((r, t) => { const { __scopeRovingFocusGroup: s, orientation: o, loop: a = !1, dir: l, currentTabStopId: u, defaultCurrentTabStopId: f, onCurrentTabStopIdChange: p, onEntryFocus: m, preventScrollOnEntryFocus: v = !1, ...y } = r, _ = x.useRef(null), S = ze(t, _), E = $a(l), [b, k] = Ds({ prop: u, defaultProp: f ?? null, onChange: p, caller: Ko }), [C, T] = x.useState(!1), P = sr(m), I = Vg(s), O = x.useRef(!1), [V, M] = x.useState(0); return x.useEffect(() => { const R = _.current; if (R) return R.addEventListener(Jc, P), () => R.removeEventListener(Jc, P) }, [P]), d.jsx(I_, { scope: s, orientation: o, dir: E, loop: a, currentTabStopId: b, onItemFocus: x.useCallback(R => k(R), [k]), onItemShiftTab: x.useCallback(() => T(!0), []), onFocusableItemAdd: x.useCallback(() => M(R => R + 1), []), onFocusableItemRemove: x.useCallback(() => M(R => R - 1), []), children: d.jsx(Ee.div, { tabIndex: C || V === 0 ? -1 : 0, "data-orientation": o, ...y, ref: S, style: { outline: "none", ...r.style }, onMouseDown: ke(r.onMouseDown, () => { O.current = !0 }), onFocus: ke(r.onFocus, R => { const L = !O.current; if (R.target === R.currentTarget && L && !C) { const F = new CustomEvent(Jc, R_); if (R.currentTarget.dispatchEvent(F), !F.defaultPrevented) { const K = I().filter(te => te.focusable), G = K.find(te => te.active), oe = K.find(te => te.id === b), ue = [G, oe, ...K].filter(Boolean).map(te => te.ref.current); Gg(ue, v) } } O.current = !1 }), onBlur: ke(r.onBlur, () => T(!1)) }) }) }), Kg = "RovingFocusGroupItem", qg = x.forwardRef((r, t) => { const { __scopeRovingFocusGroup: s, focusable: o = !0, active: a = !1, tabStopId: l, children: u, ...f } = r, p = rr(), m = l || p, v = D_(Kg, s), y = v.currentTabStopId === m, _ = Vg(s), { onFocusableItemAdd: S, onFocusableItemRemove: E, currentTabStopId: b } = v; return x.useEffect(() => { if (o) return S(), () => E() }, [o, S, E]), d.jsx(Su.ItemSlot, { scope: s, id: m, focusable: o, active: a, children: d.jsx(Ee.span, { tabIndex: y ? 0 : -1, "data-orientation": v.orientation, ...f, ref: t, onMouseDown: ke(r.onMouseDown, k => { o ? v.onItemFocus(m) : k.preventDefault() }), onFocus: ke(r.onFocus, () => v.onItemFocus(m)), onKeyDown: ke(r.onKeyDown, k => { if (k.key === "Tab" && k.shiftKey) { v.onItemShiftTab(); return } if (k.target !== k.currentTarget) return; const C = U_(k, v.orientation, v.dir); if (C !== void 0) { if (k.metaKey || k.ctrlKey || k.altKey || k.shiftKey) return; k.preventDefault(); let P = _().filter(I => I.focusable).map(I => I.ref.current); if (C === "last") P.reverse(); else if (C === "prev" || C === "next") { C === "prev" && P.reverse(); const I = P.indexOf(k.currentTarget); P = v.loop ? z_(P, I + 1) : P.slice(I + 1) } setTimeout(() => Gg(P)) } }), children: typeof u == "function" ? u({ isCurrentTabStop: y, hasTabStop: b != null }) : u }) }) }); qg.displayName = Kg; var L_ = { ArrowLeft: "prev", ArrowUp: "prev", ArrowRight: "next", ArrowDown: "next", PageUp: "first", Home: "first", PageDown: "last", End: "last" }; function M_(r, t) { return t !== "rtl" ? r : r === "ArrowLeft" ? "ArrowRight" : r === "ArrowRight" ? "ArrowLeft" : r } function U_(r, t, s) { const o = M_(r.key, s); if (!(t === "vertical" && ["ArrowLeft", "ArrowRight"].includes(o)) && !(t === "horizontal" && ["ArrowUp", "ArrowDown"].includes(o))) return L_[o] } function Gg(r, t = !1) { const s = document.activeElement; for (const o of r) if (o === s || (o.focus({ preventScroll: t }), document.activeElement !== s)) return } function z_(r, t) { return r.map((s, o) => r[(t + o) % r.length]) } var F_ = Hg, B_ = qg; function V_(r, t) { return x.useReducer((s, o) => t[s][o] ?? s, r) } var qo = r => { const { present: t, children: s } = r, o = W_(t), a = typeof s == "function" ? s({ present: o.isPresent }) : x.Children.only(s), l = ze(o.ref, H_(a)); return typeof s == "function" || o.isPresent ? x.cloneElement(a, { ref: l }) : null }; qo.displayName = "Presence"; function W_(r) { const [t, s] = x.useState(), o = x.useRef(null), a = x.useRef(r), l = x.useRef("none"), u = r ? "mounted" : "unmounted", [f, p] = V_(u, { mounted: { UNMOUNT: "unmounted", ANIMATION_OUT: "unmountSuspended" }, unmountSuspended: { MOUNT: "mounted", ANIMATION_END: "unmounted" }, unmounted: { MOUNT: "mounted" } }); return x.useEffect(() => { const m = ca(o.current); l.current = f === "mounted" ? m : "none" }, [f]), bt(() => { const m = o.current, v = a.current; if (v !== r) { const _ = l.current, S = ca(m); r ? p("MOUNT") : S === "none" || m?.display === "none" ? p("UNMOUNT") : p(v && _ !== S ? "ANIMATION_OUT" : "UNMOUNT"), a.current = r } }, [r, p]), bt(() => { if (t) { let m; const v = t.ownerDocument.defaultView ?? window, y = S => { const b = ca(o.current).includes(CSS.escape(S.animationName)); if (S.target === t && b && (p("ANIMATION_END"), !a.current)) { const k = t.style.animationFillMode; t.style.animationFillMode = "forwards", m = v.setTimeout(() => { t.style.animationFillMode === "forwards" && (t.style.animationFillMode = k) }) } }, _ = S => { S.target === t && (l.current = ca(o.current)) }; return t.addEventListener("animationstart", _), t.addEventListener("animationcancel", y), t.addEventListener("animationend", y), () => { v.clearTimeout(m), t.removeEventListener("animationstart", _), t.removeEventListener("animationcancel", y), t.removeEventListener("animationend", y) } } else p("ANIMATION_END") }, [t, p]), { isPresent: ["mounted", "unmountSuspended"].includes(f), ref: x.useCallback(m => { o.current = m ? getComputedStyle(m) : null, s(m) }, []) } } function ca(r) { return r?.animationName || "none" } function H_(r) { let t = Object.getOwnPropertyDescriptor(r.props, "ref")?.get, s = t && "isReactWarning" in t && t.isReactWarning; return s ? r.ref : (t = Object.getOwnPropertyDescriptor(r, "ref")?.get, s = t && "isReactWarning" in t && t.isReactWarning, s ? r.props.ref : r.props.ref || r.ref) } var Ua = "Tabs", [K_] = ar(Ua, [Wg]), Yg = Wg(), [q_, ad] = K_(Ua), Jg = x.forwardRef((r, t) => { const { __scopeTabs: s, value: o, onValueChange: a, defaultValue: l, orientation: u = "horizontal", dir: f, activationMode: p = "automatic", ...m } = r, v = $a(f), [y, _] = Ds({ prop: o, onChange: a, defaultProp: l ?? "", caller: Ua }); return d.jsx(q_, { scope: s, baseId: rr(), value: y, onValueChange: _, orientation: u, dir: v, activationMode: p, children: d.jsx(Ee.div, { dir: v, "data-orientation": u, ...m, ref: t }) }) }); Jg.displayName = Ua; var Qg = "TabsList", Xg = x.forwardRef((r, t) => { const { __scopeTabs: s, loop: o = !0, ...a } = r, l = ad(Qg, s), u = Yg(s); return d.jsx(F_, { asChild: !0, ...u, orientation: l.orientation, dir: l.dir, loop: o, children: d.jsx(Ee.div, { role: "tablist", "aria-orientation": l.orientation, ...a, ref: t }) }) }); Xg.displayName = Qg; var Zg = "TabsTrigger", ev = x.forwardRef((r, t) => { const { __scopeTabs: s, value: o, disabled: a = !1, ...l } = r, u = ad(Zg, s), f = Yg(s), p = rv(u.baseId, o), m = sv(u.baseId, o), v = o === u.value; return d.jsx(B_, { asChild: !0, ...f, focusable: !a, active: v, children: d.jsx(Ee.button, { type: "button", role: "tab", "aria-selected": v, "aria-controls": m, "data-state": v ? "active" : "inactive", "data-disabled": a ? "" : void 0, disabled: a, id: p, ...l, ref: t, onMouseDown: ke(r.onMouseDown, y => { !a && y.button === 0 && y.ctrlKey === !1 ? u.onValueChange(o) : y.preventDefault() }), onKeyDown: ke(r.onKeyDown, y => { [" ", "Enter"].includes(y.key) && u.onValueChange(o) }), onFocus: ke(r.onFocus, () => { const y = u.activationMode !== "manual"; !v && !a && y && u.onValueChange(o) }) }) }) }); ev.displayName = Zg; var tv = "TabsContent", nv = x.forwardRef((r, t) => { const { __scopeTabs: s, value: o, forceMount: a, children: l, ...u } = r, f = ad(tv, s), p = rv(f.baseId, o), m = sv(f.baseId, o), v = o === f.value, y = x.useRef(v); return x.useEffect(() => { const _ = requestAnimationFrame(() => y.current = !1); return () => cancelAnimationFrame(_) }, []), d.jsx(qo, { present: a || v, children: ({ present: _ }) => d.jsx(Ee.div, { "data-state": v ? "active" : "inactive", "data-orientation": f.orientation, role: "tabpanel", "aria-labelledby": p, hidden: !_, id: m, tabIndex: 0, ...u, ref: t, style: { ...r.style, animationDuration: y.current ? "0s" : void 0 }, children: _ && l }) }) }); nv.displayName = tv; function rv(r, t) { return `${r}-trigger-${t}` } function sv(r, t) { return `${r}-content-${t}` } var G_ = Jg, Y_ = Xg, J_ = ev, Q_ = nv; function ov({ className: r, ...t }) { return d.jsx(G_, { "data-slot": "tabs", className: Pe("flex flex-col gap-2", r), ...t }) } function iv({ className: r, ...t }) { return d.jsx(Y_, { "data-slot": "tabs-list", className: Pe("bg-muted text-muted-foreground inline-flex h-9 w-fit items-center justify-center rounded-xl p-[3px] flex", r), ...t }) } function Ns({ className: r, ...t }) { return d.jsx(J_, { "data-slot": "tabs-trigger", className: Pe("data-[state=active]:bg-card dark:data-[state=active]:text-foreground focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:outline-ring dark:data-[state=active]:border-input dark:data-[state=active]:bg-input/30 text-foreground dark:text-muted-foreground inline-flex h-[calc(100%-1px)] flex-1 items-center justify-center gap-1.5 rounded-xl border border-transparent px-2 py-1 text-sm font-medium whitespace-nowrap transition-[color,box-shadow] focus-visible:ring-[3px] focus-visible:outline-1 disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4", r), ...t }) } function Ts({ className: r, ...t }) { return d.jsx(Q_, { "data-slot": "tabs-content", className: Pe("flex-1 outline-none", r), ...t }) } function Mo({ className: r, ...t }) { return d.jsx("div", { "data-slot": "table-container", className: "relative w-full overflow-x-auto", children: d.jsx("table", { "data-slot": "table", className: Pe("w-full caption-bottom text-sm", r), ...t }) }) } function Uo({ className: r, ...t }) { return d.jsx("thead", { "data-slot": "table-header", className: Pe("[&_tr]:border-b", r), ...t }) } function zo({ className: r, ...t }) { return d.jsx("tbody", { "data-slot": "table-body", className: Pe("[&_tr:last-child]:border-0", r), ...t }) } function Rt({ className: r, ...t }) { return d.jsx("tr", { "data-slot": "table-row", className: Pe("hover:bg-muted/50 data-[state=selected]:bg-muted border-b transition-colors", r), ...t }) } function Ue({ className: r, ...t }) { return d.jsx("th", { "data-slot": "table-head", className: Pe("text-foreground h-10 px-2 text-left align-middle font-medium whitespace-nowrap [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px]", r), ...t }) } function Ie({ className: r, ...t }) { return d.jsx("td", { "data-slot": "table-cell", className: Pe("p-2 align-middle whitespace-nowrap [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px]", r), ...t }) } function X_() { const [r, t] = x.useState([]), [s, o] = x.useState({}), [a, l] = x.useState({}), [u, f] = x.useState({}), [p, m] = x.useState(""), [v, y] = x.useState(!0), [_, S] = x.useState(null), E = x.useMemo(() => { const R = {}; return r.forEach(L => { R[L.id] || (R[L.id] = {}), L.userName && !R[L.id].name && (R[L.id].name = L.userName), L.employeeId && !R[L.id].employeeId && (R[L.id].employeeId = L.employeeId) }), R }, [r]); x.useEffect(() => { b() }, []); const b = async () => { console.log("📊 UserProgressManagement: Starting data load..."); try { y(!0); const R = Date.now(), F = await (await fetch(`https://${Re}.supabase.co/functions/v1/make-server-a8898ff1/categories?v=${R}`, { cache: "no-store", headers: { Authorization: `Bearer ${$e}`, "Cache-Control": "no-cache" } })).json(); console.log("📋 Categories loaded:", F); const K = {}, G = {}; for (const $ of F.categories || []) { K[$.id] = $; const X = await (await fetch(`https://${Re}.supabase.co/functions/v1/make-server-a8898ff1/videos/${$.id}?v=${R}`, { cache: "no-store", headers: { Authorization: `Bearer ${$e}`, "Cache-Control": "no-cache" } })).json(); console.log(`🎥 Videos for ${$.id}:`, X); for (const j of X.videos || []) G[j.id] = j } l(K), o(G); const ae = await (await fetch(`https://${Re}.supabase.co/functions/v1/make-server-a8898ff1/users?v=${R}`, { cache: "no-store", headers: { Authorization: `Bearer ${$e}`, "Cache-Control": "no-cache" } })).json(); console.log("👥 Users data loaded:", ae); const ue = {}; for (const $ of ae.users || []) ue[$.id] = $; f(ue); const ne = await (await fetch(`https://${Re}.supabase.co/functions/v1/make-server-a8898ff1/admin/progress?v=${R}`, { cache: "no-store", headers: { Authorization: `Bearer ${$e}`, "Cache-Control": "no-cache" } })).json(); console.log("📊 Progress data loaded:", ne), console.log("📊 Number of progress records:", ne.progress?.length || 0), t(ne.progress || []) } catch (R) { console.error("❌ Error loading data:", R); const L = { fire: { id: "fire", title: "화재발생 시 대응요령" }, safety: { id: "safety", title: "지하철 안전운행" } }, F = { fire_1: { id: "fire_1", title: "지하철 화재 발생 시 초기 대응", duration: "5:30" }, safety_1: { id: "safety_1", title: "지하철 안전운행 기본 수칙", duration: "8:20" } }, K = { demo_user_1: { id: "demo_user_1", name: "김철수", employeeId: "EMP001", department: "운행팀" }, demo_user_2: { id: "demo_user_2", name: "이영희", employeeId: "EMP002", department: "안전팀" } }, G = [{ id: "demo_user_1", videoId: "fire_1", categoryId: "fire", progress: 75, watchTime: 240, lastWatched: new Date().toISOString() }, { id: "demo_user_2", videoId: "safety_1", categoryId: "safety", progress: 90, watchTime: 450, lastWatched: new Date().toISOString() }]; l(L), o(F), f(K), t(G), console.log("⚠️ Using fallback mock data") } finally { y(!1), console.log("✅ UserProgressManagement: Data loading completed") } }, k = () => { b() }, C = () => { const R = {}; return Object.keys(u).forEach(L => { const F = u[L]; R[L] = { totalVideos: 0, completedVideos: 0, avgProgress: 0, lastActivity: F?.lastLoginAt || F?.updatedAt || F?.createdAt } }), r.forEach(L => { R[L.id] || (R[L.id] = { totalVideos: 0, completedVideos: 0, avgProgress: 0, lastActivity: L.lastWatched }); const F = R[L.id]; F.totalVideos += 1, L.progress >= 80 && (F.completedVideos += 1); const K = F.lastActivity; (!K || new Date(L.lastWatched) > new Date(K)) && (F.lastActivity = L.lastWatched) }), Object.keys(R).forEach(L => { const F = r.filter(K => K.id === L); if (F.length > 0) { const K = F.reduce((G, oe) => G + oe.progress, 0); R[L].avgProgress = K / F.length } }), R }, T = R => r.filter(L => L.id === R), P = R => { const L = Math.floor(R / 3600), F = Math.floor(R % 3600 / 60), K = R % 60; return L > 0 ? `${L}:${F.toString().padStart(2, "0")}:${K.toString().padStart(2, "0")}` : `${F}:${K.toString().padStart(2, "0")}` }, I = R => { if (!R) return "-"; const L = new Date(R); return Number.isNaN(L.getTime()) ? "-" : L.toLocaleString("ko-KR") }, O = R => { const L = u[R]; if (L) { const G = [L.name, L.employeeId ? `(${L.employeeId})` : null].filter(Boolean).join(" ").trim(); if (G) return G } const F = E[R]; if (F) { if (F.name && F.employeeId) return `${F.name} (${F.employeeId})`; if (F.name) return F.name; if (F.employeeId) return F.employeeId } return R }, V = C(), M = Object.keys(V).filter(R => { const L = u[R], F = E[R], K = p.toLowerCase(); return R.toLowerCase().includes(K) || L?.name && L.name.toLowerCase().includes(K) || L?.employeeId && L.employeeId.toLowerCase().includes(K) || F?.name && F.name.toLowerCase().includes(K) || F?.employeeId && F.employeeId.toLowerCase().includes(K) }); return v ? d.jsx(ht, { children: d.jsx(xt, { className: "flex items-center justify-center py-12", children: d.jsxs("div", { className: "text-center", children: [d.jsx("div", { className: "animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600 mx-auto mb-4" }), d.jsx("p", { children: "데이터를 불러오는 중..." })] }) }) }) : d.jsxs("div", { className: "space-y-6", children: [d.jsxs(ht, { children: [d.jsxs(qt, { className: "flex flex-col sm:flex-row sm:items-center sm:justify-between gap-2", children: [d.jsxs("div", { children: [d.jsx(Gt, { children: "사용자 시청 현황" }), d.jsx(Ar, { children: "모든 사용자의 영상 시청 진행률과 활동 현황을 관리합니다." })] }), d.jsx("div", { className: "mt-2 sm:mt-0", children: d.jsxs(Ne, { variant: "outline", size: "sm", onClick: k, disabled: v, className: "flex items-center gap-2", children: [d.jsx(Ab, { className: "h-4 w-4" }), v ? "새로고침 중..." : "새로고침"] }) })] }), d.jsxs(xt, { children: [d.jsxs("div", { className: "flex items-center space-x-2 mb-6", children: [d.jsx($b, { className: "h-4 w-4 text-gray-400" }), d.jsx(wt, { placeholder: "사용자 이름 또는 사번으로 검색...", value: p, onChange: R => m(R.target.value), className: "max-w-sm" })] }), d.jsx("div", { className: "rounded-md border", children: d.jsxs(Mo, { children: [d.jsx(Uo, { children: d.jsxs(Rt, { children: [d.jsx(Ue, { children: "사용자" }), d.jsx(Ue, { children: "시청 영상 수" }), d.jsx(Ue, { children: "완료 영상 수" }), d.jsx(Ue, { children: "평균 진행률" }), d.jsx(Ue, { children: "마지막 활동" }), d.jsx(Ue, { children: "상세 보기" })] }) }), d.jsx(zo, { children: M.length === 0 ? d.jsx(Rt, { children: d.jsx(Ie, { colSpan: 6, className: "text-center py-8 text-gray-500", children: p ? "검색 결과가 없습니다." : "사용자 데이터가 없습니다." }) }) : M.map(R => { const L = V[R]; return d.jsxs(Rt, { children: [d.jsx(Ie, { className: "font-medium", children: O(R) }), d.jsx(Ie, { children: d.jsxs("div", { className: "flex items-center", children: [d.jsx(vg, { className: "h-4 w-4 mr-1 text-blue-600" }), L.totalVideos] }) }), d.jsx(Ie, { children: d.jsx(yn, { variant: L.completedVideos > 0 ? "default" : "secondary", className: L.completedVideos > 0 ? "bg-green-600" : "", children: L.completedVideos }) }), d.jsx(Ie, { children: d.jsxs("div", { className: "space-y-1", children: [d.jsx(Is, { value: L.avgProgress, className: "w-20" }), d.jsxs("span", { className: "text-xs text-gray-600", children: [Math.round(L.avgProgress), "%"] })] }) }), d.jsx(Ie, { children: d.jsxs("div", { className: "flex items-center text-sm text-gray-600", children: [d.jsx(yu, { className: "h-3 w-3 mr-1" }), I(L.lastActivity)] }) }), d.jsx(Ie, { children: d.jsxs(Ne, { variant: "outline", size: "sm", onClick: () => S(_ === R ? null : R), children: [d.jsx(xb, { className: "h-4 w-4 mr-1" }), _ === R ? "닫기" : "보기"] }) })] }, R) }) })] }) })] })] }), _ && d.jsxs(ht, { children: [d.jsxs(qt, { children: [d.jsxs(Gt, { children: ["사용자 상세 시청 기록: ", O(_)] }), d.jsx(Ar, { children: "개별 영상별 시청 진행률과 시간을 확인할 수 있습니다." })] }), d.jsx(xt, { children: d.jsx("div", { className: "rounded-md border", children: d.jsxs(Mo, { children: [d.jsx(Uo, { children: d.jsxs(Rt, { children: [d.jsx(Ue, { children: "카테고리" }), d.jsx(Ue, { children: "영상 제목" }), d.jsx(Ue, { children: "진행률" }), d.jsx(Ue, { children: "시청 시간" }), d.jsx(Ue, { children: "마지막 시청" })] }) }), d.jsx(zo, { children: T(_).map((R, L) => { const F = s[R.videoId], K = a[R.categoryId]; return d.jsxs(Rt, { children: [d.jsx(Ie, { children: d.jsx(yn, { variant: "outline", children: K?.title || R.categoryId }) }), d.jsx(Ie, { className: "font-medium", children: F?.title || R.videoId }), d.jsx(Ie, { children: d.jsxs("div", { className: "space-y-1", children: [d.jsx(Is, { value: R.progress, className: "w-24" }), d.jsxs("span", { className: "text-xs text-gray-600", children: [Math.round(R.progress), "%"] })] }) }), d.jsx(Ie, { children: d.jsxs("div", { className: "flex items-center text-sm", children: [d.jsx(yu, { className: "h-3 w-3 mr-1 text-gray-400" }), P(R.watchTime)] }) }), d.jsx(Ie, { className: "text-sm text-gray-600", children: I(R.lastWatched) })] }, L) }) })] }) }) })] })] }) } function av({ className: r, ...t }) { return d.jsx("textarea", { "data-slot": "textarea", className: Pe("resize-none border-input placeholder:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 flex field-sizing-content min-h-16 w-full rounded-md border bg-input-background px-3 py-2 text-base transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 md:text-sm", r), ...t }) } function Z_(r, t = globalThis?.document) { const s = sr(r); x.useEffect(() => { const o = a => { a.key === "Escape" && s(a) }; return t.addEventListener("keydown", o, { capture: !0 }), () => t.removeEventListener("keydown", o, { capture: !0 }) }, [s, t]) } var eS = "DismissableLayer", ku = "dismissableLayer.update", tS = "dismissableLayer.pointerDownOutside", nS = "dismissableLayer.focusOutside", Jp, lv = x.createContext({ layers: new Set, layersWithOutsidePointerEventsDisabled: new Set, branches: new Set }), ld = x.forwardRef((r, t) => { const { disableOutsidePointerEvents: s = !1, onEscapeKeyDown: o, onPointerDownOutside: a, onFocusOutside: l, onInteractOutside: u, onDismiss: f, ...p } = r, m = x.useContext(lv), [v, y] = x.useState(null), _ = v?.ownerDocument ?? globalThis?.document, [, S] = x.useState({}), E = ze(t, M => y(M)), b = Array.from(m.layers), [k] = [...m.layersWithOutsidePointerEventsDisabled].slice(-1), C = b.indexOf(k), T = v ? b.indexOf(v) : -1, P = m.layersWithOutsidePointerEventsDisabled.size > 0, I = T >= C, O = oS(M => { const R = M.target, L = [...m.branches].some(F => F.contains(R)); !I || L || (a?.(M), u?.(M), M.defaultPrevented || f?.()) }, _), V = iS(M => { const R = M.target;[...m.branches].some(F => F.contains(R)) || (l?.(M), u?.(M), M.defaultPrevented || f?.()) }, _); return Z_(M => { T === m.layers.size - 1 && (o?.(M), !M.defaultPrevented && f && (M.preventDefault(), f())) }, _), x.useEffect(() => { if (v) return s && (m.layersWithOutsidePointerEventsDisabled.size === 0 && (Jp = _.body.style.pointerEvents, _.body.style.pointerEvents = "none"), m.layersWithOutsidePointerEventsDisabled.add(v)), m.layers.add(v), Qp(), () => { s && m.layersWithOutsidePointerEventsDisabled.size === 1 && (_.body.style.pointerEvents = Jp) } }, [v, _, s, m]), x.useEffect(() => () => { v && (m.layers.delete(v), m.layersWithOutsidePointerEventsDisabled.delete(v), Qp()) }, [v, m]), x.useEffect(() => { const M = () => S({}); return document.addEventListener(ku, M), () => document.removeEventListener(ku, M) }, []), d.jsx(Ee.div, { ...p, ref: E, style: { pointerEvents: P ? I ? "auto" : "none" : void 0, ...r.style }, onFocusCapture: ke(r.onFocusCapture, V.onFocusCapture), onBlurCapture: ke(r.onBlurCapture, V.onBlurCapture), onPointerDownCapture: ke(r.onPointerDownCapture, O.onPointerDownCapture) }) }); ld.displayName = eS; var rS = "DismissableLayerBranch", sS = x.forwardRef((r, t) => { const s = x.useContext(lv), o = x.useRef(null), a = ze(t, o); return x.useEffect(() => { const l = o.current; if (l) return s.branches.add(l), () => { s.branches.delete(l) } }, [s.branches]), d.jsx(Ee.div, { ...r, ref: a }) }); sS.displayName = rS; function oS(r, t = globalThis?.document) { const s = sr(r), o = x.useRef(!1), a = x.useRef(() => { }); return x.useEffect(() => { const l = f => { if (f.target && !o.current) { let p = function () { cv(tS, s, m, { discrete: !0 }) }; const m = { originalEvent: f }; f.pointerType === "touch" ? (t.removeEventListener("click", a.current), a.current = p, t.addEventListener("click", a.current, { once: !0 })) : p() } else t.removeEventListener("click", a.current); o.current = !1 }, u = window.setTimeout(() => { t.addEventListener("pointerdown", l) }, 0); return () => { window.clearTimeout(u), t.removeEventListener("pointerdown", l), t.removeEventListener("click", a.current) } }, [t, s]), { onPointerDownCapture: () => o.current = !0 } } function iS(r, t = globalThis?.document) { const s = sr(r), o = x.useRef(!1); return x.useEffect(() => { const a = l => { l.target && !o.current && cv(nS, s, { originalEvent: l }, { discrete: !1 }) }; return t.addEventListener("focusin", a), () => t.removeEventListener("focusin", a) }, [t, s]), { onFocusCapture: () => o.current = !0, onBlurCapture: () => o.current = !1 } } function Qp() { const r = new CustomEvent(ku); document.dispatchEvent(r) } function cv(r, t, s, { discrete: o }) { const a = s.originalEvent.target, l = new CustomEvent(r, { bubbles: !1, cancelable: !0, detail: s }); t && a.addEventListener(r, t, { once: !0 }), o ? qx(a, l) : a.dispatchEvent(l) } var Qc = 0; function uv() { x.useEffect(() => { const r = document.querySelectorAll("[data-radix-focus-guard]"); return document.body.insertAdjacentElement("afterbegin", r[0] ?? Xp()), document.body.insertAdjacentElement("beforeend", r[1] ?? Xp()), Qc++, () => { Qc === 1 && document.querySelectorAll("[data-radix-focus-guard]").forEach(t => t.remove()), Qc-- } }, []) } function Xp() { const r = document.createElement("span"); return r.setAttribute("data-radix-focus-guard", ""), r.tabIndex = 0, r.style.outline = "none", r.style.opacity = "0", r.style.position = "fixed", r.style.pointerEvents = "none", r } var Xc = "focusScope.autoFocusOnMount", Zc = "focusScope.autoFocusOnUnmount", Zp = { bubbles: !1, cancelable: !0 }, aS = "FocusScope", cd = x.forwardRef((r, t) => { const { loop: s = !1, trapped: o = !1, onMountAutoFocus: a, onUnmountAutoFocus: l, ...u } = r, [f, p] = x.useState(null), m = sr(a), v = sr(l), y = x.useRef(null), _ = ze(t, b => p(b)), S = x.useRef({ paused: !1, pause() { this.paused = !0 }, resume() { this.paused = !1 } }).current; x.useEffect(() => { if (o) { let b = function (P) { if (S.paused || !f) return; const I = P.target; f.contains(I) ? y.current = I : er(y.current, { select: !0 }) }, k = function (P) { if (S.paused || !f) return; const I = P.relatedTarget; I !== null && (f.contains(I) || er(y.current, { select: !0 })) }, C = function (P) { if (document.activeElement === document.body) for (const O of P) O.removedNodes.length > 0 && er(f) }; document.addEventListener("focusin", b), document.addEventListener("focusout", k); const T = new MutationObserver(C); return f && T.observe(f, { childList: !0, subtree: !0 }), () => { document.removeEventListener("focusin", b), document.removeEventListener("focusout", k), T.disconnect() } } }, [o, f, S.paused]), x.useEffect(() => { if (f) { tm.add(S); const b = document.activeElement; if (!f.contains(b)) { const C = new CustomEvent(Xc, Zp); f.addEventListener(Xc, m), f.dispatchEvent(C), C.defaultPrevented || (lS(hS(dv(f)), { select: !0 }), document.activeElement === b && er(f)) } return () => { f.removeEventListener(Xc, m), setTimeout(() => { const C = new CustomEvent(Zc, Zp); f.addEventListener(Zc, v), f.dispatchEvent(C), C.defaultPrevented || er(b ?? document.body, { select: !0 }), f.removeEventListener(Zc, v), tm.remove(S) }, 0) } } }, [f, m, v, S]); const E = x.useCallback(b => { if (!s && !o || S.paused) return; const k = b.key === "Tab" && !b.altKey && !b.ctrlKey && !b.metaKey, C = document.activeElement; if (k && C) { const T = b.currentTarget, [P, I] = cS(T); P && I ? !b.shiftKey && C === I ? (b.preventDefault(), s && er(P, { select: !0 })) : b.shiftKey && C === P && (b.preventDefault(), s && er(I, { select: !0 })) : C === T && b.preventDefault() } }, [s, o, S.paused]); return d.jsx(Ee.div, { tabIndex: -1, ...u, ref: _, onKeyDown: E }) }); cd.displayName = aS; function lS(r, { select: t = !1 } = {}) { const s = document.activeElement; for (const o of r) if (er(o, { select: t }), document.activeElement !== s) return } function cS(r) { const t = dv(r), s = em(t, r), o = em(t.reverse(), r); return [s, o] } function dv(r) { const t = [], s = document.createTreeWalker(r, NodeFilter.SHOW_ELEMENT, { acceptNode: o => { const a = o.tagName === "INPUT" && o.type === "hidden"; return o.disabled || o.hidden || a ? NodeFilter.FILTER_SKIP : o.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP } }); for (; s.nextNode();)t.push(s.currentNode); return t } function em(r, t) { for (const s of r) if (!uS(s, { upTo: t })) return s } function uS(r, { upTo: t }) { if (getComputedStyle(r).visibility === "hidden") return !0; for (; r;) { if (t !== void 0 && r === t) return !1; if (getComputedStyle(r).display === "none") return !0; r = r.parentElement } return !1 } function dS(r) { return r instanceof HTMLInputElement && "select" in r } function er(r, { select: t = !1 } = {}) { if (r && r.focus) { const s = document.activeElement; r.focus({ preventScroll: !0 }), r !== s && dS(r) && t && r.select() } } var tm = fS(); function fS() { let r = []; return { add(t) { const s = r[0]; t !== s && s?.pause(), r = nm(r, t), r.unshift(t) }, remove(t) { r = nm(r, t), r[0]?.resume() } } } function nm(r, t) { const s = [...r], o = s.indexOf(t); return o !== -1 && s.splice(o, 1), s } function hS(r) { return r.filter(t => t.tagName !== "A") } const pS = ["top", "right", "bottom", "left"], or = Math.min, Mt = Math.max, Ea = Math.round, ua = Math.floor, vn = r => ({ x: r, y: r }), mS = { left: "right", right: "left", bottom: "top", top: "bottom" }, gS = { start: "end", end: "start" }; function Eu(r, t, s) { return Mt(r, or(t, s)) } function Rn(r, t) { return typeof r == "function" ? r(t) : r } function An(r) { return r.split("-")[0] } function Fs(r) { return r.split("-")[1] } function ud(r) { return r === "x" ? "y" : "x" } function dd(r) { return r === "y" ? "height" : "width" } const vS = new Set(["top", "bottom"]); function gn(r) { return vS.has(An(r)) ? "y" : "x" } function fd(r) { return ud(gn(r)) } function yS(r, t, s) { s === void 0 && (s = !1); const o = Fs(r), a = fd(r), l = dd(a); let u = a === "x" ? o === (s ? "end" : "start") ? "right" : "left" : o === "start" ? "bottom" : "top"; return t.reference[l] > t.floating[l] && (u = ja(u)), [u, ja(u)] } function wS(r) { const t = ja(r); return [ju(r), t, ju(t)] } function ju(r) { return r.replace(/start|end/g, t => gS[t]) } const rm = ["left", "right"], sm = ["right", "left"], xS = ["top", "bottom"], bS = ["bottom", "top"]; function _S(r, t, s) { switch (r) { case "top": case "bottom": return s ? t ? sm : rm : t ? rm : sm; case "left": case "right": return t ? xS : bS; default: return [] } } function SS(r, t, s, o) { const a = Fs(r); let l = _S(An(r), s === "start", o); return a && (l = l.map(u => u + "-" + a), t && (l = l.concat(l.map(ju)))), l } function ja(r) { return r.replace(/left|right|bottom|top/g, t => mS[t]) } function kS(r) { return { top: 0, right: 0, bottom: 0, left: 0, ...r } } function fv(r) { return typeof r != "number" ? kS(r) : { top: r, right: r, bottom: r, left: r } } function Ca(r) { const { x: t, y: s, width: o, height: a } = r; return { width: o, height: a, top: s, left: t, right: t + o, bottom: s + a, x: t, y: s } } function om(r, t, s) { let { reference: o, floating: a } = r; const l = gn(t), u = fd(t), f = dd(u), p = An(t), m = l === "y", v = o.x + o.width / 2 - a.width / 2, y = o.y + o.height / 2 - a.height / 2, _ = o[f] / 2 - a[f] / 2; let S; switch (p) { case "top": S = { x: v, y: o.y - a.height }; break; case "bottom": S = { x: v, y: o.y + o.height }; break; case "right": S = { x: o.x + o.width, y }; break; case "left": S = { x: o.x - a.width, y }; break; default: S = { x: o.x, y: o.y } }switch (Fs(t)) { case "start": S[u] -= _ * (s && m ? -1 : 1); break; case "end": S[u] += _ * (s && m ? -1 : 1); break }return S } const ES = async (r, t, s) => { const { placement: o = "bottom", strategy: a = "absolute", middleware: l = [], platform: u } = s, f = l.filter(Boolean), p = await (u.isRTL == null ? void 0 : u.isRTL(t)); let m = await u.getElementRects({ reference: r, floating: t, strategy: a }), { x: v, y } = om(m, o, p), _ = o, S = {}, E = 0; for (let b = 0; b < f.length; b++) { const { name: k, fn: C } = f[b], { x: T, y: P, data: I, reset: O } = await C({ x: v, y, initialPlacement: o, placement: _, strategy: a, middlewareData: S, rects: m, platform: u, elements: { reference: r, floating: t } }); v = T ?? v, y = P ?? y, S = { ...S, [k]: { ...S[k], ...I } }, O && E <= 50 && (E++, typeof O == "object" && (O.placement && (_ = O.placement), O.rects && (m = O.rects === !0 ? await u.getElementRects({ reference: r, floating: t, strategy: a }) : O.rects), { x: v, y } = om(m, _, p)), b = -1) } return { x: v, y, placement: _, strategy: a, middlewareData: S } }; async function Fo(r, t) { var s; t === void 0 && (t = {}); const { x: o, y: a, platform: l, rects: u, elements: f, strategy: p } = r, { boundary: m = "clippingAncestors", rootBoundary: v = "viewport", elementContext: y = "floating", altBoundary: _ = !1, padding: S = 0 } = Rn(t, r), E = fv(S), k = f[_ ? y === "floating" ? "reference" : "floating" : y], C = Ca(await l.getClippingRect({ element: (s = await (l.isElement == null ? void 0 : l.isElement(k))) == null || s ? k : k.contextElement || await (l.getDocumentElement == null ? void 0 : l.getDocumentElement(f.floating)), boundary: m, rootBoundary: v, strategy: p })), T = y === "floating" ? { x: o, y: a, width: u.floating.width, height: u.floating.height } : u.reference, P = await (l.getOffsetParent == null ? void 0 : l.getOffsetParent(f.floating)), I = await (l.isElement == null ? void 0 : l.isElement(P)) ? await (l.getScale == null ? void 0 : l.getScale(P)) || { x: 1, y: 1 } : { x: 1, y: 1 }, O = Ca(l.convertOffsetParentRelativeRectToViewportRelativeRect ? await l.convertOffsetParentRelativeRectToViewportRelativeRect({ elements: f, rect: T, offsetParent: P, strategy: p }) : T); return { top: (C.top - O.top + E.top) / I.y, bottom: (O.bottom - C.bottom + E.bottom) / I.y, left: (C.left - O.left + E.left) / I.x, right: (O.right - C.right + E.right) / I.x } } const jS = r => ({ name: "arrow", options: r, async fn(t) { const { x: s, y: o, placement: a, rects: l, platform: u, elements: f, middlewareData: p } = t, { element: m, padding: v = 0 } = Rn(r, t) || {}; if (m == null) return {}; const y = fv(v), _ = { x: s, y: o }, S = fd(a), E = dd(S), b = await u.getDimensions(m), k = S === "y", C = k ? "top" : "left", T = k ? "bottom" : "right", P = k ? "clientHeight" : "clientWidth", I = l.reference[E] + l.reference[S] - _[S] - l.floating[E], O = _[S] - l.reference[S], V = await (u.getOffsetParent == null ? void 0 : u.getOffsetParent(m)); let M = V ? V[P] : 0; (!M || !await (u.isElement == null ? void 0 : u.isElement(V))) && (M = f.floating[P] || l.floating[E]); const R = I / 2 - O / 2, L = M / 2 - b[E] / 2 - 1, F = or(y[C], L), K = or(y[T], L), G = F, oe = M - b[E] - K, ae = M / 2 - b[E] / 2 + R, ue = Eu(G, ae, oe), te = !p.arrow && Fs(a) != null && ae !== ue && l.reference[E] / 2 - (ae < G ? F : K) - b[E] / 2 < 0, ne = te ? ae < G ? ae - G : ae - oe : 0; return { [S]: _[S] + ne, data: { [S]: ue, centerOffset: ae - ue - ne, ...te && { alignmentOffset: ne } }, reset: te } } }), CS = function (r) { return r === void 0 && (r = {}), { name: "flip", options: r, async fn(t) { var s, o; const { placement: a, middlewareData: l, rects: u, initialPlacement: f, platform: p, elements: m } = t, { mainAxis: v = !0, crossAxis: y = !0, fallbackPlacements: _, fallbackStrategy: S = "bestFit", fallbackAxisSideDirection: E = "none", flipAlignment: b = !0, ...k } = Rn(r, t); if ((s = l.arrow) != null && s.alignmentOffset) return {}; const C = An(a), T = gn(f), P = An(f) === f, I = await (p.isRTL == null ? void 0 : p.isRTL(m.floating)), O = _ || (P || !b ? [ja(f)] : wS(f)), V = E !== "none"; !_ && V && O.push(...SS(f, b, E, I)); const M = [f, ...O], R = await Fo(t, k), L = []; let F = ((o = l.flip) == null ? void 0 : o.overflows) || []; if (v && L.push(R[C]), y) { const ae = yS(a, u, I); L.push(R[ae[0]], R[ae[1]]) } if (F = [...F, { placement: a, overflows: L }], !L.every(ae => ae <= 0)) { var K, G; const ae = (((K = l.flip) == null ? void 0 : K.index) || 0) + 1, ue = M[ae]; if (ue && (!(y === "alignment" ? T !== gn(ue) : !1) || F.every($ => gn($.placement) === T ? $.overflows[0] > 0 : !0))) return { data: { index: ae, overflows: F }, reset: { placement: ue } }; let te = (G = F.filter(ne => ne.overflows[0] <= 0).sort((ne, $) => ne.overflows[1] - $.overflows[1])[0]) == null ? void 0 : G.placement; if (!te) switch (S) { case "bestFit": { var oe; const ne = (oe = F.filter($ => { if (V) { const ee = gn($.placement); return ee === T || ee === "y" } return !0 }).map($ => [$.placement, $.overflows.filter(ee => ee > 0).reduce((ee, X) => ee + X, 0)]).sort(($, ee) => $[1] - ee[1])[0]) == null ? void 0 : oe[0]; ne && (te = ne); break } case "initialPlacement": te = f; break }if (a !== te) return { reset: { placement: te } } } return {} } } }; function im(r, t) { return { top: r.top - t.height, right: r.right - t.width, bottom: r.bottom - t.height, left: r.left - t.width } } function am(r) { return pS.some(t => r[t] >= 0) } const NS = function (r) { return r === void 0 && (r = {}), { name: "hide", options: r, async fn(t) { const { rects: s } = t, { strategy: o = "referenceHidden", ...a } = Rn(r, t); switch (o) { case "referenceHidden": { const l = await Fo(t, { ...a, elementContext: "reference" }), u = im(l, s.reference); return { data: { referenceHiddenOffsets: u, referenceHidden: am(u) } } } case "escaped": { const l = await Fo(t, { ...a, altBoundary: !0 }), u = im(l, s.floating); return { data: { escapedOffsets: u, escaped: am(u) } } } default: return {} } } } }, hv = new Set(["left", "top"]); async function TS(r, t) { const { placement: s, platform: o, elements: a } = r, l = await (o.isRTL == null ? void 0 : o.isRTL(a.floating)), u = An(s), f = Fs(s), p = gn(s) === "y", m = hv.has(u) ? -1 : 1, v = l && p ? -1 : 1, y = Rn(t, r); let { mainAxis: _, crossAxis: S, alignmentAxis: E } = typeof y == "number" ? { mainAxis: y, crossAxis: 0, alignmentAxis: null } : { mainAxis: y.mainAxis || 0, crossAxis: y.crossAxis || 0, alignmentAxis: y.alignmentAxis }; return f && typeof E == "number" && (S = f === "end" ? E * -1 : E), p ? { x: S * v, y: _ * m } : { x: _ * m, y: S * v } } const PS = function (r) { return r === void 0 && (r = 0), { name: "offset", options: r, async fn(t) { var s, o; const { x: a, y: l, placement: u, middlewareData: f } = t, p = await TS(t, r); return u === ((s = f.offset) == null ? void 0 : s.placement) && (o = f.arrow) != null && o.alignmentOffset ? {} : { x: a + p.x, y: l + p.y, data: { ...p, placement: u } } } } }, RS = function (r) { return r === void 0 && (r = {}), { name: "shift", options: r, async fn(t) { const { x: s, y: o, placement: a } = t, { mainAxis: l = !0, crossAxis: u = !1, limiter: f = { fn: k => { let { x: C, y: T } = k; return { x: C, y: T } } }, ...p } = Rn(r, t), m = { x: s, y: o }, v = await Fo(t, p), y = gn(An(a)), _ = ud(y); let S = m[_], E = m[y]; if (l) { const k = _ === "y" ? "top" : "left", C = _ === "y" ? "bottom" : "right", T = S + v[k], P = S - v[C]; S = Eu(T, S, P) } if (u) { const k = y === "y" ? "top" : "left", C = y === "y" ? "bottom" : "right", T = E + v[k], P = E - v[C]; E = Eu(T, E, P) } const b = f.fn({ ...t, [_]: S, [y]: E }); return { ...b, data: { x: b.x - s, y: b.y - o, enabled: { [_]: l, [y]: u } } } } } }, AS = function (r) { return r === void 0 && (r = {}), { options: r, fn(t) { const { x: s, y: o, placement: a, rects: l, middlewareData: u } = t, { offset: f = 0, mainAxis: p = !0, crossAxis: m = !0 } = Rn(r, t), v = { x: s, y: o }, y = gn(a), _ = ud(y); let S = v[_], E = v[y]; const b = Rn(f, t), k = typeof b == "number" ? { mainAxis: b, crossAxis: 0 } : { mainAxis: 0, crossAxis: 0, ...b }; if (p) { const P = _ === "y" ? "height" : "width", I = l.reference[_] - l.floating[P] + k.mainAxis, O = l.reference[_] + l.reference[P] - k.mainAxis; S < I ? S = I : S > O && (S = O) } if (m) { var C, T; const P = _ === "y" ? "width" : "height", I = hv.has(An(a)), O = l.reference[y] - l.floating[P] + (I && ((C = u.offset) == null ? void 0 : C[y]) || 0) + (I ? 0 : k.crossAxis), V = l.reference[y] + l.reference[P] + (I ? 0 : ((T = u.offset) == null ? void 0 : T[y]) || 0) - (I ? k.crossAxis : 0); E < O ? E = O : E > V && (E = V) } return { [_]: S, [y]: E } } } }, OS = function (r) { return r === void 0 && (r = {}), { name: "size", options: r, async fn(t) { var s, o; const { placement: a, rects: l, platform: u, elements: f } = t, { apply: p = () => { }, ...m } = Rn(r, t), v = await Fo(t, m), y = An(a), _ = Fs(a), S = gn(a) === "y", { width: E, height: b } = l.floating; let k, C; y === "top" || y === "bottom" ? (k = y, C = _ === (await (u.isRTL == null ? void 0 : u.isRTL(f.floating)) ? "start" : "end") ? "left" : "right") : (C = y, k = _ === "end" ? "top" : "bottom"); const T = b - v.top - v.bottom, P = E - v.left - v.right, I = or(b - v[k], T), O = or(E - v[C], P), V = !t.middlewareData.shift; let M = I, R = O; if ((s = t.middlewareData.shift) != null && s.enabled.x && (R = P), (o = t.middlewareData.shift) != null && o.enabled.y && (M = T), V && !_) { const F = Mt(v.left, 0), K = Mt(v.right, 0), G = Mt(v.top, 0), oe = Mt(v.bottom, 0); S ? R = E - 2 * (F !== 0 || K !== 0 ? F + K : Mt(v.left, v.right)) : M = b - 2 * (G !== 0 || oe !== 0 ? G + oe : Mt(v.top, v.bottom)) } await p({ ...t, availableWidth: R, availableHeight: M }); const L = await u.getDimensions(f.floating); return E !== L.width || b !== L.height ? { reset: { rects: !0 } } : {} } } }; function za() { return typeof window < "u" } function Bs(r) { return pv(r) ? (r.nodeName || "").toLowerCase() : "#document" } function Ut(r) { var t; return (r == null || (t = r.ownerDocument) == null ? void 0 : t.defaultView) || window } function xn(r) { var t; return (t = (pv(r) ? r.ownerDocument : r.document) || window.document) == null ? void 0 : t.documentElement } function pv(r) { return za() ? r instanceof Node || r instanceof Ut(r).Node : !1 } function on(r) { return za() ? r instanceof Element || r instanceof Ut(r).Element : !1 } function wn(r) { return za() ? r instanceof HTMLElement || r instanceof Ut(r).HTMLElement : !1 } function lm(r) { return !za() || typeof ShadowRoot > "u" ? !1 : r instanceof ShadowRoot || r instanceof Ut(r).ShadowRoot } const IS = new Set(["inline", "contents"]); function Go(r) { const { overflow: t, overflowX: s, overflowY: o, display: a } = an(r); return /auto|scroll|overlay|hidden|clip/.test(t + o + s) && !IS.has(a) } const DS = new Set(["table", "td", "th"]); function $S(r) { return DS.has(Bs(r)) } const LS = [":popover-open", ":modal"]; function Fa(r) { return LS.some(t => { try { return r.matches(t) } catch { return !1 } }) } const MS = ["transform", "translate", "scale", "rotate", "perspective"], US = ["transform", "translate", "scale", "rotate", "perspective", "filter"], zS = ["paint", "layout", "strict", "content"]; function hd(r) { const t = pd(), s = on(r) ? an(r) : r; return MS.some(o => s[o] ? s[o] !== "none" : !1) || (s.containerType ? s.containerType !== "normal" : !1) || !t && (s.backdropFilter ? s.backdropFilter !== "none" : !1) || !t && (s.filter ? s.filter !== "none" : !1) || US.some(o => (s.willChange || "").includes(o)) || zS.some(o => (s.contain || "").includes(o)) } function FS(r) { let t = ir(r); for (; wn(t) && !$s(t);) { if (hd(t)) return t; if (Fa(t)) return null; t = ir(t) } return null } function pd() { return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none") } const BS = new Set(["html", "body", "#document"]); function $s(r) { return BS.has(Bs(r)) } function an(r) { return Ut(r).getComputedStyle(r) } function Ba(r) { return on(r) ? { scrollLeft: r.scrollLeft, scrollTop: r.scrollTop } : { scrollLeft: r.scrollX, scrollTop: r.scrollY } } function ir(r) { if (Bs(r) === "html") return r; const t = r.assignedSlot || r.parentNode || lm(r) && r.host || xn(r); return lm(t) ? t.host : t } function mv(r) { const t = ir(r); return $s(t) ? r.ownerDocument ? r.ownerDocument.body : r.body : wn(t) && Go(t) ? t : mv(t) } function Bo(r, t, s) { var o; t === void 0 && (t = []), s === void 0 && (s = !0); const a = mv(r), l = a === ((o = r.ownerDocument) == null ? void 0 : o.body), u = Ut(a); if (l) { const f = Cu(u); return t.concat(u, u.visualViewport || [], Go(a) ? a : [], f && s ? Bo(f) : []) } return t.concat(a, Bo(a, [], s)) } function Cu(r) { return r.parent && Object.getPrototypeOf(r.parent) ? r.frameElement : null } function gv(r) { const t = an(r); let s = parseFloat(t.width) || 0, o = parseFloat(t.height) || 0; const a = wn(r), l = a ? r.offsetWidth : s, u = a ? r.offsetHeight : o, f = Ea(s) !== l || Ea(o) !== u; return f && (s = l, o = u), { width: s, height: o, $: f } } function md(r) { return on(r) ? r : r.contextElement } function Ps(r) { const t = md(r); if (!wn(t)) return vn(1); const s = t.getBoundingClientRect(), { width: o, height: a, $: l } = gv(t); let u = (l ? Ea(s.width) : s.width) / o, f = (l ? Ea(s.height) : s.height) / a; return (!u || !Number.isFinite(u)) && (u = 1), (!f || !Number.isFinite(f)) && (f = 1), { x: u, y: f } } const VS = vn(0); function vv(r) { const t = Ut(r); return !pd() || !t.visualViewport ? VS : { x: t.visualViewport.offsetLeft, y: t.visualViewport.offsetTop } } function WS(r, t, s) { return t === void 0 && (t = !1), !s || t && s !== Ut(r) ? !1 : t } function Or(r, t, s, o) { t === void 0 && (t = !1), s === void 0 && (s = !1); const a = r.getBoundingClientRect(), l = md(r); let u = vn(1); t && (o ? on(o) && (u = Ps(o)) : u = Ps(r)); const f = WS(l, s, o) ? vv(l) : vn(0); let p = (a.left + f.x) / u.x, m = (a.top + f.y) / u.y, v = a.width / u.x, y = a.height / u.y; if (l) { const _ = Ut(l), S = o && on(o) ? Ut(o) : o; let E = _, b = Cu(E); for (; b && o && S !== E;) { const k = Ps(b), C = b.getBoundingClientRect(), T = an(b), P = C.left + (b.clientLeft + parseFloat(T.paddingLeft)) * k.x, I = C.top + (b.clientTop + parseFloat(T.paddingTop)) * k.y; p *= k.x, m *= k.y, v *= k.x, y *= k.y, p += P, m += I, E = Ut(b), b = Cu(E) } } return Ca({ width: v, height: y, x: p, y: m }) } function Va(r, t) { const s = Ba(r).scrollLeft; return t ? t.left + s : Or(xn(r)).left + s } function yv(r, t) { const s = r.getBoundingClientRect(), o = s.left + t.scrollLeft - Va(r, s), a = s.top + t.scrollTop; return { x: o, y: a } } function HS(r) { let { elements: t, rect: s, offsetParent: o, strategy: a } = r; const l = a === "fixed", u = xn(o), f = t ? Fa(t.floating) : !1; if (o === u || f && l) return s; let p = { scrollLeft: 0, scrollTop: 0 }, m = vn(1); const v = vn(0), y = wn(o); if ((y || !y && !l) && ((Bs(o) !== "body" || Go(u)) && (p = Ba(o)), wn(o))) { const S = Or(o); m = Ps(o), v.x = S.x + o.clientLeft, v.y = S.y + o.clientTop } const _ = u && !y && !l ? yv(u, p) : vn(0); return { width: s.width * m.x, height: s.height * m.y, x: s.x * m.x - p.scrollLeft * m.x + v.x + _.x, y: s.y * m.y - p.scrollTop * m.y + v.y + _.y } } function KS(r) { return Array.from(r.getClientRects()) } function qS(r) { const t = xn(r), s = Ba(r), o = r.ownerDocument.body, a = Mt(t.scrollWidth, t.clientWidth, o.scrollWidth, o.clientWidth), l = Mt(t.scrollHeight, t.clientHeight, o.scrollHeight, o.clientHeight); let u = -s.scrollLeft + Va(r); const f = -s.scrollTop; return an(o).direction === "rtl" && (u += Mt(t.clientWidth, o.clientWidth) - a), { width: a, height: l, x: u, y: f } } const cm = 25; function GS(r, t) { const s = Ut(r), o = xn(r), a = s.visualViewport; let l = o.clientWidth, u = o.clientHeight, f = 0, p = 0; if (a) { l = a.width, u = a.height; const v = pd(); (!v || v && t === "fixed") && (f = a.offsetLeft, p = a.offsetTop) } const m = Va(o); if (m <= 0) { const v = o.ownerDocument, y = v.body, _ = getComputedStyle(y), S = v.compatMode === "CSS1Compat" && parseFloat(_.marginLeft) + parseFloat(_.marginRight) || 0, E = Math.abs(o.clientWidth - y.clientWidth - S); E <= cm && (l -= E) } else m <= cm && (l += m); return { width: l, height: u, x: f, y: p } } const YS = new Set(["absolute", "fixed"]); function JS(r, t) { const s = Or(r, !0, t === "fixed"), o = s.top + r.clientTop, a = s.left + r.clientLeft, l = wn(r) ? Ps(r) : vn(1), u = r.clientWidth * l.x, f = r.clientHeight * l.y, p = a * l.x, m = o * l.y; return { width: u, height: f, x: p, y: m } } function um(r, t, s) { let o; if (t === "viewport") o = GS(r, s); else if (t === "document") o = qS(xn(r)); else if (on(t)) o = JS(t, s); else { const a = vv(r); o = { x: t.x - a.x, y: t.y - a.y, width: t.width, height: t.height } } return Ca(o) } function wv(r, t) { const s = ir(r); return s === t || !on(s) || $s(s) ? !1 : an(s).position === "fixed" || wv(s, t) } function QS(r, t) { const s = t.get(r); if (s) return s; let o = Bo(r, [], !1).filter(f => on(f) && Bs(f) !== "body"), a = null; const l = an(r).position === "fixed"; let u = l ? ir(r) : r; for (; on(u) && !$s(u);) { const f = an(u), p = hd(u); !p && f.position === "fixed" && (a = null), (l ? !p && !a : !p && f.position === "static" && !!a && YS.has(a.position) || Go(u) && !p && wv(r, u)) ? o = o.filter(v => v !== u) : a = f, u = ir(u) } return t.set(r, o), o } function XS(r) { let { element: t, boundary: s, rootBoundary: o, strategy: a } = r; const u = [...s === "clippingAncestors" ? Fa(t) ? [] : QS(t, this._c) : [].concat(s), o], f = u[0], p = u.reduce((m, v) => { const y = um(t, v, a); return m.top = Mt(y.top, m.top), m.right = or(y.right, m.right), m.bottom = or(y.bottom, m.bottom), m.left = Mt(y.left, m.left), m }, um(t, f, a)); return { width: p.right - p.left, height: p.bottom - p.top, x: p.left, y: p.top } } function ZS(r) { const { width: t, height: s } = gv(r); return { width: t, height: s } } function e1(r, t, s) { const o = wn(t), a = xn(t), l = s === "fixed", u = Or(r, !0, l, t); let f = { scrollLeft: 0, scrollTop: 0 }; const p = vn(0); function m() { p.x = Va(a) } if (o || !o && !l) if ((Bs(t) !== "body" || Go(a)) && (f = Ba(t)), o) { const S = Or(t, !0, l, t); p.x = S.x + t.clientLeft, p.y = S.y + t.clientTop } else a && m(); l && !o && a && m(); const v = a && !o && !l ? yv(a, f) : vn(0), y = u.left + f.scrollLeft - p.x - v.x, _ = u.top + f.scrollTop - p.y - v.y; return { x: y, y: _, width: u.width, height: u.height } } function eu(r) { return an(r).position === "static" } function dm(r, t) { if (!wn(r) || an(r).position === "fixed") return null; if (t) return t(r); let s = r.offsetParent; return xn(r) === s && (s = s.ownerDocument.body), s } function xv(r, t) { const s = Ut(r); if (Fa(r)) return s; if (!wn(r)) { let a = ir(r); for (; a && !$s(a);) { if (on(a) && !eu(a)) return a; a = ir(a) } return s } let o = dm(r, t); for (; o && $S(o) && eu(o);)o = dm(o, t); return o && $s(o) && eu(o) && !hd(o) ? s : o || FS(r) || s } const t1 = async function (r) { const t = this.getOffsetParent || xv, s = this.getDimensions, o = await s(r.floating); return { reference: e1(r.reference, await t(r.floating), r.strategy), floating: { x: 0, y: 0, width: o.width, height: o.height } } }; function n1(r) { return an(r).direction === "rtl" } const r1 = { convertOffsetParentRelativeRectToViewportRelativeRect: HS, getDocumentElement: xn, getClippingRect: XS, getOffsetParent: xv, getElementRects: t1, getClientRects: KS, getDimensions: ZS, getScale: Ps, isElement: on, isRTL: n1 }; function bv(r, t) { return r.x === t.x && r.y === t.y && r.width === t.width && r.height === t.height } function s1(r, t) { let s = null, o; const a = xn(r); function l() { var f; clearTimeout(o), (f = s) == null || f.disconnect(), s = null } function u(f, p) { f === void 0 && (f = !1), p === void 0 && (p = 1), l(); const m = r.getBoundingClientRect(), { left: v, top: y, width: _, height: S } = m; if (f || t(), !_ || !S) return; const E = ua(y), b = ua(a.clientWidth - (v + _)), k = ua(a.clientHeight - (y + S)), C = ua(v), P = { rootMargin: -E + "px " + -b + "px " + -k + "px " + -C + "px", threshold: Mt(0, or(1, p)) || 1 }; let I = !0; function O(V) { const M = V[0].intersectionRatio; if (M !== p) { if (!I) return u(); M ? u(!1, M) : o = setTimeout(() => { u(!1, 1e-7) }, 1e3) } M === 1 && !bv(m, r.getBoundingClientRect()) && u(), I = !1 } try { s = new IntersectionObserver(O, { ...P, root: a.ownerDocument }) } catch { s = new IntersectionObserver(O, P) } s.observe(r) } return u(!0), l } function o1(r, t, s, o) { o === void 0 && (o = {}); const { ancestorScroll: a = !0, ancestorResize: l = !0, elementResize: u = typeof ResizeObserver == "function", layoutShift: f = typeof IntersectionObserver == "function", animationFrame: p = !1 } = o, m = md(r), v = a || l ? [...m ? Bo(m) : [], ...Bo(t)] : []; v.forEach(C => { a && C.addEventListener("scroll", s, { passive: !0 }), l && C.addEventListener("resize", s) }); const y = m && f ? s1(m, s) : null; let _ = -1, S = null; u && (S = new ResizeObserver(C => { let [T] = C; T && T.target === m && S && (S.unobserve(t), cancelAnimationFrame(_), _ = requestAnimationFrame(() => { var P; (P = S) == null || P.observe(t) })), s() }), m && !p && S.observe(m), S.observe(t)); let E, b = p ? Or(r) : null; p && k(); function k() { const C = Or(r); b && !bv(b, C) && s(), b = C, E = requestAnimationFrame(k) } return s(), () => { var C; v.forEach(T => { a && T.removeEventListener("scroll", s), l && T.removeEventListener("resize", s) }), y?.(), (C = S) == null || C.disconnect(), S = null, p && cancelAnimationFrame(E) } } const i1 = PS, a1 = RS, l1 = CS, c1 = OS, u1 = NS, fm = jS, d1 = AS, f1 = (r, t, s) => { const o = new Map, a = { platform: r1, ...s }, l = { ...a.platform, _c: o }; return ES(r, t, { ...a, platform: l }) }; var h1 = typeof document < "u", p1 = function () { }, wa = h1 ? x.useLayoutEffect : p1; function Na(r, t) { if (r === t) return !0; if (typeof r != typeof t) return !1; if (typeof r == "function" && r.toString() === t.toString()) return !0; let s, o, a; if (r && t && typeof r == "object") { if (Array.isArray(r)) { if (s = r.length, s !== t.length) return !1; for (o = s; o-- !== 0;)if (!Na(r[o], t[o])) return !1; return !0 } if (a = Object.keys(r), s = a.length, s !== Object.keys(t).length) return !1; for (o = s; o-- !== 0;)if (!{}.hasOwnProperty.call(t, a[o])) return !1; for (o = s; o-- !== 0;) { const l = a[o]; if (!(l === "_owner" && r.$$typeof) && !Na(r[l], t[l])) return !1 } return !0 } return r !== r && t !== t } function _v(r) { return typeof window > "u" ? 1 : (r.ownerDocument.defaultView || window).devicePixelRatio || 1 } function hm(r, t) { const s = _v(r); return Math.round(t * s) / s } function tu(r) { const t = x.useRef(r); return wa(() => { t.current = r }), t } function m1(r) { r === void 0 && (r = {}); const { placement: t = "bottom", strategy: s = "absolute", middleware: o = [], platform: a, elements: { reference: l, floating: u } = {}, transform: f = !0, whileElementsMounted: p, open: m } = r, [v, y] = x.useState({ x: 0, y: 0, strategy: s, placement: t, middlewareData: {}, isPositioned: !1 }), [_, S] = x.useState(o); Na(_, o) || S(o); const [E, b] = x.useState(null), [k, C] = x.useState(null), T = x.useCallback($ => { $ !== V.current && (V.current = $, b($)) }, []), P = x.useCallback($ => { $ !== M.current && (M.current = $, C($)) }, []), I = l || E, O = u || k, V = x.useRef(null), M = x.useRef(null), R = x.useRef(v), L = p != null, F = tu(p), K = tu(a), G = tu(m), oe = x.useCallback(() => { if (!V.current || !M.current) return; const $ = { placement: t, strategy: s, middleware: _ }; K.current && ($.platform = K.current), f1(V.current, M.current, $).then(ee => { const X = { ...ee, isPositioned: G.current !== !1 }; ae.current && !Na(R.current, X) && (R.current = X, Ho.flushSync(() => { y(X) })) }) }, [_, t, s, K, G]); wa(() => { m === !1 && R.current.isPositioned && (R.current.isPositioned = !1, y($ => ({ ...$, isPositioned: !1 }))) }, [m]); const ae = x.useRef(!1); wa(() => (ae.current = !0, () => { ae.current = !1 }), []), wa(() => { if (I && (V.current = I), O && (M.current = O), I && O) { if (F.current) return F.current(I, O, oe); oe() } }, [I, O, oe, F, L]); const ue = x.useMemo(() => ({ reference: V, floating: M, setReference: T, setFloating: P }), [T, P]), te = x.useMemo(() => ({ reference: I, floating: O }), [I, O]), ne = x.useMemo(() => { const $ = { position: s, left: 0, top: 0 }; if (!te.floating) return $; const ee = hm(te.floating, v.x), X = hm(te.floating, v.y); return f ? { ...$, transform: "translate(" + ee + "px, " + X + "px)", ..._v(te.floating) >= 1.5 && { willChange: "transform" } } : { position: s, left: ee, top: X } }, [s, f, te.floating, v.x, v.y]); return x.useMemo(() => ({ ...v, update: oe, refs: ue, elements: te, floatingStyles: ne }), [v, oe, ue, te, ne]) } const g1 = r => { function t(s) { return {}.hasOwnProperty.call(s, "current") } return { name: "arrow", options: r, fn(s) { const { element: o, padding: a } = typeof r == "function" ? r(s) : r; return o && t(o) ? o.current != null ? fm({ element: o.current, padding: a }).fn(s) : {} : o ? fm({ element: o, padding: a }).fn(s) : {} } } }, v1 = (r, t) => ({ ...i1(r), options: [r, t] }), y1 = (r, t) => ({ ...a1(r), options: [r, t] }), w1 = (r, t) => ({ ...d1(r), options: [r, t] }), x1 = (r, t) => ({ ...l1(r), options: [r, t] }), b1 = (r, t) => ({ ...c1(r), options: [r, t] }), _1 = (r, t) => ({ ...u1(r), options: [r, t] }), S1 = (r, t) => ({ ...g1(r), options: [r, t] }); var k1 = "Arrow", Sv = x.forwardRef((r, t) => { const { children: s, width: o = 10, height: a = 5, ...l } = r; return d.jsx(Ee.svg, { ...l, ref: t, width: o, height: a, viewBox: "0 0 30 10", preserveAspectRatio: "none", children: r.asChild ? s : d.jsx("polygon", { points: "0,0 30,0 15,10" }) }) }); Sv.displayName = k1; var E1 = Sv, gd = "Popper", [kv, Ev] = ar(gd), [j1, jv] = kv(gd), Cv = r => { const { __scopePopper: t, children: s } = r, [o, a] = x.useState(null); return d.jsx(j1, { scope: t, anchor: o, onAnchorChange: a, children: s }) }; Cv.displayName = gd; var Nv = "PopperAnchor", Tv = x.forwardRef((r, t) => { const { __scopePopper: s, virtualRef: o, ...a } = r, l = jv(Nv, s), u = x.useRef(null), f = ze(t, u), p = x.useRef(null); return x.useEffect(() => { const m = p.current; p.current = o?.current || u.current, m !== p.current && l.onAnchorChange(p.current) }), o ? null : d.jsx(Ee.div, { ...a, ref: f }) }); Tv.displayName = Nv; var vd = "PopperContent", [C1, N1] = kv(vd), Pv = x.forwardRef((r, t) => { const { __scopePopper: s, side: o = "bottom", sideOffset: a = 0, align: l = "center", alignOffset: u = 0, arrowPadding: f = 0, avoidCollisions: p = !0, collisionBoundary: m = [], collisionPadding: v = 0, sticky: y = "partial", hideWhenDetached: _ = !1, updatePositionStrategy: S = "optimized", onPlaced: E, ...b } = r, k = jv(vd, s), [C, T] = x.useState(null), P = ze(t, q => T(q)), [I, O] = x.useState(null), V = Cg(I), M = V?.width ?? 0, R = V?.height ?? 0, L = o + (l !== "center" ? "-" + l : ""), F = typeof v == "number" ? v : { top: 0, right: 0, bottom: 0, left: 0, ...v }, K = Array.isArray(m) ? m : [m], G = K.length > 0, oe = { padding: F, boundary: K.filter(P1), altBoundary: G }, { refs: ae, floatingStyles: ue, placement: te, isPositioned: ne, middlewareData: $ } = m1({ strategy: "fixed", placement: L, whileElementsMounted: (...q) => o1(...q, { animationFrame: S === "always" }), elements: { reference: k.anchor }, middleware: [v1({ mainAxis: a + R, alignmentAxis: u }), p && y1({ mainAxis: !0, crossAxis: !1, limiter: y === "partial" ? w1() : void 0, ...oe }), p && x1({ ...oe }), b1({ ...oe, apply: ({ elements: q, rects: le, availableWidth: ve, availableHeight: be }) => { const { width: je, height: Le } = le.reference, Xe = q.floating.style; Xe.setProperty("--radix-popper-available-width", `${ve}px`), Xe.setProperty("--radix-popper-available-height", `${be}px`), Xe.setProperty("--radix-popper-anchor-width", `${je}px`), Xe.setProperty("--radix-popper-anchor-height", `${Le}px`) } }), I && S1({ element: I, padding: f }), R1({ arrowWidth: M, arrowHeight: R }), _ && _1({ strategy: "referenceHidden", ...oe })] }), [ee, X] = Ov(te), j = sr(E); bt(() => { ne && j?.() }, [ne, j]); const U = $.arrow?.x, re = $.arrow?.y, H = $.arrow?.centerOffset !== 0, [se, de] = x.useState(); return bt(() => { C && de(window.getComputedStyle(C).zIndex) }, [C]), d.jsx("div", { ref: ae.setFloating, "data-radix-popper-content-wrapper": "", style: { ...ue, transform: ne ? ue.transform : "translate(0, -200%)", minWidth: "max-content", zIndex: se, "--radix-popper-transform-origin": [$.transformOrigin?.x, $.transformOrigin?.y].join(" "), ...$.hide?.referenceHidden && { visibility: "hidden", pointerEvents: "none" } }, dir: r.dir, children: d.jsx(C1, { scope: s, placedSide: ee, onArrowChange: O, arrowX: U, arrowY: re, shouldHideArrow: H, children: d.jsx(Ee.div, { "data-side": ee, "data-align": X, ...b, ref: P, style: { ...b.style, animation: ne ? void 0 : "none" } }) }) }) }); Pv.displayName = vd; var Rv = "PopperArrow", T1 = { top: "bottom", right: "left", bottom: "top", left: "right" }, Av = x.forwardRef(function (t, s) { const { __scopePopper: o, ...a } = t, l = N1(Rv, o), u = T1[l.placedSide]; return d.jsx("span", { ref: l.onArrowChange, style: { position: "absolute", left: l.arrowX, top: l.arrowY, [u]: 0, transformOrigin: { top: "", right: "0 0", bottom: "center 0", left: "100% 0" }[l.placedSide], transform: { top: "translateY(100%)", right: "translateY(50%) rotate(90deg) translateX(-50%)", bottom: "rotate(180deg)", left: "translateY(50%) rotate(-90deg) translateX(50%)" }[l.placedSide], visibility: l.shouldHideArrow ? "hidden" : void 0 }, children: d.jsx(E1, { ...a, ref: s, style: { ...a.style, display: "block" } }) }) }); Av.displayName = Rv; function P1(r) { return r !== null } var R1 = r => ({ name: "transformOrigin", options: r, fn(t) { const { placement: s, rects: o, middlewareData: a } = t, u = a.arrow?.centerOffset !== 0, f = u ? 0 : r.arrowWidth, p = u ? 0 : r.arrowHeight, [m, v] = Ov(s), y = { start: "0%", center: "50%", end: "100%" }[v], _ = (a.arrow?.x ?? 0) + f / 2, S = (a.arrow?.y ?? 0) + p / 2; let E = "", b = ""; return m === "bottom" ? (E = u ? y : `${_}px`, b = `${-p}px`) : m === "top" ? (E = u ? y : `${_}px`, b = `${o.floating.height + p}px`) : m === "right" ? (E = `${-p}px`, b = u ? y : `${S}px`) : m === "left" && (E = `${o.floating.width + p}px`, b = u ? y : `${S}px`), { data: { x: E, y: b } } } }); function Ov(r) { const [t, s = "center"] = r.split("-"); return [t, s] } var A1 = Cv, O1 = Tv, I1 = Pv, D1 = Av, $1 = "Portal", yd = x.forwardRef((r, t) => { const { container: s, ...o } = r, [a, l] = x.useState(!1); bt(() => l(!0), []); const u = s || a && globalThis?.document?.body; return u ? Hx.createPortal(d.jsx(Ee.div, { ...o, ref: t }), u) : null }); yd.displayName = $1; var Iv = Object.freeze({ position: "absolute", border: 0, width: 1, height: 1, padding: 0, margin: -1, overflow: "hidden", clip: "rect(0, 0, 0, 0)", whiteSpace: "nowrap", wordWrap: "normal" }), L1 = "VisuallyHidden", M1 = x.forwardRef((r, t) => d.jsx(Ee.span, { ...r, ref: t, style: { ...Iv, ...r.style } })); M1.displayName = L1; var U1 = function (r) { if (typeof document > "u") return null; var t = Array.isArray(r) ? r[0] : r; return t.ownerDocument.body }, fs = new WeakMap, da = new WeakMap, fa = {}, nu = 0, Dv = function (r) { return r && (r.host || Dv(r.parentNode)) }, z1 = function (r, t) { return t.map(function (s) { if (r.contains(s)) return s; var o = Dv(s); return o && r.contains(o) ? o : (console.error("aria-hidden", s, "in not contained inside", r, ". Doing nothing"), null) }).filter(function (s) { return !!s }) }, F1 = function (r, t, s, o) { var a = z1(t, Array.isArray(r) ? r : [r]); fa[s] || (fa[s] = new WeakMap); var l = fa[s], u = [], f = new Set, p = new Set(a), m = function (y) { !y || f.has(y) || (f.add(y), m(y.parentNode)) }; a.forEach(m); var v = function (y) { !y || p.has(y) || Array.prototype.forEach.call(y.children, function (_) { if (f.has(_)) v(_); else try { var S = _.getAttribute(o), E = S !== null && S !== "false", b = (fs.get(_) || 0) + 1, k = (l.get(_) || 0) + 1; fs.set(_, b), l.set(_, k), u.push(_), b === 1 && E && da.set(_, !0), k === 1 && _.setAttribute(s, "true"), E || _.setAttribute(o, "true") } catch (C) { console.error("aria-hidden: cannot operate on ", _, C) } }) }; return v(t), f.clear(), nu++, function () { u.forEach(function (y) { var _ = fs.get(y) - 1, S = l.get(y) - 1; fs.set(y, _), l.set(y, S), _ || (da.has(y) || y.removeAttribute(o), da.delete(y)), S || y.removeAttribute(s) }), nu--, nu || (fs = new WeakMap, fs = new WeakMap, da = new WeakMap, fa = {}) } }, $v = function (r, t, s) { s === void 0 && (s = "data-aria-hidden"); var o = Array.from(Array.isArray(r) ? r : [r]), a = U1(r); return a ? (o.push.apply(o, Array.from(a.querySelectorAll("[aria-live], script"))), F1(o, a, s, "aria-hidden")) : function () { return null } }, mn = function () { return mn = Object.assign || function (t) { for (var s, o = 1, a = arguments.length; o < a; o++) { s = arguments[o]; for (var l in s) Object.prototype.hasOwnProperty.call(s, l) && (t[l] = s[l]) } return t }, mn.apply(this, arguments) }; function Lv(r, t) { var s = {}; for (var o in r) Object.prototype.hasOwnProperty.call(r, o) && t.indexOf(o) < 0 && (s[o] = r[o]); if (r != null && typeof Object.getOwnPropertySymbols == "function") for (var a = 0, o = Object.getOwnPropertySymbols(r); a < o.length; a++)t.indexOf(o[a]) < 0 && Object.prototype.propertyIsEnumerable.call(r, o[a]) && (s[o[a]] = r[o[a]]); return s } function B1(r, t, s) { if (s || arguments.length === 2) for (var o = 0, a = t.length, l; o < a; o++)(l || !(o in t)) && (l || (l = Array.prototype.slice.call(t, 0, o)), l[o] = t[o]); return r.concat(l || Array.prototype.slice.call(t)) } var xa = "right-scroll-bar-position", ba = "width-before-scroll-bar", V1 = "with-scroll-bars-hidden", W1 = "--removed-body-scroll-bar-size"; function ru(r, t) { return typeof r == "function" ? r(t) : r && (r.current = t), r } function H1(r, t) { var s = x.useState(function () { return { value: r, callback: t, facade: { get current() { return s.value }, set current(o) { var a = s.value; a !== o && (s.value = o, s.callback(o, a)) } } } })[0]; return s.callback = t, s.facade } var K1 = typeof window < "u" ? x.useLayoutEffect : x.useEffect, pm = new WeakMap; function q1(r, t) { var s = H1(null, function (o) { return r.forEach(function (a) { return ru(a, o) }) }); return K1(function () { var o = pm.get(s); if (o) { var a = new Set(o), l = new Set(r), u = s.current; a.forEach(function (f) { l.has(f) || ru(f, null) }), l.forEach(function (f) { a.has(f) || ru(f, u) }) } pm.set(s, r) }, [r]), s } function G1(r) { return r } function Y1(r, t) { t === void 0 && (t = G1); var s = [], o = !1, a = { read: function () { if (o) throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`."); return s.length ? s[s.length - 1] : r }, useMedium: function (l) { var u = t(l, o); return s.push(u), function () { s = s.filter(function (f) { return f !== u }) } }, assignSyncMedium: function (l) { for (o = !0; s.length;) { var u = s; s = [], u.forEach(l) } s = { push: function (f) { return l(f) }, filter: function () { return s } } }, assignMedium: function (l) { o = !0; var u = []; if (s.length) { var f = s; s = [], f.forEach(l), u = s } var p = function () { var v = u; u = [], v.forEach(l) }, m = function () { return Promise.resolve().then(p) }; m(), s = { push: function (v) { u.push(v), m() }, filter: function (v) { return u = u.filter(v), s } } } }; return a } function J1(r) { r === void 0 && (r = {}); var t = Y1(null); return t.options = mn({ async: !0, ssr: !1 }, r), t } var Mv = function (r) { var t = r.sideCar, s = Lv(r, ["sideCar"]); if (!t) throw new Error("Sidecar: please provide `sideCar` property to import the right car"); var o = t.read(); if (!o) throw new Error("Sidecar medium not found"); return x.createElement(o, mn({}, s)) }; Mv.isSideCarExport = !0; function Q1(r, t) { return r.useMedium(t), Mv } var Uv = J1(), su = function () { }, Wa = x.forwardRef(function (r, t) { var s = x.useRef(null), o = x.useState({ onScrollCapture: su, onWheelCapture: su, onTouchMoveCapture: su }), a = o[0], l = o[1], u = r.forwardProps, f = r.children, p = r.className, m = r.removeScrollBar, v = r.enabled, y = r.shards, _ = r.sideCar, S = r.noRelative, E = r.noIsolation, b = r.inert, k = r.allowPinchZoom, C = r.as, T = C === void 0 ? "div" : C, P = r.gapMode, I = Lv(r, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noRelative", "noIsolation", "inert", "allowPinchZoom", "as", "gapMode"]), O = _, V = q1([s, t]), M = mn(mn({}, I), a); return x.createElement(x.Fragment, null, v && x.createElement(O, { sideCar: Uv, removeScrollBar: m, shards: y, noRelative: S, noIsolation: E, inert: b, setCallbacks: l, allowPinchZoom: !!k, lockRef: s, gapMode: P }), u ? x.cloneElement(x.Children.only(f), mn(mn({}, M), { ref: V })) : x.createElement(T, mn({}, M, { className: p, ref: V }), f)) }); Wa.defaultProps = { enabled: !0, removeScrollBar: !0, inert: !1 }; Wa.classNames = { fullWidth: ba, zeroRight: xa }; var X1 = function () { if (typeof __webpack_nonce__ < "u") return __webpack_nonce__ }; function Z1() { if (!document) return null; var r = document.createElement("style"); r.type = "text/css"; var t = X1(); return t && r.setAttribute("nonce", t), r } function ek(r, t) { r.styleSheet ? r.styleSheet.cssText = t : r.appendChild(document.createTextNode(t)) } function tk(r) { var t = document.head || document.getElementsByTagName("head")[0]; t.appendChild(r) } var nk = function () { var r = 0, t = null; return { add: function (s) { r == 0 && (t = Z1()) && (ek(t, s), tk(t)), r++ }, remove: function () { r--, !r && t && (t.parentNode && t.parentNode.removeChild(t), t = null) } } }, rk = function () { var r = nk(); return function (t, s) { x.useEffect(function () { return r.add(t), function () { r.remove() } }, [t && s]) } }, zv = function () { var r = rk(), t = function (s) { var o = s.styles, a = s.dynamic; return r(o, a), null }; return t }, sk = { left: 0, top: 0, right: 0, gap: 0 }, ou = function (r) { return parseInt(r || "", 10) || 0 }, ok = function (r) { var t = window.getComputedStyle(document.body), s = t[r === "padding" ? "paddingLeft" : "marginLeft"], o = t[r === "padding" ? "paddingTop" : "marginTop"], a = t[r === "padding" ? "paddingRight" : "marginRight"]; return [ou(s), ou(o), ou(a)] }, ik = function (r) { if (r === void 0 && (r = "margin"), typeof window > "u") return sk; var t = ok(r), s = document.documentElement.clientWidth, o = window.innerWidth; return { left: t[0], top: t[1], right: t[2], gap: Math.max(0, o - s + t[2] - t[0]) } }, ak = zv(), Rs = "data-scroll-locked", lk = function (r, t, s, o) {
  var a = r.left, l = r.top, u = r.right, f = r.gap; return s === void 0 && (s = "margin"), `
  .`.concat(V1, ` {
   overflow: hidden `).concat(o, `;
   padding-right: `).concat(f, "px ").concat(o, `;
  }
  body[`).concat(Rs, `] {
    overflow: hidden `).concat(o, `;
    overscroll-behavior: contain;
    `).concat([t && "position: relative ".concat(o, ";"), s === "margin" && `
    padding-left: `.concat(a, `px;
    padding-top: `).concat(l, `px;
    padding-right: `).concat(u, `px;
    margin-left:0;
    margin-top:0;
    margin-right: `).concat(f, "px ").concat(o, `;
    `), s === "padding" && "padding-right: ".concat(f, "px ").concat(o, ";")].filter(Boolean).join(""), `
  }
  
  .`).concat(xa, ` {
    right: `).concat(f, "px ").concat(o, `;
  }
  
  .`).concat(ba, ` {
    margin-right: `).concat(f, "px ").concat(o, `;
  }
  
  .`).concat(xa, " .").concat(xa, ` {
    right: 0 `).concat(o, `;
  }
  
  .`).concat(ba, " .").concat(ba, ` {
    margin-right: 0 `).concat(o, `;
  }
  
  body[`).concat(Rs, `] {
    `).concat(W1, ": ").concat(f, `px;
  }
`)
}, mm = function () { var r = parseInt(document.body.getAttribute(Rs) || "0", 10); return isFinite(r) ? r : 0 }, ck = function () { x.useEffect(function () { return document.body.setAttribute(Rs, (mm() + 1).toString()), function () { var r = mm() - 1; r <= 0 ? document.body.removeAttribute(Rs) : document.body.setAttribute(Rs, r.toString()) } }, []) }, uk = function (r) { var t = r.noRelative, s = r.noImportant, o = r.gapMode, a = o === void 0 ? "margin" : o; ck(); var l = x.useMemo(function () { return ik(a) }, [a]); return x.createElement(ak, { styles: lk(l, !t, a, s ? "" : "!important") }) }, Nu = !1; if (typeof window < "u") try { var ha = Object.defineProperty({}, "passive", { get: function () { return Nu = !0, !0 } }); window.addEventListener("test", ha, ha), window.removeEventListener("test", ha, ha) } catch { Nu = !1 } var hs = Nu ? { passive: !1 } : !1, dk = function (r) { return r.tagName === "TEXTAREA" }, Fv = function (r, t) { if (!(r instanceof Element)) return !1; var s = window.getComputedStyle(r); return s[t] !== "hidden" && !(s.overflowY === s.overflowX && !dk(r) && s[t] === "visible") }, fk = function (r) { return Fv(r, "overflowY") }, hk = function (r) { return Fv(r, "overflowX") }, gm = function (r, t) { var s = t.ownerDocument, o = t; do { typeof ShadowRoot < "u" && o instanceof ShadowRoot && (o = o.host); var a = Bv(r, o); if (a) { var l = Vv(r, o), u = l[1], f = l[2]; if (u > f) return !0 } o = o.parentNode } while (o && o !== s.body); return !1 }, pk = function (r) { var t = r.scrollTop, s = r.scrollHeight, o = r.clientHeight; return [t, s, o] }, mk = function (r) { var t = r.scrollLeft, s = r.scrollWidth, o = r.clientWidth; return [t, s, o] }, Bv = function (r, t) { return r === "v" ? fk(t) : hk(t) }, Vv = function (r, t) { return r === "v" ? pk(t) : mk(t) }, gk = function (r, t) { return r === "h" && t === "rtl" ? -1 : 1 }, vk = function (r, t, s, o, a) { var l = gk(r, window.getComputedStyle(t).direction), u = l * o, f = s.target, p = t.contains(f), m = !1, v = u > 0, y = 0, _ = 0; do { if (!f) break; var S = Vv(r, f), E = S[0], b = S[1], k = S[2], C = b - k - l * E; (E || C) && Bv(r, f) && (y += C, _ += E); var T = f.parentNode; f = T && T.nodeType === Node.DOCUMENT_FRAGMENT_NODE ? T.host : T } while (!p && f !== document.body || p && (t.contains(f) || t === f)); return (v && Math.abs(y) < 1 || !v && Math.abs(_) < 1) && (m = !0), m }, pa = function (r) { return "changedTouches" in r ? [r.changedTouches[0].clientX, r.changedTouches[0].clientY] : [0, 0] }, vm = function (r) { return [r.deltaX, r.deltaY] }, ym = function (r) { return r && "current" in r ? r.current : r }, yk = function (r, t) { return r[0] === t[0] && r[1] === t[1] }, wk = function (r) {
  return `
  .block-interactivity-`.concat(r, ` {pointer-events: none;}
  .allow-interactivity-`).concat(r, ` {pointer-events: all;}
`)
}, xk = 0, ps = []; function bk(r) { var t = x.useRef([]), s = x.useRef([0, 0]), o = x.useRef(), a = x.useState(xk++)[0], l = x.useState(zv)[0], u = x.useRef(r); x.useEffect(function () { u.current = r }, [r]), x.useEffect(function () { if (r.inert) { document.body.classList.add("block-interactivity-".concat(a)); var b = B1([r.lockRef.current], (r.shards || []).map(ym), !0).filter(Boolean); return b.forEach(function (k) { return k.classList.add("allow-interactivity-".concat(a)) }), function () { document.body.classList.remove("block-interactivity-".concat(a)), b.forEach(function (k) { return k.classList.remove("allow-interactivity-".concat(a)) }) } } }, [r.inert, r.lockRef.current, r.shards]); var f = x.useCallback(function (b, k) { if ("touches" in b && b.touches.length === 2 || b.type === "wheel" && b.ctrlKey) return !u.current.allowPinchZoom; var C = pa(b), T = s.current, P = "deltaX" in b ? b.deltaX : T[0] - C[0], I = "deltaY" in b ? b.deltaY : T[1] - C[1], O, V = b.target, M = Math.abs(P) > Math.abs(I) ? "h" : "v"; if ("touches" in b && M === "h" && V.type === "range") return !1; var R = gm(M, V); if (!R) return !0; if (R ? O = M : (O = M === "v" ? "h" : "v", R = gm(M, V)), !R) return !1; if (!o.current && "changedTouches" in b && (P || I) && (o.current = O), !O) return !0; var L = o.current || O; return vk(L, k, b, L === "h" ? P : I) }, []), p = x.useCallback(function (b) { var k = b; if (!(!ps.length || ps[ps.length - 1] !== l)) { var C = "deltaY" in k ? vm(k) : pa(k), T = t.current.filter(function (O) { return O.name === k.type && (O.target === k.target || k.target === O.shadowParent) && yk(O.delta, C) })[0]; if (T && T.should) { k.cancelable && k.preventDefault(); return } if (!T) { var P = (u.current.shards || []).map(ym).filter(Boolean).filter(function (O) { return O.contains(k.target) }), I = P.length > 0 ? f(k, P[0]) : !u.current.noIsolation; I && k.cancelable && k.preventDefault() } } }, []), m = x.useCallback(function (b, k, C, T) { var P = { name: b, delta: k, target: C, should: T, shadowParent: _k(C) }; t.current.push(P), setTimeout(function () { t.current = t.current.filter(function (I) { return I !== P }) }, 1) }, []), v = x.useCallback(function (b) { s.current = pa(b), o.current = void 0 }, []), y = x.useCallback(function (b) { m(b.type, vm(b), b.target, f(b, r.lockRef.current)) }, []), _ = x.useCallback(function (b) { m(b.type, pa(b), b.target, f(b, r.lockRef.current)) }, []); x.useEffect(function () { return ps.push(l), r.setCallbacks({ onScrollCapture: y, onWheelCapture: y, onTouchMoveCapture: _ }), document.addEventListener("wheel", p, hs), document.addEventListener("touchmove", p, hs), document.addEventListener("touchstart", v, hs), function () { ps = ps.filter(function (b) { return b !== l }), document.removeEventListener("wheel", p, hs), document.removeEventListener("touchmove", p, hs), document.removeEventListener("touchstart", v, hs) } }, []); var S = r.removeScrollBar, E = r.inert; return x.createElement(x.Fragment, null, E ? x.createElement(l, { styles: wk(a) }) : null, S ? x.createElement(uk, { noRelative: r.noRelative, gapMode: r.gapMode }) : null) } function _k(r) { for (var t = null; r !== null;)r instanceof ShadowRoot && (t = r.host, r = r.host), r = r.parentNode; return t } const Sk = Q1(Uv, bk); var wd = x.forwardRef(function (r, t) { return x.createElement(Wa, mn({}, r, { ref: t, sideCar: Sk })) }); wd.classNames = Wa.classNames; var kk = [" ", "Enter", "ArrowUp", "ArrowDown"], Ek = [" ", "Enter"], Ir = "Select", [Ha, Ka, jk] = od(Ir), [Vs] = ar(Ir, [jk, Ev]), qa = Ev(), [Ck, lr] = Vs(Ir), [Nk, Tk] = Vs(Ir), Wv = r => { const { __scopeSelect: t, children: s, open: o, defaultOpen: a, onOpenChange: l, value: u, defaultValue: f, onValueChange: p, dir: m, name: v, autoComplete: y, disabled: _, required: S, form: E } = r, b = qa(t), [k, C] = x.useState(null), [T, P] = x.useState(null), [I, O] = x.useState(!1), V = $a(m), [M, R] = Ds({ prop: o, defaultProp: a ?? !1, onChange: l, caller: Ir }), [L, F] = Ds({ prop: u, defaultProp: f, onChange: p, caller: Ir }), K = x.useRef(null), G = k ? E || !!k.closest("form") : !0, [oe, ae] = x.useState(new Set), ue = Array.from(oe).map(te => te.props.value).join(";"); return d.jsx(A1, { ...b, children: d.jsxs(Ck, { required: S, scope: t, trigger: k, onTriggerChange: C, valueNode: T, onValueNodeChange: P, valueNodeHasChildren: I, onValueNodeHasChildrenChange: O, contentId: rr(), value: L, onValueChange: F, open: M, onOpenChange: R, dir: V, triggerPointerDownPosRef: K, disabled: _, children: [d.jsx(Ha.Provider, { scope: t, children: d.jsx(Nk, { scope: r.__scopeSelect, onNativeOptionAdd: x.useCallback(te => { ae(ne => new Set(ne).add(te)) }, []), onNativeOptionRemove: x.useCallback(te => { ae(ne => { const $ = new Set(ne); return $.delete(te), $ }) }, []), children: s }) }), G ? d.jsxs(fy, { "aria-hidden": !0, required: S, tabIndex: -1, name: v, autoComplete: y, value: L, onChange: te => F(te.target.value), disabled: _, form: E, children: [L === void 0 ? d.jsx("option", { value: "" }) : null, Array.from(oe)] }, ue) : null] }) }) }; Wv.displayName = Ir; var Hv = "SelectTrigger", Kv = x.forwardRef((r, t) => { const { __scopeSelect: s, disabled: o = !1, ...a } = r, l = qa(s), u = lr(Hv, s), f = u.disabled || o, p = ze(t, u.onTriggerChange), m = Ka(s), v = x.useRef("touch"), [y, _, S] = py(b => { const k = m().filter(P => !P.disabled), C = k.find(P => P.value === u.value), T = my(k, b, C); T !== void 0 && u.onValueChange(T.value) }), E = b => { f || (u.onOpenChange(!0), S()), b && (u.triggerPointerDownPosRef.current = { x: Math.round(b.pageX), y: Math.round(b.pageY) }) }; return d.jsx(O1, { asChild: !0, ...l, children: d.jsx(Ee.button, { type: "button", role: "combobox", "aria-controls": u.contentId, "aria-expanded": u.open, "aria-required": u.required, "aria-autocomplete": "none", dir: u.dir, "data-state": u.open ? "open" : "closed", disabled: f, "data-disabled": f ? "" : void 0, "data-placeholder": hy(u.value) ? "" : void 0, ...a, ref: p, onClick: ke(a.onClick, b => { b.currentTarget.focus(), v.current !== "mouse" && E(b) }), onPointerDown: ke(a.onPointerDown, b => { v.current = b.pointerType; const k = b.target; k.hasPointerCapture(b.pointerId) && k.releasePointerCapture(b.pointerId), b.button === 0 && b.ctrlKey === !1 && b.pointerType === "mouse" && (E(b), b.preventDefault()) }), onKeyDown: ke(a.onKeyDown, b => { const k = y.current !== ""; !(b.ctrlKey || b.altKey || b.metaKey) && b.key.length === 1 && _(b.key), !(k && b.key === " ") && kk.includes(b.key) && (E(), b.preventDefault()) }) }) }) }); Kv.displayName = Hv; var qv = "SelectValue", Gv = x.forwardRef((r, t) => { const { __scopeSelect: s, className: o, style: a, children: l, placeholder: u = "", ...f } = r, p = lr(qv, s), { onValueNodeHasChildrenChange: m } = p, v = l !== void 0, y = ze(t, p.onValueNodeChange); return bt(() => { m(v) }, [m, v]), d.jsx(Ee.span, { ...f, ref: y, style: { pointerEvents: "none" }, children: hy(p.value) ? d.jsx(d.Fragment, { children: u }) : l }) }); Gv.displayName = qv; var Pk = "SelectIcon", Yv = x.forwardRef((r, t) => { const { __scopeSelect: s, children: o, ...a } = r; return d.jsx(Ee.span, { "aria-hidden": !0, ...a, ref: t, children: o || "▼" }) }); Yv.displayName = Pk; var Rk = "SelectPortal", Jv = r => d.jsx(yd, { asChild: !0, ...r }); Jv.displayName = Rk; var Dr = "SelectContent", Qv = x.forwardRef((r, t) => { const s = lr(Dr, r.__scopeSelect), [o, a] = x.useState(); if (bt(() => { a(new DocumentFragment) }, []), !s.open) { const l = o; return l ? Ho.createPortal(d.jsx(Xv, { scope: r.__scopeSelect, children: d.jsx(Ha.Slot, { scope: r.__scopeSelect, children: d.jsx("div", { children: r.children }) }) }), l) : null } return d.jsx(Zv, { ...r, ref: t }) }); Qv.displayName = Dr; var rn = 10, [Xv, cr] = Vs(Dr), Ak = "SelectContentImpl", Ok = Os("SelectContent.RemoveScroll"), Zv = x.forwardRef((r, t) => { const { __scopeSelect: s, position: o = "item-aligned", onCloseAutoFocus: a, onEscapeKeyDown: l, onPointerDownOutside: u, side: f, sideOffset: p, align: m, alignOffset: v, arrowPadding: y, collisionBoundary: _, collisionPadding: S, sticky: E, hideWhenDetached: b, avoidCollisions: k, ...C } = r, T = lr(Dr, s), [P, I] = x.useState(null), [O, V] = x.useState(null), M = ze(t, q => I(q)), [R, L] = x.useState(null), [F, K] = x.useState(null), G = Ka(s), [oe, ae] = x.useState(!1), ue = x.useRef(!1); x.useEffect(() => { if (P) return $v(P) }, [P]), uv(); const te = x.useCallback(q => { const [le, ...ve] = G().map(Le => Le.ref.current), [be] = ve.slice(-1), je = document.activeElement; for (const Le of q) if (Le === je || (Le?.scrollIntoView({ block: "nearest" }), Le === le && O && (O.scrollTop = 0), Le === be && O && (O.scrollTop = O.scrollHeight), Le?.focus(), document.activeElement !== je)) return }, [G, O]), ne = x.useCallback(() => te([R, P]), [te, R, P]); x.useEffect(() => { oe && ne() }, [oe, ne]); const { onOpenChange: $, triggerPointerDownPosRef: ee } = T; x.useEffect(() => { if (P) { let q = { x: 0, y: 0 }; const le = be => { q = { x: Math.abs(Math.round(be.pageX) - (ee.current?.x ?? 0)), y: Math.abs(Math.round(be.pageY) - (ee.current?.y ?? 0)) } }, ve = be => { q.x <= 10 && q.y <= 10 ? be.preventDefault() : P.contains(be.target) || $(!1), document.removeEventListener("pointermove", le), ee.current = null }; return ee.current !== null && (document.addEventListener("pointermove", le), document.addEventListener("pointerup", ve, { capture: !0, once: !0 })), () => { document.removeEventListener("pointermove", le), document.removeEventListener("pointerup", ve, { capture: !0 }) } } }, [P, $, ee]), x.useEffect(() => { const q = () => $(!1); return window.addEventListener("blur", q), window.addEventListener("resize", q), () => { window.removeEventListener("blur", q), window.removeEventListener("resize", q) } }, [$]); const [X, j] = py(q => { const le = G().filter(je => !je.disabled), ve = le.find(je => je.ref.current === document.activeElement), be = my(le, q, ve); be && setTimeout(() => be.ref.current.focus()) }), U = x.useCallback((q, le, ve) => { const be = !ue.current && !ve; (T.value !== void 0 && T.value === le || be) && (L(q), be && (ue.current = !0)) }, [T.value]), re = x.useCallback(() => P?.focus(), [P]), H = x.useCallback((q, le, ve) => { const be = !ue.current && !ve; (T.value !== void 0 && T.value === le || be) && K(q) }, [T.value]), se = o === "popper" ? Tu : ey, de = se === Tu ? { side: f, sideOffset: p, align: m, alignOffset: v, arrowPadding: y, collisionBoundary: _, collisionPadding: S, sticky: E, hideWhenDetached: b, avoidCollisions: k } : {}; return d.jsx(Xv, { scope: s, content: P, viewport: O, onViewportChange: V, itemRefCallback: U, selectedItem: R, onItemLeave: re, itemTextRefCallback: H, focusSelectedItem: ne, selectedItemText: F, position: o, isPositioned: oe, searchRef: X, children: d.jsx(wd, { as: Ok, allowPinchZoom: !0, children: d.jsx(cd, { asChild: !0, trapped: T.open, onMountAutoFocus: q => { q.preventDefault() }, onUnmountAutoFocus: ke(a, q => { T.trigger?.focus({ preventScroll: !0 }), q.preventDefault() }), children: d.jsx(ld, { asChild: !0, disableOutsidePointerEvents: !0, onEscapeKeyDown: l, onPointerDownOutside: u, onFocusOutside: q => q.preventDefault(), onDismiss: () => T.onOpenChange(!1), children: d.jsx(se, { role: "listbox", id: T.contentId, "data-state": T.open ? "open" : "closed", dir: T.dir, onContextMenu: q => q.preventDefault(), ...C, ...de, onPlaced: () => ae(!0), ref: M, style: { display: "flex", flexDirection: "column", outline: "none", ...C.style }, onKeyDown: ke(C.onKeyDown, q => { const le = q.ctrlKey || q.altKey || q.metaKey; if (q.key === "Tab" && q.preventDefault(), !le && q.key.length === 1 && j(q.key), ["ArrowUp", "ArrowDown", "Home", "End"].includes(q.key)) { let be = G().filter(je => !je.disabled).map(je => je.ref.current); if (["ArrowUp", "End"].includes(q.key) && (be = be.slice().reverse()), ["ArrowUp", "ArrowDown"].includes(q.key)) { const je = q.target, Le = be.indexOf(je); be = be.slice(Le + 1) } setTimeout(() => te(be)), q.preventDefault() } }) }) }) }) }) }) }); Zv.displayName = Ak; var Ik = "SelectItemAlignedPosition", ey = x.forwardRef((r, t) => { const { __scopeSelect: s, onPlaced: o, ...a } = r, l = lr(Dr, s), u = cr(Dr, s), [f, p] = x.useState(null), [m, v] = x.useState(null), y = ze(t, M => v(M)), _ = Ka(s), S = x.useRef(!1), E = x.useRef(!0), { viewport: b, selectedItem: k, selectedItemText: C, focusSelectedItem: T } = u, P = x.useCallback(() => { if (l.trigger && l.valueNode && f && m && b && k && C) { const M = l.trigger.getBoundingClientRect(), R = m.getBoundingClientRect(), L = l.valueNode.getBoundingClientRect(), F = C.getBoundingClientRect(); if (l.dir !== "rtl") { const je = F.left - R.left, Le = L.left - je, Xe = M.left - Le, nt = M.width + Xe, Mr = Math.max(nt, R.width), Ur = window.innerWidth - rn, dr = ka(Le, [rn, Math.max(rn, Ur - Mr)]); f.style.minWidth = nt + "px", f.style.left = dr + "px" } else { const je = R.right - F.right, Le = window.innerWidth - L.right - je, Xe = window.innerWidth - M.right - Le, nt = M.width + Xe, Mr = Math.max(nt, R.width), Ur = window.innerWidth - rn, dr = ka(Le, [rn, Math.max(rn, Ur - Mr)]); f.style.minWidth = nt + "px", f.style.right = dr + "px" } const K = _(), G = window.innerHeight - rn * 2, oe = b.scrollHeight, ae = window.getComputedStyle(m), ue = parseInt(ae.borderTopWidth, 10), te = parseInt(ae.paddingTop, 10), ne = parseInt(ae.borderBottomWidth, 10), $ = parseInt(ae.paddingBottom, 10), ee = ue + te + oe + $ + ne, X = Math.min(k.offsetHeight * 5, ee), j = window.getComputedStyle(b), U = parseInt(j.paddingTop, 10), re = parseInt(j.paddingBottom, 10), H = M.top + M.height / 2 - rn, se = G - H, de = k.offsetHeight / 2, q = k.offsetTop + de, le = ue + te + q, ve = ee - le; if (le <= H) { const je = K.length > 0 && k === K[K.length - 1].ref.current; f.style.bottom = "0px"; const Le = m.clientHeight - b.offsetTop - b.offsetHeight, Xe = Math.max(se, de + (je ? re : 0) + Le + ne), nt = le + Xe; f.style.height = nt + "px" } else { const je = K.length > 0 && k === K[0].ref.current; f.style.top = "0px"; const Xe = Math.max(H, ue + b.offsetTop + (je ? U : 0) + de) + ve; f.style.height = Xe + "px", b.scrollTop = le - H + b.offsetTop } f.style.margin = `${rn}px 0`, f.style.minHeight = X + "px", f.style.maxHeight = G + "px", o?.(), requestAnimationFrame(() => S.current = !0) } }, [_, l.trigger, l.valueNode, f, m, b, k, C, l.dir, o]); bt(() => P(), [P]); const [I, O] = x.useState(); bt(() => { m && O(window.getComputedStyle(m).zIndex) }, [m]); const V = x.useCallback(M => { M && E.current === !0 && (P(), T?.(), E.current = !1) }, [P, T]); return d.jsx($k, { scope: s, contentWrapper: f, shouldExpandOnScrollRef: S, onScrollButtonChange: V, children: d.jsx("div", { ref: p, style: { display: "flex", flexDirection: "column", position: "fixed", zIndex: I }, children: d.jsx(Ee.div, { ...a, ref: y, style: { boxSizing: "border-box", maxHeight: "100%", ...a.style } }) }) }) }); ey.displayName = Ik; var Dk = "SelectPopperPosition", Tu = x.forwardRef((r, t) => { const { __scopeSelect: s, align: o = "start", collisionPadding: a = rn, ...l } = r, u = qa(s); return d.jsx(I1, { ...u, ...l, ref: t, align: o, collisionPadding: a, style: { boxSizing: "border-box", ...l.style, "--radix-select-content-transform-origin": "var(--radix-popper-transform-origin)", "--radix-select-content-available-width": "var(--radix-popper-available-width)", "--radix-select-content-available-height": "var(--radix-popper-available-height)", "--radix-select-trigger-width": "var(--radix-popper-anchor-width)", "--radix-select-trigger-height": "var(--radix-popper-anchor-height)" } }) }); Tu.displayName = Dk; var [$k, xd] = Vs(Dr, {}), Pu = "SelectViewport", ty = x.forwardRef((r, t) => { const { __scopeSelect: s, nonce: o, ...a } = r, l = cr(Pu, s), u = xd(Pu, s), f = ze(t, l.onViewportChange), p = x.useRef(0); return d.jsxs(d.Fragment, { children: [d.jsx("style", { dangerouslySetInnerHTML: { __html: "[data-radix-select-viewport]{scrollbar-width:none;-ms-overflow-style:none;-webkit-overflow-scrolling:touch;}[data-radix-select-viewport]::-webkit-scrollbar{display:none}" }, nonce: o }), d.jsx(Ha.Slot, { scope: s, children: d.jsx(Ee.div, { "data-radix-select-viewport": "", role: "presentation", ...a, ref: f, style: { position: "relative", flex: 1, overflow: "hidden auto", ...a.style }, onScroll: ke(a.onScroll, m => { const v = m.currentTarget, { contentWrapper: y, shouldExpandOnScrollRef: _ } = u; if (_?.current && y) { const S = Math.abs(p.current - v.scrollTop); if (S > 0) { const E = window.innerHeight - rn * 2, b = parseFloat(y.style.minHeight), k = parseFloat(y.style.height), C = Math.max(b, k); if (C < E) { const T = C + S, P = Math.min(E, T), I = T - P; y.style.height = P + "px", y.style.bottom === "0px" && (v.scrollTop = I > 0 ? I : 0, y.style.justifyContent = "flex-end") } } } p.current = v.scrollTop }) }) })] }) }); ty.displayName = Pu; var ny = "SelectGroup", [Lk, Mk] = Vs(ny), Uk = x.forwardRef((r, t) => { const { __scopeSelect: s, ...o } = r, a = rr(); return d.jsx(Lk, { scope: s, id: a, children: d.jsx(Ee.div, { role: "group", "aria-labelledby": a, ...o, ref: t }) }) }); Uk.displayName = ny; var ry = "SelectLabel", zk = x.forwardRef((r, t) => { const { __scopeSelect: s, ...o } = r, a = Mk(ry, s); return d.jsx(Ee.div, { id: a.id, ...o, ref: t }) }); zk.displayName = ry; var Ta = "SelectItem", [Fk, sy] = Vs(Ta), oy = x.forwardRef((r, t) => { const { __scopeSelect: s, value: o, disabled: a = !1, textValue: l, ...u } = r, f = lr(Ta, s), p = cr(Ta, s), m = f.value === o, [v, y] = x.useState(l ?? ""), [_, S] = x.useState(!1), E = ze(t, T => p.itemRefCallback?.(T, o, a)), b = rr(), k = x.useRef("touch"), C = () => { a || (f.onValueChange(o), f.onOpenChange(!1)) }; if (o === "") throw new Error("A <Select.Item /> must have a value prop that is not an empty string. This is because the Select value can be set to an empty string to clear the selection and show the placeholder."); return d.jsx(Fk, { scope: s, value: o, disabled: a, textId: b, isSelected: m, onItemTextChange: x.useCallback(T => { y(P => P || (T?.textContent ?? "").trim()) }, []), children: d.jsx(Ha.ItemSlot, { scope: s, value: o, disabled: a, textValue: v, children: d.jsx(Ee.div, { role: "option", "aria-labelledby": b, "data-highlighted": _ ? "" : void 0, "aria-selected": m && _, "data-state": m ? "checked" : "unchecked", "aria-disabled": a || void 0, "data-disabled": a ? "" : void 0, tabIndex: a ? void 0 : -1, ...u, ref: E, onFocus: ke(u.onFocus, () => S(!0)), onBlur: ke(u.onBlur, () => S(!1)), onClick: ke(u.onClick, () => { k.current !== "mouse" && C() }), onPointerUp: ke(u.onPointerUp, () => { k.current === "mouse" && C() }), onPointerDown: ke(u.onPointerDown, T => { k.current = T.pointerType }), onPointerMove: ke(u.onPointerMove, T => { k.current = T.pointerType, a ? p.onItemLeave?.() : k.current === "mouse" && T.currentTarget.focus({ preventScroll: !0 }) }), onPointerLeave: ke(u.onPointerLeave, T => { T.currentTarget === document.activeElement && p.onItemLeave?.() }), onKeyDown: ke(u.onKeyDown, T => { p.searchRef?.current !== "" && T.key === " " || (Ek.includes(T.key) && C(), T.key === " " && T.preventDefault()) }) }) }) }) }); oy.displayName = Ta; var Oo = "SelectItemText", iy = x.forwardRef((r, t) => { const { __scopeSelect: s, className: o, style: a, ...l } = r, u = lr(Oo, s), f = cr(Oo, s), p = sy(Oo, s), m = Tk(Oo, s), [v, y] = x.useState(null), _ = ze(t, C => y(C), p.onItemTextChange, C => f.itemTextRefCallback?.(C, p.value, p.disabled)), S = v?.textContent, E = x.useMemo(() => d.jsx("option", { value: p.value, disabled: p.disabled, children: S }, p.value), [p.disabled, p.value, S]), { onNativeOptionAdd: b, onNativeOptionRemove: k } = m; return bt(() => (b(E), () => k(E)), [b, k, E]), d.jsxs(d.Fragment, { children: [d.jsx(Ee.span, { id: p.textId, ...l, ref: _ }), p.isSelected && u.valueNode && !u.valueNodeHasChildren ? Ho.createPortal(l.children, u.valueNode) : null] }) }); iy.displayName = Oo; var ay = "SelectItemIndicator", ly = x.forwardRef((r, t) => { const { __scopeSelect: s, ...o } = r; return sy(ay, s).isSelected ? d.jsx(Ee.span, { "aria-hidden": !0, ...o, ref: t }) : null }); ly.displayName = ay; var Ru = "SelectScrollUpButton", cy = x.forwardRef((r, t) => { const s = cr(Ru, r.__scopeSelect), o = xd(Ru, r.__scopeSelect), [a, l] = x.useState(!1), u = ze(t, o.onScrollButtonChange); return bt(() => { if (s.viewport && s.isPositioned) { let f = function () { const m = p.scrollTop > 0; l(m) }; const p = s.viewport; return f(), p.addEventListener("scroll", f), () => p.removeEventListener("scroll", f) } }, [s.viewport, s.isPositioned]), a ? d.jsx(dy, { ...r, ref: u, onAutoScroll: () => { const { viewport: f, selectedItem: p } = s; f && p && (f.scrollTop = f.scrollTop - p.offsetHeight) } }) : null }); cy.displayName = Ru; var Au = "SelectScrollDownButton", uy = x.forwardRef((r, t) => { const s = cr(Au, r.__scopeSelect), o = xd(Au, r.__scopeSelect), [a, l] = x.useState(!1), u = ze(t, o.onScrollButtonChange); return bt(() => { if (s.viewport && s.isPositioned) { let f = function () { const m = p.scrollHeight - p.clientHeight, v = Math.ceil(p.scrollTop) < m; l(v) }; const p = s.viewport; return f(), p.addEventListener("scroll", f), () => p.removeEventListener("scroll", f) } }, [s.viewport, s.isPositioned]), a ? d.jsx(dy, { ...r, ref: u, onAutoScroll: () => { const { viewport: f, selectedItem: p } = s; f && p && (f.scrollTop = f.scrollTop + p.offsetHeight) } }) : null }); uy.displayName = Au; var dy = x.forwardRef((r, t) => { const { __scopeSelect: s, onAutoScroll: o, ...a } = r, l = cr("SelectScrollButton", s), u = x.useRef(null), f = Ka(s), p = x.useCallback(() => { u.current !== null && (window.clearInterval(u.current), u.current = null) }, []); return x.useEffect(() => () => p(), [p]), bt(() => { f().find(v => v.ref.current === document.activeElement)?.ref.current?.scrollIntoView({ block: "nearest" }) }, [f]), d.jsx(Ee.div, { "aria-hidden": !0, ...a, ref: t, style: { flexShrink: 0, ...a.style }, onPointerDown: ke(a.onPointerDown, () => { u.current === null && (u.current = window.setInterval(o, 50)) }), onPointerMove: ke(a.onPointerMove, () => { l.onItemLeave?.(), u.current === null && (u.current = window.setInterval(o, 50)) }), onPointerLeave: ke(a.onPointerLeave, () => { p() }) }) }), Bk = "SelectSeparator", Vk = x.forwardRef((r, t) => { const { __scopeSelect: s, ...o } = r; return d.jsx(Ee.div, { "aria-hidden": !0, ...o, ref: t }) }); Vk.displayName = Bk; var Ou = "SelectArrow", Wk = x.forwardRef((r, t) => { const { __scopeSelect: s, ...o } = r, a = qa(s), l = lr(Ou, s), u = cr(Ou, s); return l.open && u.position === "popper" ? d.jsx(D1, { ...a, ...o, ref: t }) : null }); Wk.displayName = Ou; var Hk = "SelectBubbleInput", fy = x.forwardRef(({ __scopeSelect: r, value: t, ...s }, o) => { const a = x.useRef(null), l = ze(o, a), u = jg(t); return x.useEffect(() => { const f = a.current; if (!f) return; const p = window.HTMLSelectElement.prototype, v = Object.getOwnPropertyDescriptor(p, "value").set; if (u !== t && v) { const y = new Event("change", { bubbles: !0 }); v.call(f, t), f.dispatchEvent(y) } }, [u, t]), d.jsx(Ee.select, { ...s, style: { ...Iv, ...s.style }, ref: l, defaultValue: t }) }); fy.displayName = Hk; function hy(r) { return r === "" || r === void 0 } function py(r) { const t = sr(r), s = x.useRef(""), o = x.useRef(0), a = x.useCallback(u => { const f = s.current + u; t(f), (function p(m) { s.current = m, window.clearTimeout(o.current), m !== "" && (o.current = window.setTimeout(() => p(""), 1e3)) })(f) }, [t]), l = x.useCallback(() => { s.current = "", window.clearTimeout(o.current) }, []); return x.useEffect(() => () => window.clearTimeout(o.current), []), [s, a, l] } function my(r, t, s) { const a = t.length > 1 && Array.from(t).every(m => m === t[0]) ? t[0] : t, l = s ? r.indexOf(s) : -1; let u = Kk(r, Math.max(l, 0)); a.length === 1 && (u = u.filter(m => m !== s)); const p = u.find(m => m.textValue.toLowerCase().startsWith(a.toLowerCase())); return p !== s ? p : void 0 } function Kk(r, t) { return r.map((s, o) => r[(t + o) % r.length]) } var qk = Wv, Gk = Kv, Yk = Gv, Jk = Yv, Qk = Jv, Xk = Qv, Zk = ty, eE = oy, tE = iy, nE = ly, rE = cy, sE = uy; function oE({ ...r }) { return d.jsx(qk, { "data-slot": "select", ...r }) } function iE({ ...r }) { return d.jsx(Yk, { "data-slot": "select-value", ...r }) } function aE({ className: r, size: t = "default", children: s, ...o }) { return d.jsxs(Gk, { "data-slot": "select-trigger", "data-size": t, className: Pe("border-input data-[placeholder]:text-muted-foreground [&_svg:not([class*='text-'])]:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 dark:hover:bg-input/50 flex w-full items-center justify-between gap-2 rounded-md border bg-input-background px-3 py-2 text-sm whitespace-nowrap transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 data-[size=default]:h-9 data-[size=sm]:h-8 *:data-[slot=select-value]:line-clamp-1 *:data-[slot=select-value]:flex *:data-[slot=select-value]:items-center *:data-[slot=select-value]:gap-2 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4", r), ...o, children: [s, d.jsx(Jk, { asChild: !0, children: d.jsx(mg, { className: "size-4 opacity-50" }) })] }) } function lE({ className: r, children: t, position: s = "popper", ...o }) { return d.jsx(Qk, { children: d.jsxs(Xk, { "data-slot": "select-content", className: Pe("bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 relative z-50 max-h-(--radix-select-content-available-height) min-w-[8rem] origin-(--radix-select-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-md border shadow-md", s === "popper" && "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1", r), position: s, ...o, children: [d.jsx(uE, {}), d.jsx(Zk, { className: Pe("p-1", s === "popper" && "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)] scroll-my-1"), children: t }), d.jsx(dE, {})] }) }) } function cE({ className: r, children: t, ...s }) { return d.jsxs(eE, { "data-slot": "select-item", className: Pe("focus:bg-accent focus:text-accent-foreground [&_svg:not([class*='text-'])]:text-muted-foreground relative flex w-full cursor-default items-center gap-2 rounded-sm py-1.5 pr-8 pl-2 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4 *:[span]:last:flex *:[span]:last:items-center *:[span]:last:gap-2", r), ...s, children: [d.jsx("span", { className: "absolute right-2 flex size-3.5 items-center justify-center", children: d.jsx(nE, { children: d.jsx(cb, { className: "size-4" }) }) }), d.jsx(tE, { children: t })] }) } function uE({ className: r, ...t }) { return d.jsx(rE, { "data-slot": "select-scroll-up-button", className: Pe("flex cursor-default items-center justify-center py-1", r), ...t, children: d.jsx(fb, { className: "size-4" }) }) } function dE({ className: r, ...t }) { return d.jsx(sE, { "data-slot": "select-scroll-down-button", className: Pe("flex cursor-default items-center justify-center py-1", r), ...t, children: d.jsx(mg, { className: "size-4" }) }) } var Ga = "Dialog", [gy] = ar(Ga), [fE, ln] = gy(Ga), vy = r => { const { __scopeDialog: t, children: s, open: o, defaultOpen: a, onOpenChange: l, modal: u = !0 } = r, f = x.useRef(null), p = x.useRef(null), [m, v] = Ds({ prop: o, defaultProp: a ?? !1, onChange: l, caller: Ga }); return d.jsx(fE, { scope: t, triggerRef: f, contentRef: p, contentId: rr(), titleId: rr(), descriptionId: rr(), open: m, onOpenChange: v, onOpenToggle: x.useCallback(() => v(y => !y), [v]), modal: u, children: s }) }; vy.displayName = Ga; var yy = "DialogTrigger", wy = x.forwardRef((r, t) => { const { __scopeDialog: s, ...o } = r, a = ln(yy, s), l = ze(t, a.triggerRef); return d.jsx(Ee.button, { type: "button", "aria-haspopup": "dialog", "aria-expanded": a.open, "aria-controls": a.contentId, "data-state": Sd(a.open), ...o, ref: l, onClick: ke(r.onClick, a.onOpenToggle) }) }); wy.displayName = yy; var bd = "DialogPortal", [hE, xy] = gy(bd, { forceMount: void 0 }), by = r => { const { __scopeDialog: t, forceMount: s, children: o, container: a } = r, l = ln(bd, t); return d.jsx(hE, { scope: t, forceMount: s, children: x.Children.map(o, u => d.jsx(qo, { present: s || l.open, children: d.jsx(yd, { asChild: !0, container: a, children: u }) })) }) }; by.displayName = bd; var Pa = "DialogOverlay", _y = x.forwardRef((r, t) => { const s = xy(Pa, r.__scopeDialog), { forceMount: o = s.forceMount, ...a } = r, l = ln(Pa, r.__scopeDialog); return l.modal ? d.jsx(qo, { present: o || l.open, children: d.jsx(mE, { ...a, ref: t }) }) : null }); _y.displayName = Pa; var pE = Os("DialogOverlay.RemoveScroll"), mE = x.forwardRef((r, t) => { const { __scopeDialog: s, ...o } = r, a = ln(Pa, s); return d.jsx(wd, { as: pE, allowPinchZoom: !0, shards: [a.contentRef], children: d.jsx(Ee.div, { "data-state": Sd(a.open), ...o, ref: t, style: { pointerEvents: "auto", ...o.style } }) }) }), $r = "DialogContent", Sy = x.forwardRef((r, t) => { const s = xy($r, r.__scopeDialog), { forceMount: o = s.forceMount, ...a } = r, l = ln($r, r.__scopeDialog); return d.jsx(qo, { present: o || l.open, children: l.modal ? d.jsx(gE, { ...a, ref: t }) : d.jsx(vE, { ...a, ref: t }) }) }); Sy.displayName = $r; var gE = x.forwardRef((r, t) => { const s = ln($r, r.__scopeDialog), o = x.useRef(null), a = ze(t, s.contentRef, o); return x.useEffect(() => { const l = o.current; if (l) return $v(l) }, []), d.jsx(ky, { ...r, ref: a, trapFocus: s.open, disableOutsidePointerEvents: !0, onCloseAutoFocus: ke(r.onCloseAutoFocus, l => { l.preventDefault(), s.triggerRef.current?.focus() }), onPointerDownOutside: ke(r.onPointerDownOutside, l => { const u = l.detail.originalEvent, f = u.button === 0 && u.ctrlKey === !0; (u.button === 2 || f) && l.preventDefault() }), onFocusOutside: ke(r.onFocusOutside, l => l.preventDefault()) }) }), vE = x.forwardRef((r, t) => { const s = ln($r, r.__scopeDialog), o = x.useRef(!1), a = x.useRef(!1); return d.jsx(ky, { ...r, ref: t, trapFocus: !1, disableOutsidePointerEvents: !1, onCloseAutoFocus: l => { r.onCloseAutoFocus?.(l), l.defaultPrevented || (o.current || s.triggerRef.current?.focus(), l.preventDefault()), o.current = !1, a.current = !1 }, onInteractOutside: l => { r.onInteractOutside?.(l), l.defaultPrevented || (o.current = !0, l.detail.originalEvent.type === "pointerdown" && (a.current = !0)); const u = l.target; s.triggerRef.current?.contains(u) && l.preventDefault(), l.detail.originalEvent.type === "focusin" && a.current && l.preventDefault() } }) }), ky = x.forwardRef((r, t) => { const { __scopeDialog: s, trapFocus: o, onOpenAutoFocus: a, onCloseAutoFocus: l, ...u } = r, f = ln($r, s), p = x.useRef(null), m = ze(t, p); return uv(), d.jsxs(d.Fragment, { children: [d.jsx(cd, { asChild: !0, loop: !0, trapped: o, onMountAutoFocus: a, onUnmountAutoFocus: l, children: d.jsx(ld, { role: "dialog", id: f.contentId, "aria-describedby": f.descriptionId, "aria-labelledby": f.titleId, "data-state": Sd(f.open), ...u, ref: m, onDismiss: () => f.onOpenChange(!1) }) }), d.jsxs(d.Fragment, { children: [d.jsx(yE, { titleId: f.titleId }), d.jsx(xE, { contentRef: p, descriptionId: f.descriptionId })] })] }) }), _d = "DialogTitle", Ey = x.forwardRef((r, t) => { const { __scopeDialog: s, ...o } = r, a = ln(_d, s); return d.jsx(Ee.h2, { id: a.titleId, ...o, ref: t }) }); Ey.displayName = _d; var jy = "DialogDescription", Cy = x.forwardRef((r, t) => { const { __scopeDialog: s, ...o } = r, a = ln(jy, s); return d.jsx(Ee.p, { id: a.descriptionId, ...o, ref: t }) }); Cy.displayName = jy; var Ny = "DialogClose", Ty = x.forwardRef((r, t) => { const { __scopeDialog: s, ...o } = r, a = ln(Ny, s); return d.jsx(Ee.button, { type: "button", ...o, ref: t, onClick: ke(r.onClick, () => a.onOpenChange(!1)) }) }); Ty.displayName = Ny; function Sd(r) { return r ? "open" : "closed" } var Py = "DialogTitleWarning", [gN, Ry] = Vx(Py, { contentName: $r, titleName: _d, docsSlug: "dialog" }), yE = ({ titleId: r }) => {
  const t = Ry(Py), s = `\`${t.contentName}\` requires a \`${t.titleName}\` for the component to be accessible for screen reader users.

If you want to hide the \`${t.titleName}\`, you can wrap it with our VisuallyHidden component.

For more information, see https://radix-ui.com/primitives/docs/components/${t.docsSlug}`; return x.useEffect(() => { r && (document.getElementById(r) || console.error(s)) }, [s, r]), null
}, wE = "DialogDescriptionWarning", xE = ({ contentRef: r, descriptionId: t }) => { const o = `Warning: Missing \`Description\` or \`aria-describedby={undefined}\` for {${Ry(wE).contentName}}.`; return x.useEffect(() => { const a = r.current?.getAttribute("aria-describedby"); t && a && (document.getElementById(t) || console.warn(o)) }, [o, r, t]), null }, bE = vy, _E = wy, SE = by, kE = _y, EE = Sy, jE = Ey, CE = Cy, NE = Ty; function kd({ ...r }) { return d.jsx(bE, { "data-slot": "dialog", ...r }) } function Ed({ ...r }) { return d.jsx(_E, { "data-slot": "dialog-trigger", ...r }) } function TE({ ...r }) { return d.jsx(SE, { "data-slot": "dialog-portal", ...r }) } function PE({ className: r, ...t }) { return d.jsx(kE, { "data-slot": "dialog-overlay", className: Pe("data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50", r), ...t }) } function jd({ className: r, children: t, ...s }) { return d.jsxs(TE, { "data-slot": "dialog-portal", children: [d.jsx(PE, {}), d.jsxs(EE, { "data-slot": "dialog-content", className: Pe("bg-background data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 fixed top-[50%] left-[50%] z-50 grid w-full max-w-[calc(100%-2rem)] translate-x-[-50%] translate-y-[-50%] gap-4 rounded-lg border p-6 shadow-lg duration-200 sm:max-w-lg", r), ...s, children: [t, d.jsxs(NE, { className: "ring-offset-background focus:ring-ring data-[state=open]:bg-accent data-[state=open]:text-muted-foreground absolute top-4 right-4 rounded-xs opacity-70 transition-opacity hover:opacity-100 focus:ring-2 focus:ring-offset-2 focus:outline-hidden disabled:pointer-events-none [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4", children: [d.jsx(Eg, {}), d.jsx("span", { className: "sr-only", children: "Close" })] })] })] }) } function Cd({ className: r, ...t }) { return d.jsx("div", { "data-slot": "dialog-header", className: Pe("flex flex-col gap-2 text-center sm:text-left", r), ...t }) } function Nd({ className: r, ...t }) { return d.jsx("div", { "data-slot": "dialog-footer", className: Pe("flex flex-col-reverse gap-2 sm:flex-row sm:justify-end", r), ...t }) } function Td({ className: r, ...t }) { return d.jsx(jE, { "data-slot": "dialog-title", className: Pe("text-lg leading-none font-semibold", r), ...t }) } function Pd({ className: r, ...t }) { return d.jsx(CE, { "data-slot": "dialog-description", className: Pe("text-muted-foreground text-sm", r), ...t }) } const RE = Xu("relative w-full rounded-lg border px-4 py-3 text-sm grid has-[>svg]:grid-cols-[calc(var(--spacing)*4)_1fr] grid-cols-[0_1fr] has-[>svg]:gap-x-3 gap-y-0.5 items-start [&>svg]:size-4 [&>svg]:translate-y-0.5 [&>svg]:text-current", { variants: { variant: { default: "bg-card text-card-foreground", destructive: "text-destructive bg-card [&>svg]:text-current *:data-[slot=alert-description]:text-destructive/90" } }, defaultVariants: { variant: "default" } }); function Iu({ className: r, variant: t, ...s }) { return d.jsx("div", { "data-slot": "alert", role: "alert", className: Pe(RE({ variant: t }), r), ...s }) } function Du({ className: r, ...t }) { return d.jsx("div", { "data-slot": "alert-description", className: Pe("text-muted-foreground col-start-2 grid justify-items-start gap-1 text-sm [&_p]:leading-relaxed", r), ...t }) } function AE({ onStatsUpdate: r }) { const t = "https://via.placeholder.com/480x270/1f2937/ffffff?text=Video", s = j => `https://img.youtube.com/vi/${j}/hqdefault.jpg`, o = j => j.videoType === "youtube" && j.youtubeId ? j.thumbnail || s(j.youtubeId) : j.thumbnail || t, [a, l] = x.useState([]), [u, f] = x.useState({}), [p, m] = x.useState(""), [v, y] = x.useState(!0), [_, S] = x.useState(!1), [E, b] = x.useState(null), [k, C] = x.useState({ title: "", description: "", youtubeId: "", duration: "", videoType: "youtube" }), [T, P] = x.useState(null), [I, O] = x.useState(0), [V, M] = x.useState(!1), [R, L] = x.useState("youtube"); x.useEffect(() => { F() }, []), x.useEffect(() => { p && K(p) }, [p]); const F = async () => { try { const j = await fetch(`https://${Re}.supabase.co/functions/v1/make-server-a8898ff1/categories`, { headers: { Authorization: `Bearer ${$e}`, cache: "no-store" } }); if (!j.ok) throw new Error("Failed to fetch categories"); const U = await j.json(); l(U.categories || []), U.categories && U.categories.length > 0 && !p && m(U.categories[0].id) } catch (j) { console.error("Error loading categories:", j); const U = [{ id: "fire", title: "화재발생 시 대응요령" }, { id: "safety", title: "지하철 안전운행" }, { id: "emergency", title: "응급상황 대응" }]; l(U), p || m(U[0].id) } finally { y(!1) } }, K = async j => { try { const U = await fetch(`https://${Re}.supabase.co/functions/v1/make-server-a8898ff1/videos/${j}`, { headers: { Authorization: `Bearer ${$e}`, cache: "no-store" } }); if (!U.ok) throw new Error("Failed to fetch videos"); const H = ((await U.json()).videos || []).map(se => ({ ...se, thumbnail: o(se) })); f(se => ({ ...se, [j]: H })) } catch (U) { console.error("Error loading videos:", U); const re = { fire: [{ id: "fire_1", title: "지하철 화재 발생 시 초기 대응", description: "지하철에서 화재가 발생했을 때 승무원이 취해야 할 초기 대응 방법을 학습합니다.", youtubeId: "dQw4w9WgXcQ", videoType: "youtube", duration: "5:30", thumbnail: "https://img.youtube.com/vi/dQw4w9WgXcQ/maxresdefault.jpg", createdAt: new Date().toISOString() }], safety: [{ id: "safety_1", title: "지하철 안전운행 기본 수칙", description: "지하철을 안전하게 운행하기 위한 기본적인 수칙과 절차를 학습합니다.", youtubeId: "dQw4w9WgXcQ", videoType: "youtube", duration: "8:20", thumbnail: "https://img.youtube.com/vi/dQw4w9WgXcQ/maxresdefault.jpg", createdAt: new Date().toISOString() }], emergency: [] }; f(H => ({ ...H, [j]: (re[j] || []).map(se => ({ ...se, thumbnail: o(se) })) })) } }, G = j => { const U = j.target.files?.[0]; if (U) { if (!U.type.startsWith("video/")) { alert("비디오 파일만 업로드 가능합니다."); return } if (U.size > 100 * 1024 * 1024) { alert("파일 크기는 100MB를 초과할 수 없습니다."); return } P(U); const re = document.createElement("video"); re.src = URL.createObjectURL(U), re.onloadedmetadata = () => { const H = Math.floor(re.duration), se = Math.floor(H / 60), de = H % 60; C(q => ({ ...q, duration: `${se}:${de.toString().padStart(2, "0")}` })), URL.revokeObjectURL(re.src) } } }, oe = async j => { M(!0), O(0); try { const U = new FormData; U.append("file", j), U.append("categoryId", p); const H = await (await fetch(`https://${Re}.supabase.co/functions/v1/make-server-a8898ff1/upload-video`, { method: "POST", headers: { Authorization: `Bearer ${$e}`, cache: "no-store" }, body: U })).json(); if (H.success) { if (H.url) return H.url; throw new Error("업로드 응답에 파일 URL이 없습니다.") } else throw new Error(H.error || "파일 업로드에 실패했습니다.") } catch (U) { throw console.error("Error uploading file:", U), U } finally { M(!1), O(0) } }, ae = async j => { if (j.preventDefault(), !!p) { if (R === "youtube" && !k.youtubeId) { alert("YouTube URL 또는 ID를 입력해주세요."); return } if (R === "local" && !T && !E) { alert("업로드할 비디오 파일을 선택해주세요."); return } try { const U = k.title.trim(), re = k.description.trim(), H = k.duration.trim(), se = R === "youtube" ? $(k.youtubeId.trim()) : ""; let de = E?.videoUrl || "", q = E?.thumbnail || ""; if (R === "local") T && (de = await oe(T)), q = E?.thumbnail || t; else if (R === "youtube") { if (!se) { alert("YouTube 영상 ID를 확인해주세요."); return } q = s(se) } const le = E ? `https://${Re}.supabase.co/functions/v1/make-server-a8898ff1/videos/${p}/${E.id}` : `https://${Re}.supabase.co/functions/v1/make-server-a8898ff1/videos`, ve = E ? "PUT" : "POST", be = { title: U, description: re, duration: H, videoType: R, thumbnail: q }; let je; if (E) { const nt = { ...be }; R === "local" ? de && (nt.videoUrl = de) : nt.youtubeId = se, je = nt } else { const nt = { ...be }; R === "local" ? nt.videoUrl = de : nt.youtubeId = se, je = { categoryId: p, video: nt } } const Xe = await (await fetch(le, { method: ve, cache: "no-store", headers: { "Content-Type": "application/json", Authorization: `Bearer ${$e}`, "Cache-Control": "no-cache" }, body: JSON.stringify(je) })).json(); Xe.success ? (await K(p), r(), S(!1), ne()) : alert(Xe.error || "영상 저장에 실패했습니다.") } catch (U) { console.error("Error saving video:", U), alert("영상 저장 중 오류가 발생했습니다.") } } }, ue = async j => { if (p && confirm("정말로 이 영상을 삭제하시겠습니까?")) try { const re = await (await fetch(`https://${Re}.supabase.co/functions/v1/make-server-a8898ff1/videos/${p}/${j}`, { method: "DELETE", cache: "no-store", headers: { Authorization: `Bearer ${$e}`, "Cache-Control": "no-cache" } })).json(); re.success ? (await K(p), r()) : alert(re.error || "영상 삭제에 실패했습니다.") } catch (U) { console.error("Error deleting video:", U), alert("영상 삭제 중 오류가 발생했습니다.") } }, te = j => { b(j), C({ title: j.title, description: j.description, youtubeId: j.youtubeId || "", duration: j.duration, videoType: j.videoType }), L(j.videoType), P(null), O(0), M(!1), S(!0) }, ne = () => { b(null), C({ title: "", description: "", youtubeId: "", duration: "", videoType: "youtube" }), P(null), L("youtube"), O(0), M(!1) }, $ = j => { const U = j.match(/(?:youtube\.com\/watch\?v=|youtu\.be\/|youtube\.com\/embed\/)([^&\n?#]+)/); return U ? U[1] : j }, ee = j => { if (j.includes(":")) return j; const U = parseInt(j); if (!isNaN(U)) { const re = Math.floor(U / 60), H = U % 60; return `${re}:${H.toString().padStart(2, "0")}` } return j }; if (v) return d.jsx(ht, { children: d.jsx(xt, { className: "flex items-center justify-center py-12", children: d.jsxs("div", { className: "text-center", children: [d.jsx("div", { className: "animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600 mx-auto mb-4" }), d.jsx("p", { children: "데이터를 불러오는 중..." })] }) }) }); const X = p ? u[p] || [] : []; return d.jsx("div", { className: "space-y-6", children: d.jsxs(ht, { children: [d.jsxs(qt, { children: [d.jsx(Gt, { children: "영상 관리" }), d.jsx(Ar, { children: "카테고리별 교육 영상을 추가, 수정, 삭제할 수 있습니다." })] }), d.jsxs(xt, { children: [d.jsxs("div", { className: "flex items-center justify-between mb-6", children: [d.jsxs("div", { className: "flex items-center space-x-4", children: [d.jsx(Qe, { htmlFor: "category-select", children: "카테고리:" }), d.jsxs(oE, { value: p, onValueChange: m, children: [d.jsx(aE, { className: "w-64", children: d.jsx(iE, { placeholder: "카테고리를 선택하세요" }) }), d.jsx(lE, { children: a.map(j => d.jsx(cE, { value: j.id, children: j.title }, j.id)) })] })] }), d.jsxs(kd, { open: _, onOpenChange: S, children: [d.jsx(Ed, { asChild: !0, children: d.jsxs(Ne, { onClick: ne, disabled: !p, children: [d.jsx(nd, { className: "h-4 w-4 mr-2" }), "새 영상 추가"] }) }), d.jsxs(jd, { className: "max-w-2xl", children: [d.jsxs(Cd, { children: [d.jsx(Td, { children: E ? "영상 수정" : "새 영상 추가" }), d.jsx(Pd, { children: E ? "영상 정보를 수정합니다." : "새로운 교육 영상을 추가합니다." })] }), d.jsxs("form", { onSubmit: ae, className: "space-y-6", children: [d.jsxs("div", { className: "space-y-4", children: [d.jsxs("div", { children: [d.jsx(Qe, { htmlFor: "title", children: "영상 제목" }), d.jsx(wt, { id: "title", value: k.title, onChange: j => C(U => ({ ...U, title: j.target.value })), placeholder: "영상 제목을 입력하세요", required: !0 })] }), d.jsxs("div", { children: [d.jsx(Qe, { htmlFor: "description", children: "영상 설명" }), d.jsx(av, { id: "description", value: k.description, onChange: j => C(U => ({ ...U, description: j.target.value })), placeholder: "영상에 대한 설명을 입력하세요", rows: 3, required: !0 })] })] }), !E && d.jsxs("div", { children: [d.jsx(Qe, { children: "영상 업로드 방법" }), d.jsxs(ov, { value: R, onValueChange: j => L(j), className: "mt-2", children: [d.jsxs(iv, { className: "grid w-full grid-cols-2", children: [d.jsxs(Ns, { value: "youtube", className: "flex items-center gap-2", children: [d.jsx(Yc, { className: "w-4 h-4" }), "YouTube 링크"] }), d.jsxs(Ns, { value: "local", className: "flex items-center gap-2", children: [d.jsx(la, { className: "w-4 h-4" }), "파일 업로드"] })] }), d.jsxs(Ts, { value: "youtube", className: "space-y-4 mt-4", children: [d.jsxs(Iu, { children: [d.jsx(qp, { className: "h-4 w-4" }), d.jsx(Du, { children: "YouTube 영상 URL이나 비디오 ID를 입력하세요. 공개 또는 '링크로 공유 가능한' 영상만 재생 가능합니다." })] }), d.jsxs("div", { children: [d.jsx(Qe, { htmlFor: "youtubeId", children: "YouTube 링크 또는 ID" }), d.jsx(wt, { id: "youtubeId", value: k.youtubeId, onChange: j => C(U => ({ ...U, youtubeId: $(j.target.value) })), placeholder: "https://www.youtube.com/watch?v=VIDEO_ID 또는 VIDEO_ID", required: R === "youtube" })] })] }), d.jsxs(Ts, { value: "local", className: "space-y-4 mt-4", children: [d.jsxs(Iu, { children: [d.jsx(qp, { className: "h-4 w-4" }), d.jsx(Du, { children: "MP4, MOV, AVI 등의 비디오 파일을 업로드하세요. 최대 파일 크기: 50MB" })] }), d.jsxs("div", { children: [d.jsx(Qe, { htmlFor: "videoFile", children: "비디오 파일" }), d.jsx(wt, { id: "videoFile", type: "file", accept: "video/*", onChange: G, required: R === "local" && !E, className: "cursor-pointer" }), T && d.jsx("div", { className: "mt-2 p-3 bg-muted rounded-lg", children: d.jsxs("div", { className: "flex items-center gap-2 text-sm", children: [d.jsx(la, { className: "w-4 h-4" }), d.jsx("span", { children: T.name }), d.jsxs(yn, { variant: "outline", children: [(T.size / (1024 * 1024)).toFixed(1), " MB"] })] }) })] })] })] })] }), E && d.jsxs("div", { children: [d.jsx(Qe, { children: "영상 타입" }), d.jsx("div", { className: "mt-2 p-3 bg-muted rounded-lg", children: d.jsx("div", { className: "flex items-center gap-2", children: E.videoType === "youtube" ? d.jsxs(d.Fragment, { children: [d.jsx(Yc, { className: "w-4 h-4" }), d.jsx("span", { children: "YouTube 영상" })] }) : d.jsxs(d.Fragment, { children: [d.jsx(la, { className: "w-4 h-4" }), d.jsx("span", { children: "업로드된 파일" })] }) }) }), E.videoType === "youtube" && d.jsxs("div", { className: "mt-4", children: [d.jsx(Qe, { htmlFor: "youtubeId", children: "YouTube 링크 또는 ID" }), d.jsx(wt, { id: "youtubeId", value: k.youtubeId, onChange: j => C(U => ({ ...U, youtubeId: $(j.target.value) })), placeholder: "YouTube URL 또는 비디오 ID", required: !0 })] })] }), d.jsxs("div", { children: [d.jsx(Qe, { htmlFor: "duration", children: "영상 길이" }), d.jsx(wt, { id: "duration", value: k.duration, onChange: j => C(U => ({ ...U, duration: j.target.value })), placeholder: "예: 10:30 또는 630 (초)", required: !0 }), d.jsx("p", { className: "text-xs text-muted-foreground mt-1", children: "로컬 파일의 경우 자동으로 감지됩니다." })] }), V && d.jsxs("div", { className: "space-y-2", children: [d.jsxs("div", { className: "flex items-center justify-between text-sm", children: [d.jsx("span", { children: "파일 업로드 중..." }), d.jsxs("span", { children: [I, "%"] })] }), d.jsx(Is, { value: I, className: "w-full" })] }), d.jsxs(Nd, { children: [d.jsx(Ne, { type: "button", variant: "outline", onClick: () => S(!1), disabled: V, children: "취소" }), d.jsx(Ne, { type: "submit", disabled: V, children: V ? d.jsxs(d.Fragment, { children: [d.jsx(bg, { className: "w-4 h-4 mr-2 animate-spin" }), "업로드 중..."] }) : E ? "수정" : "추가" })] })] })] })] })] }), p ? d.jsx("div", { className: "rounded-md border", children: d.jsxs(Mo, { children: [d.jsx(Uo, { children: d.jsxs(Rt, { children: [d.jsx(Ue, { children: "썸네일" }), d.jsx(Ue, { children: "제목" }), d.jsx(Ue, { children: "설명" }), d.jsx(Ue, { children: "타입" }), d.jsx(Ue, { children: "길이" }), d.jsx(Ue, { children: "등록일" }), d.jsx(Ue, { children: "작업" })] }) }), d.jsx(zo, { children: X.length === 0 ? d.jsx(Rt, { children: d.jsx(Ie, { colSpan: 7, className: "text-center py-8 text-gray-500", children: "등록된 영상이 없습니다." }) }) : X.map(j => { const U = o(j); return d.jsxs(Rt, { children: [d.jsx(Ie, { children: d.jsx("div", { className: "flex items-center space-x-2", children: d.jsx("img", { src: U, alt: j.title, className: "w-16 h-9 object-cover rounded", onError: re => { re.currentTarget.src = t } }) }) }), d.jsx(Ie, { className: "font-medium max-w-xs", children: d.jsx("div", { className: "truncate", title: j.title, children: j.title }) }), d.jsx(Ie, { className: "max-w-xs", children: d.jsx("div", { className: "truncate text-sm text-gray-600", title: j.description, children: j.description }) }), d.jsx(Ie, { children: d.jsx("div", { className: "flex items-center gap-2", children: j.videoType === "youtube" ? d.jsxs(d.Fragment, { children: [d.jsx(Yc, { className: "w-4 h-4 text-red-600" }), d.jsx("span", { className: "text-xs", children: "YouTube" })] }) : d.jsxs(d.Fragment, { children: [d.jsx(la, { className: "w-4 h-4 text-blue-600" }), d.jsx("span", { className: "text-xs", children: "로컬" })] }) }) }), d.jsx(Ie, { children: d.jsx(yn, { variant: "outline", children: ee(j.duration) }) }), d.jsx(Ie, { className: "text-sm text-gray-600", children: new Date(j.createdAt).toLocaleDateString("ko-KR") }), d.jsx(Ie, { children: d.jsxs("div", { className: "flex items-center space-x-2", children: [j.videoType === "youtube" && j.youtubeId && d.jsx(Ne, { variant: "outline", size: "sm", onClick: () => window.open(`https://www.youtube.com/watch?v=${j.youtubeId}`, "_blank"), title: "YouTube에서 보기", children: d.jsx(wu, { className: "h-3 w-3" }) }), j.videoType === "local" && j.videoUrl && d.jsx(Ne, { variant: "outline", size: "sm", onClick: () => window.open(j.videoUrl, "_blank"), title: "영상 보기", children: d.jsx(wu, { className: "h-3 w-3" }) }), d.jsx(Ne, { variant: "outline", size: "sm", onClick: () => te(j), title: "수정", children: d.jsx(rd, { className: "h-3 w-3" }) }), d.jsx(Ne, { variant: "outline", size: "sm", onClick: () => ue(j.id), className: "text-red-600 hover:text-red-700", title: "삭제", children: d.jsx(sd, { className: "h-3 w-3" }) })] }) })] }, j.id) }) })] }) }) : d.jsxs("div", { className: "text-center py-12 text-gray-500", children: [d.jsx(kg, { className: "h-12 w-12 mx-auto mb-4 text-gray-300" }), d.jsx("p", { children: "카테고리를 선택해 주세요." })] })] })] }) }) } const OE = "modulepreload", IE = function (r) { return "/" + r }, wm = {}, Yo = function (t, s, o) { let a = Promise.resolve(); if (s && s.length > 0) { let u = function (m) { return Promise.all(m.map(v => Promise.resolve(v).then(y => ({ status: "fulfilled", value: y }), y => ({ status: "rejected", reason: y })))) }; document.getElementsByTagName("link"); const f = document.querySelector("meta[property=csp-nonce]"), p = f?.nonce || f?.getAttribute("nonce"); a = u(s.map(m => { if (m = IE(m), m in wm) return; wm[m] = !0; const v = m.endsWith(".css"), y = v ? '[rel="stylesheet"]' : ""; if (document.querySelector(`link[href="${m}"]${y}`)) return; const _ = document.createElement("link"); if (_.rel = v ? "stylesheet" : OE, v || (_.as = "script"), _.crossOrigin = "", _.href = m, p && _.setAttribute("nonce", p), document.head.appendChild(_), v) return new Promise((S, E) => { _.addEventListener("load", S), _.addEventListener("error", () => E(new Error(`Unable to preload CSS for ${m}`))) }) })) } function l(u) { const f = new Event("vite:preloadError", { cancelable: !0 }); if (f.payload = u, window.dispatchEvent(f), !f.defaultPrevented) throw u } return a.then(u => { for (const f of u || []) f.status === "rejected" && l(f.reason); return t().catch(l) }) }, DE = r => { let t; return r ? t = r : typeof fetch > "u" ? t = (...s) => Yo(async () => { const { default: o } = await Promise.resolve().then(() => Ws); return { default: o } }, void 0).then(({ default: o }) => o(...s)) : t = fetch, (...s) => t(...s) }; class Rd extends Error { constructor(t, s = "FunctionsError", o) { super(t), this.name = s, this.context = o } } class xm extends Rd { constructor(t) { super("Failed to send a request to the Edge Function", "FunctionsFetchError", t) } } class bm extends Rd { constructor(t) { super("Relay Error invoking the Edge Function", "FunctionsRelayError", t) } } class _m extends Rd { constructor(t) { super("Edge Function returned a non-2xx status code", "FunctionsHttpError", t) } } var $u; (function (r) { r.Any = "any", r.ApNortheast1 = "ap-northeast-1", r.ApNortheast2 = "ap-northeast-2", r.ApSouth1 = "ap-south-1", r.ApSoutheast1 = "ap-southeast-1", r.ApSoutheast2 = "ap-southeast-2", r.CaCentral1 = "ca-central-1", r.EuCentral1 = "eu-central-1", r.EuWest1 = "eu-west-1", r.EuWest2 = "eu-west-2", r.EuWest3 = "eu-west-3", r.SaEast1 = "sa-east-1", r.UsEast1 = "us-east-1", r.UsWest1 = "us-west-1", r.UsWest2 = "us-west-2" })($u || ($u = {})); var $E = function (r, t, s, o) { function a(l) { return l instanceof s ? l : new s(function (u) { u(l) }) } return new (s || (s = Promise))(function (l, u) { function f(v) { try { m(o.next(v)) } catch (y) { u(y) } } function p(v) { try { m(o.throw(v)) } catch (y) { u(y) } } function m(v) { v.done ? l(v.value) : a(v.value).then(f, p) } m((o = o.apply(r, t || [])).next()) }) }; class LE { constructor(t, { headers: s = {}, customFetch: o, region: a = $u.Any } = {}) { this.url = t, this.headers = s, this.region = a, this.fetch = DE(o) } setAuth(t) { this.headers.Authorization = `Bearer ${t}` } invoke(t) { return $E(this, arguments, void 0, function* (s, o = {}) { var a; try { const { headers: l, method: u, body: f, signal: p } = o; let m = {}, { region: v } = o; v || (v = this.region); const y = new URL(`${this.url}/${s}`); v && v !== "any" && (m["x-region"] = v, y.searchParams.set("forceFunctionRegion", v)); let _; f && (l && !Object.prototype.hasOwnProperty.call(l, "Content-Type") || !l) && (typeof Blob < "u" && f instanceof Blob || f instanceof ArrayBuffer ? (m["Content-Type"] = "application/octet-stream", _ = f) : typeof f == "string" ? (m["Content-Type"] = "text/plain", _ = f) : typeof FormData < "u" && f instanceof FormData ? _ = f : (m["Content-Type"] = "application/json", _ = JSON.stringify(f))); const S = yield this.fetch(y.toString(), { method: u || "POST", headers: Object.assign(Object.assign(Object.assign({}, m), this.headers), l), body: _, signal: p }).catch(C => { throw C.name === "AbortError" ? C : new xm(C) }), E = S.headers.get("x-relay-error"); if (E && E === "true") throw new bm(S); if (!S.ok) throw new _m(S); let b = ((a = S.headers.get("Content-Type")) !== null && a !== void 0 ? a : "text/plain").split(";")[0].trim(), k; return b === "application/json" ? k = yield S.json() : b === "application/octet-stream" ? k = yield S.blob() : b === "text/event-stream" ? k = S : b === "multipart/form-data" ? k = yield S.formData() : k = yield S.text(), { data: k, error: null, response: S } } catch (l) { return l instanceof Error && l.name === "AbortError" ? { data: null, error: new xm(l) } : { data: null, error: l, response: l instanceof _m || l instanceof bm ? l.context : void 0 } } }) } } var ut = {}, ms = {}, gs = {}, vs = {}, ys = {}, ws = {}, ME = function () { if (typeof self < "u") return self; if (typeof window < "u") return window; if (typeof global < "u") return global; throw new Error("unable to locate global object") }, Ls = ME(); const UE = Ls.fetch, Ay = Ls.fetch.bind(Ls), Oy = Ls.Headers, zE = Ls.Request, FE = Ls.Response, Ws = Object.freeze(Object.defineProperty({ __proto__: null, Headers: Oy, Request: zE, Response: FE, default: Ay, fetch: UE }, Symbol.toStringTag, { value: "Module" })), BE = Yw(Ws); var ma = {}, Sm; function Iy() { if (Sm) return ma; Sm = 1, Object.defineProperty(ma, "__esModule", { value: !0 }); class r extends Error { constructor(s) { super(s.message), this.name = "PostgrestError", this.details = s.details, this.hint = s.hint, this.code = s.code } } return ma.default = r, ma } var km; function Dy() { if (km) return ws; km = 1; var r = ws && ws.__importDefault || function (a) { return a && a.__esModule ? a : { default: a } }; Object.defineProperty(ws, "__esModule", { value: !0 }); const t = r(BE), s = r(Iy()); class o { constructor(l) { var u, f; this.shouldThrowOnError = !1, this.method = l.method, this.url = l.url, this.headers = new Headers(l.headers), this.schema = l.schema, this.body = l.body, this.shouldThrowOnError = (u = l.shouldThrowOnError) !== null && u !== void 0 ? u : !1, this.signal = l.signal, this.isMaybeSingle = (f = l.isMaybeSingle) !== null && f !== void 0 ? f : !1, l.fetch ? this.fetch = l.fetch : typeof fetch > "u" ? this.fetch = t.default : this.fetch = fetch } throwOnError() { return this.shouldThrowOnError = !0, this } setHeader(l, u) { return this.headers = new Headers(this.headers), this.headers.set(l, u), this } then(l, u) { this.schema === void 0 || (["GET", "HEAD"].includes(this.method) ? this.headers.set("Accept-Profile", this.schema) : this.headers.set("Content-Profile", this.schema)), this.method !== "GET" && this.method !== "HEAD" && this.headers.set("Content-Type", "application/json"); const f = this.fetch; let p = f(this.url.toString(), { method: this.method, headers: this.headers, body: JSON.stringify(this.body), signal: this.signal }).then(async m => { var v, y, _, S; let E = null, b = null, k = null, C = m.status, T = m.statusText; if (m.ok) { if (this.method !== "HEAD") { const V = await m.text(); V === "" || (this.headers.get("Accept") === "text/csv" || this.headers.get("Accept") && (!((v = this.headers.get("Accept")) === null || v === void 0) && v.includes("application/vnd.pgrst.plan+text")) ? b = V : b = JSON.parse(V)) } const I = (y = this.headers.get("Prefer")) === null || y === void 0 ? void 0 : y.match(/count=(exact|planned|estimated)/), O = (_ = m.headers.get("content-range")) === null || _ === void 0 ? void 0 : _.split("/"); I && O && O.length > 1 && (k = parseInt(O[1])), this.isMaybeSingle && this.method === "GET" && Array.isArray(b) && (b.length > 1 ? (E = { code: "PGRST116", details: `Results contain ${b.length} rows, application/vnd.pgrst.object+json requires 1 row`, hint: null, message: "JSON object requested, multiple (or no) rows returned" }, b = null, k = null, C = 406, T = "Not Acceptable") : b.length === 1 ? b = b[0] : b = null) } else { const I = await m.text(); try { E = JSON.parse(I), Array.isArray(E) && m.status === 404 && (b = [], E = null, C = 200, T = "OK") } catch { m.status === 404 && I === "" ? (C = 204, T = "No Content") : E = { message: I } } if (E && this.isMaybeSingle && (!((S = E?.details) === null || S === void 0) && S.includes("0 rows")) && (E = null, C = 200, T = "OK"), E && this.shouldThrowOnError) throw new s.default(E) } return { error: E, data: b, count: k, status: C, statusText: T } }); return this.shouldThrowOnError || (p = p.catch(m => { var v, y, _; return { error: { message: `${(v = m?.name) !== null && v !== void 0 ? v : "FetchError"}: ${m?.message}`, details: `${(y = m?.stack) !== null && y !== void 0 ? y : ""}`, hint: "", code: `${(_ = m?.code) !== null && _ !== void 0 ? _ : ""}` }, data: null, count: null, status: 0, statusText: "" } })), p.then(l, u) } returns() { return this } overrideTypes() { return this } } return ws.default = o, ws } var Em; function $y() { if (Em) return ys; Em = 1; var r = ys && ys.__importDefault || function (o) { return o && o.__esModule ? o : { default: o } }; Object.defineProperty(ys, "__esModule", { value: !0 }); const t = r(Dy()); class s extends t.default { select(a) { let l = !1; const u = (a ?? "*").split("").map(f => /\s/.test(f) && !l ? "" : (f === '"' && (l = !l), f)).join(""); return this.url.searchParams.set("select", u), this.headers.append("Prefer", "return=representation"), this } order(a, { ascending: l = !0, nullsFirst: u, foreignTable: f, referencedTable: p = f } = {}) { const m = p ? `${p}.order` : "order", v = this.url.searchParams.get(m); return this.url.searchParams.set(m, `${v ? `${v},` : ""}${a}.${l ? "asc" : "desc"}${u === void 0 ? "" : u ? ".nullsfirst" : ".nullslast"}`), this } limit(a, { foreignTable: l, referencedTable: u = l } = {}) { const f = typeof u > "u" ? "limit" : `${u}.limit`; return this.url.searchParams.set(f, `${a}`), this } range(a, l, { foreignTable: u, referencedTable: f = u } = {}) { const p = typeof f > "u" ? "offset" : `${f}.offset`, m = typeof f > "u" ? "limit" : `${f}.limit`; return this.url.searchParams.set(p, `${a}`), this.url.searchParams.set(m, `${l - a + 1}`), this } abortSignal(a) { return this.signal = a, this } single() { return this.headers.set("Accept", "application/vnd.pgrst.object+json"), this } maybeSingle() { return this.method === "GET" ? this.headers.set("Accept", "application/json") : this.headers.set("Accept", "application/vnd.pgrst.object+json"), this.isMaybeSingle = !0, this } csv() { return this.headers.set("Accept", "text/csv"), this } geojson() { return this.headers.set("Accept", "application/geo+json"), this } explain({ analyze: a = !1, verbose: l = !1, settings: u = !1, buffers: f = !1, wal: p = !1, format: m = "text" } = {}) { var v; const y = [a ? "analyze" : null, l ? "verbose" : null, u ? "settings" : null, f ? "buffers" : null, p ? "wal" : null].filter(Boolean).join("|"), _ = (v = this.headers.get("Accept")) !== null && v !== void 0 ? v : "application/json"; return this.headers.set("Accept", `application/vnd.pgrst.plan+${m}; for="${_}"; options=${y};`), m === "json" ? this : this } rollback() { return this.headers.append("Prefer", "tx=rollback"), this } returns() { return this } maxAffected(a) { return this.headers.append("Prefer", "handling=strict"), this.headers.append("Prefer", `max-affected=${a}`), this } } return ys.default = s, ys } var jm; function Ad() { if (jm) return vs; jm = 1; var r = vs && vs.__importDefault || function (o) { return o && o.__esModule ? o : { default: o } }; Object.defineProperty(vs, "__esModule", { value: !0 }); const t = r($y()); class s extends t.default { eq(a, l) { return this.url.searchParams.append(a, `eq.${l}`), this } neq(a, l) { return this.url.searchParams.append(a, `neq.${l}`), this } gt(a, l) { return this.url.searchParams.append(a, `gt.${l}`), this } gte(a, l) { return this.url.searchParams.append(a, `gte.${l}`), this } lt(a, l) { return this.url.searchParams.append(a, `lt.${l}`), this } lte(a, l) { return this.url.searchParams.append(a, `lte.${l}`), this } like(a, l) { return this.url.searchParams.append(a, `like.${l}`), this } likeAllOf(a, l) { return this.url.searchParams.append(a, `like(all).{${l.join(",")}}`), this } likeAnyOf(a, l) { return this.url.searchParams.append(a, `like(any).{${l.join(",")}}`), this } ilike(a, l) { return this.url.searchParams.append(a, `ilike.${l}`), this } ilikeAllOf(a, l) { return this.url.searchParams.append(a, `ilike(all).{${l.join(",")}}`), this } ilikeAnyOf(a, l) { return this.url.searchParams.append(a, `ilike(any).{${l.join(",")}}`), this } is(a, l) { return this.url.searchParams.append(a, `is.${l}`), this } in(a, l) { const u = Array.from(new Set(l)).map(f => typeof f == "string" && new RegExp("[,()]").test(f) ? `"${f}"` : `${f}`).join(","); return this.url.searchParams.append(a, `in.(${u})`), this } contains(a, l) { return typeof l == "string" ? this.url.searchParams.append(a, `cs.${l}`) : Array.isArray(l) ? this.url.searchParams.append(a, `cs.{${l.join(",")}}`) : this.url.searchParams.append(a, `cs.${JSON.stringify(l)}`), this } containedBy(a, l) { return typeof l == "string" ? this.url.searchParams.append(a, `cd.${l}`) : Array.isArray(l) ? this.url.searchParams.append(a, `cd.{${l.join(",")}}`) : this.url.searchParams.append(a, `cd.${JSON.stringify(l)}`), this } rangeGt(a, l) { return this.url.searchParams.append(a, `sr.${l}`), this } rangeGte(a, l) { return this.url.searchParams.append(a, `nxl.${l}`), this } rangeLt(a, l) { return this.url.searchParams.append(a, `sl.${l}`), this } rangeLte(a, l) { return this.url.searchParams.append(a, `nxr.${l}`), this } rangeAdjacent(a, l) { return this.url.searchParams.append(a, `adj.${l}`), this } overlaps(a, l) { return typeof l == "string" ? this.url.searchParams.append(a, `ov.${l}`) : this.url.searchParams.append(a, `ov.{${l.join(",")}}`), this } textSearch(a, l, { config: u, type: f } = {}) { let p = ""; f === "plain" ? p = "pl" : f === "phrase" ? p = "ph" : f === "websearch" && (p = "w"); const m = u === void 0 ? "" : `(${u})`; return this.url.searchParams.append(a, `${p}fts${m}.${l}`), this } match(a) { return Object.entries(a).forEach(([l, u]) => { this.url.searchParams.append(l, `eq.${u}`) }), this } not(a, l, u) { return this.url.searchParams.append(a, `not.${l}.${u}`), this } or(a, { foreignTable: l, referencedTable: u = l } = {}) { const f = u ? `${u}.or` : "or"; return this.url.searchParams.append(f, `(${a})`), this } filter(a, l, u) { return this.url.searchParams.append(a, `${l}.${u}`), this } } return vs.default = s, vs } var Cm; function Ly() { if (Cm) return gs; Cm = 1; var r = gs && gs.__importDefault || function (o) { return o && o.__esModule ? o : { default: o } }; Object.defineProperty(gs, "__esModule", { value: !0 }); const t = r(Ad()); class s { constructor(a, { headers: l = {}, schema: u, fetch: f }) { this.url = a, this.headers = new Headers(l), this.schema = u, this.fetch = f } select(a, l) { const { head: u = !1, count: f } = l ?? {}, p = u ? "HEAD" : "GET"; let m = !1; const v = (a ?? "*").split("").map(y => /\s/.test(y) && !m ? "" : (y === '"' && (m = !m), y)).join(""); return this.url.searchParams.set("select", v), f && this.headers.append("Prefer", `count=${f}`), new t.default({ method: p, url: this.url, headers: this.headers, schema: this.schema, fetch: this.fetch }) } insert(a, { count: l, defaultToNull: u = !0 } = {}) { var f; const p = "POST"; if (l && this.headers.append("Prefer", `count=${l}`), u || this.headers.append("Prefer", "missing=default"), Array.isArray(a)) { const m = a.reduce((v, y) => v.concat(Object.keys(y)), []); if (m.length > 0) { const v = [...new Set(m)].map(y => `"${y}"`); this.url.searchParams.set("columns", v.join(",")) } } return new t.default({ method: p, url: this.url, headers: this.headers, schema: this.schema, body: a, fetch: (f = this.fetch) !== null && f !== void 0 ? f : fetch }) } upsert(a, { onConflict: l, ignoreDuplicates: u = !1, count: f, defaultToNull: p = !0 } = {}) { var m; const v = "POST"; if (this.headers.append("Prefer", `resolution=${u ? "ignore" : "merge"}-duplicates`), l !== void 0 && this.url.searchParams.set("on_conflict", l), f && this.headers.append("Prefer", `count=${f}`), p || this.headers.append("Prefer", "missing=default"), Array.isArray(a)) { const y = a.reduce((_, S) => _.concat(Object.keys(S)), []); if (y.length > 0) { const _ = [...new Set(y)].map(S => `"${S}"`); this.url.searchParams.set("columns", _.join(",")) } } return new t.default({ method: v, url: this.url, headers: this.headers, schema: this.schema, body: a, fetch: (m = this.fetch) !== null && m !== void 0 ? m : fetch }) } update(a, { count: l } = {}) { var u; const f = "PATCH"; return l && this.headers.append("Prefer", `count=${l}`), new t.default({ method: f, url: this.url, headers: this.headers, schema: this.schema, body: a, fetch: (u = this.fetch) !== null && u !== void 0 ? u : fetch }) } delete({ count: a } = {}) { var l; const u = "DELETE"; return a && this.headers.append("Prefer", `count=${a}`), new t.default({ method: u, url: this.url, headers: this.headers, schema: this.schema, fetch: (l = this.fetch) !== null && l !== void 0 ? l : fetch }) } } return gs.default = s, gs } var Nm; function VE() { if (Nm) return ms; Nm = 1; var r = ms && ms.__importDefault || function (a) { return a && a.__esModule ? a : { default: a } }; Object.defineProperty(ms, "__esModule", { value: !0 }); const t = r(Ly()), s = r(Ad()); class o { constructor(l, { headers: u = {}, schema: f, fetch: p } = {}) { this.url = l, this.headers = new Headers(u), this.schemaName = f, this.fetch = p } from(l) { const u = new URL(`${this.url}/${l}`); return new t.default(u, { headers: new Headers(this.headers), schema: this.schemaName, fetch: this.fetch }) } schema(l) { return new o(this.url, { headers: this.headers, schema: l, fetch: this.fetch }) } rpc(l, u = {}, { head: f = !1, get: p = !1, count: m } = {}) { var v; let y; const _ = new URL(`${this.url}/rpc/${l}`); let S; f || p ? (y = f ? "HEAD" : "GET", Object.entries(u).filter(([b, k]) => k !== void 0).map(([b, k]) => [b, Array.isArray(k) ? `{${k.join(",")}}` : `${k}`]).forEach(([b, k]) => { _.searchParams.append(b, k) })) : (y = "POST", S = u); const E = new Headers(this.headers); return m && E.set("Prefer", `count=${m}`), new s.default({ method: y, url: _, headers: E, schema: this.schemaName, body: S, fetch: (v = this.fetch) !== null && v !== void 0 ? v : fetch }) } } return ms.default = o, ms } var Tm; function WE() { if (Tm) return ut; Tm = 1; var r = ut && ut.__importDefault || function (f) { return f && f.__esModule ? f : { default: f } }; Object.defineProperty(ut, "__esModule", { value: !0 }), ut.PostgrestError = ut.PostgrestBuilder = ut.PostgrestTransformBuilder = ut.PostgrestFilterBuilder = ut.PostgrestQueryBuilder = ut.PostgrestClient = void 0; const t = r(VE()); ut.PostgrestClient = t.default; const s = r(Ly()); ut.PostgrestQueryBuilder = s.default; const o = r(Ad()); ut.PostgrestFilterBuilder = o.default; const a = r($y()); ut.PostgrestTransformBuilder = a.default; const l = r(Dy()); ut.PostgrestBuilder = l.default; const u = r(Iy()); return ut.PostgrestError = u.default, ut.default = { PostgrestClient: t.default, PostgrestQueryBuilder: s.default, PostgrestFilterBuilder: o.default, PostgrestTransformBuilder: a.default, PostgrestBuilder: l.default, PostgrestError: u.default }, ut } var HE = WE(); const KE = Gu(HE), { PostgrestClient: qE, PostgrestQueryBuilder: vN, PostgrestFilterBuilder: yN, PostgrestTransformBuilder: wN, PostgrestBuilder: xN, PostgrestError: bN } = KE; class GE {
  static detectEnvironment() {
    var t; if (typeof WebSocket < "u") return { type: "native", constructor: WebSocket }; if (typeof globalThis < "u" && typeof globalThis.WebSocket < "u") return { type: "native", constructor: globalThis.WebSocket }; if (typeof global < "u" && typeof global.WebSocket < "u") return { type: "native", constructor: global.WebSocket }; if (typeof globalThis < "u" && typeof globalThis.WebSocketPair < "u" && typeof globalThis.WebSocket > "u") return { type: "cloudflare", error: "Cloudflare Workers detected. WebSocket clients are not supported in Cloudflare Workers.", workaround: "Use Cloudflare Workers WebSocket API for server-side WebSocket handling, or deploy to a different runtime." }; if (typeof globalThis < "u" && globalThis.EdgeRuntime || typeof navigator < "u" && (!((t = navigator.userAgent) === null || t === void 0) && t.includes("Vercel-Edge"))) return { type: "unsupported", error: "Edge runtime detected (Vercel Edge/Netlify Edge). WebSockets are not supported in edge functions.", workaround: "Use serverless functions or a different deployment target for WebSocket functionality." }; if (typeof process < "u") {
      const s = process.versions; if (s && s.node) {
        const o = s.node, a = parseInt(o.replace(/^v/, "").split(".")[0]); return a >= 22 ? typeof globalThis.WebSocket < "u" ? { type: "native", constructor: globalThis.WebSocket } : { type: "unsupported", error: `Node.js ${a} detected but native WebSocket not found.`, workaround: "Provide a WebSocket implementation via the transport option." } : {
          type: "unsupported", error: `Node.js ${a} detected without native WebSocket support.`, workaround: `For Node.js < 22, install "ws" package and provide it via the transport option:
import ws from "ws"
new RealtimeClient(url, { transport: ws })`}
      }
    } return { type: "unsupported", error: "Unknown JavaScript runtime without WebSocket support.", workaround: "Ensure you're running in a supported environment (browser, Node.js, Deno) or provide a custom WebSocket implementation." }
  } static getWebSocketConstructor() {
    const t = this.detectEnvironment(); if (t.constructor) return t.constructor; let s = t.error || "WebSocket not supported in this environment."; throw t.workaround && (s += `

Suggested solution: ${t.workaround}`), new Error(s)
  } static createWebSocket(t, s) { const o = this.getWebSocketConstructor(); return new o(t, s) } static isWebSocketSupported() { try { const t = this.detectEnvironment(); return t.type === "native" || t.type === "ws" } catch { return !1 } }
} const YE = "2.75.0", JE = `realtime-js/${YE}`, QE = "1.0.0", Lu = 1e4, XE = 1e3, ZE = 100; var Do; (function (r) { r[r.connecting = 0] = "connecting", r[r.open = 1] = "open", r[r.closing = 2] = "closing", r[r.closed = 3] = "closed" })(Do || (Do = {})); var it; (function (r) { r.closed = "closed", r.errored = "errored", r.joined = "joined", r.joining = "joining", r.leaving = "leaving" })(it || (it = {})); var sn; (function (r) { r.close = "phx_close", r.error = "phx_error", r.join = "phx_join", r.reply = "phx_reply", r.leave = "phx_leave", r.access_token = "access_token" })(sn || (sn = {})); var Mu; (function (r) { r.websocket = "websocket" })(Mu || (Mu = {})); var Tr; (function (r) { r.Connecting = "connecting", r.Open = "open", r.Closing = "closing", r.Closed = "closed" })(Tr || (Tr = {})); class ej { constructor() { this.HEADER_LENGTH = 1 } decode(t, s) { return t.constructor === ArrayBuffer ? s(this._binaryDecode(t)) : s(typeof t == "string" ? JSON.parse(t) : {}) } _binaryDecode(t) { const s = new DataView(t), o = new TextDecoder; return this._decodeBroadcast(t, s, o) } _decodeBroadcast(t, s, o) { const a = s.getUint8(1), l = s.getUint8(2); let u = this.HEADER_LENGTH + 2; const f = o.decode(t.slice(u, u + a)); u = u + a; const p = o.decode(t.slice(u, u + l)); u = u + l; const m = JSON.parse(o.decode(t.slice(u, t.byteLength))); return { ref: null, topic: f, event: p, payload: m } } } class My { constructor(t, s) { this.callback = t, this.timerCalc = s, this.timer = void 0, this.tries = 0, this.callback = t, this.timerCalc = s } reset() { this.tries = 0, clearTimeout(this.timer), this.timer = void 0 } scheduleTimeout() { clearTimeout(this.timer), this.timer = setTimeout(() => { this.tries = this.tries + 1, this.callback() }, this.timerCalc(this.tries + 1)) } } var Be; (function (r) { r.abstime = "abstime", r.bool = "bool", r.date = "date", r.daterange = "daterange", r.float4 = "float4", r.float8 = "float8", r.int2 = "int2", r.int4 = "int4", r.int4range = "int4range", r.int8 = "int8", r.int8range = "int8range", r.json = "json", r.jsonb = "jsonb", r.money = "money", r.numeric = "numeric", r.oid = "oid", r.reltime = "reltime", r.text = "text", r.time = "time", r.timestamp = "timestamp", r.timestamptz = "timestamptz", r.timetz = "timetz", r.tsrange = "tsrange", r.tstzrange = "tstzrange" })(Be || (Be = {})); const Pm = (r, t, s = {}) => { var o; const a = (o = s.skipTypes) !== null && o !== void 0 ? o : []; return t ? Object.keys(t).reduce((l, u) => (l[u] = tj(u, r, t, a), l), {}) : {} }, tj = (r, t, s, o) => { const a = t.find(f => f.name === r), l = a?.type, u = s[r]; return l && !o.includes(l) ? Uy(l, u) : Uu(u) }, Uy = (r, t) => { if (r.charAt(0) === "_") { const s = r.slice(1, r.length); return oj(t, s) } switch (r) { case Be.bool: return nj(t); case Be.float4: case Be.float8: case Be.int2: case Be.int4: case Be.int8: case Be.numeric: case Be.oid: return rj(t); case Be.json: case Be.jsonb: return sj(t); case Be.timestamp: return ij(t); case Be.abstime: case Be.date: case Be.daterange: case Be.int4range: case Be.int8range: case Be.money: case Be.reltime: case Be.text: case Be.time: case Be.timestamptz: case Be.timetz: case Be.tsrange: case Be.tstzrange: return Uu(t); default: return Uu(t) } }, Uu = r => r, nj = r => { switch (r) { case "t": return !0; case "f": return !1; default: return r } }, rj = r => { if (typeof r == "string") { const t = parseFloat(r); if (!Number.isNaN(t)) return t } return r }, sj = r => { if (typeof r == "string") try { return JSON.parse(r) } catch (t) { return console.log(`JSON parse error: ${t}`), r } return r }, oj = (r, t) => { if (typeof r != "string") return r; const s = r.length - 1, o = r[s]; if (r[0] === "{" && o === "}") { let l; const u = r.slice(1, s); try { l = JSON.parse("[" + u + "]") } catch { l = u ? u.split(",") : [] } return l.map(f => Uy(t, f)) } return r }, ij = r => typeof r == "string" ? r.replace(" ", "T") : r, zy = r => { let t = r; return t = t.replace(/^ws/i, "http"), t = t.replace(/(\/socket\/websocket|\/socket|\/websocket)\/?$/i, ""), t.replace(/\/+$/, "") + "/api/broadcast" }; class iu { constructor(t, s, o = {}, a = Lu) { this.channel = t, this.event = s, this.payload = o, this.timeout = a, this.sent = !1, this.timeoutTimer = void 0, this.ref = "", this.receivedResp = null, this.recHooks = [], this.refEvent = null } resend(t) { this.timeout = t, this._cancelRefEvent(), this.ref = "", this.refEvent = null, this.receivedResp = null, this.sent = !1, this.send() } send() { this._hasReceived("timeout") || (this.startTimeout(), this.sent = !0, this.channel.socket.push({ topic: this.channel.topic, event: this.event, payload: this.payload, ref: this.ref, join_ref: this.channel._joinRef() })) } updatePayload(t) { this.payload = Object.assign(Object.assign({}, this.payload), t) } receive(t, s) { var o; return this._hasReceived(t) && s((o = this.receivedResp) === null || o === void 0 ? void 0 : o.response), this.recHooks.push({ status: t, callback: s }), this } startTimeout() { if (this.timeoutTimer) return; this.ref = this.channel.socket._makeRef(), this.refEvent = this.channel._replyEventName(this.ref); const t = s => { this._cancelRefEvent(), this._cancelTimeout(), this.receivedResp = s, this._matchReceive(s) }; this.channel._on(this.refEvent, {}, t), this.timeoutTimer = setTimeout(() => { this.trigger("timeout", {}) }, this.timeout) } trigger(t, s) { this.refEvent && this.channel._trigger(this.refEvent, { status: t, response: s }) } destroy() { this._cancelRefEvent(), this._cancelTimeout() } _cancelRefEvent() { this.refEvent && this.channel._off(this.refEvent, {}) } _cancelTimeout() { clearTimeout(this.timeoutTimer), this.timeoutTimer = void 0 } _matchReceive({ status: t, response: s }) { this.recHooks.filter(o => o.status === t).forEach(o => o.callback(s)) } _hasReceived(t) { return this.receivedResp && this.receivedResp.status === t } } var Rm; (function (r) { r.SYNC = "sync", r.JOIN = "join", r.LEAVE = "leave" })(Rm || (Rm = {})); class $o { constructor(t, s) { this.channel = t, this.state = {}, this.pendingDiffs = [], this.joinRef = null, this.enabled = !1, this.caller = { onJoin: () => { }, onLeave: () => { }, onSync: () => { } }; const o = s?.events || { state: "presence_state", diff: "presence_diff" }; this.channel._on(o.state, {}, a => { const { onJoin: l, onLeave: u, onSync: f } = this.caller; this.joinRef = this.channel._joinRef(), this.state = $o.syncState(this.state, a, l, u), this.pendingDiffs.forEach(p => { this.state = $o.syncDiff(this.state, p, l, u) }), this.pendingDiffs = [], f() }), this.channel._on(o.diff, {}, a => { const { onJoin: l, onLeave: u, onSync: f } = this.caller; this.inPendingSyncState() ? this.pendingDiffs.push(a) : (this.state = $o.syncDiff(this.state, a, l, u), f()) }), this.onJoin((a, l, u) => { this.channel._trigger("presence", { event: "join", key: a, currentPresences: l, newPresences: u }) }), this.onLeave((a, l, u) => { this.channel._trigger("presence", { event: "leave", key: a, currentPresences: l, leftPresences: u }) }), this.onSync(() => { this.channel._trigger("presence", { event: "sync" }) }) } static syncState(t, s, o, a) { const l = this.cloneDeep(t), u = this.transformState(s), f = {}, p = {}; return this.map(l, (m, v) => { u[m] || (p[m] = v) }), this.map(u, (m, v) => { const y = l[m]; if (y) { const _ = v.map(k => k.presence_ref), S = y.map(k => k.presence_ref), E = v.filter(k => S.indexOf(k.presence_ref) < 0), b = y.filter(k => _.indexOf(k.presence_ref) < 0); E.length > 0 && (f[m] = E), b.length > 0 && (p[m] = b) } else f[m] = v }), this.syncDiff(l, { joins: f, leaves: p }, o, a) } static syncDiff(t, s, o, a) { const { joins: l, leaves: u } = { joins: this.transformState(s.joins), leaves: this.transformState(s.leaves) }; return o || (o = () => { }), a || (a = () => { }), this.map(l, (f, p) => { var m; const v = (m = t[f]) !== null && m !== void 0 ? m : []; if (t[f] = this.cloneDeep(p), v.length > 0) { const y = t[f].map(S => S.presence_ref), _ = v.filter(S => y.indexOf(S.presence_ref) < 0); t[f].unshift(..._) } o(f, v, p) }), this.map(u, (f, p) => { let m = t[f]; if (!m) return; const v = p.map(y => y.presence_ref); m = m.filter(y => v.indexOf(y.presence_ref) < 0), t[f] = m, a(f, m, p), m.length === 0 && delete t[f] }), t } static map(t, s) { return Object.getOwnPropertyNames(t).map(o => s(o, t[o])) } static transformState(t) { return t = this.cloneDeep(t), Object.getOwnPropertyNames(t).reduce((s, o) => { const a = t[o]; return "metas" in a ? s[o] = a.metas.map(l => (l.presence_ref = l.phx_ref, delete l.phx_ref, delete l.phx_ref_prev, l)) : s[o] = a, s }, {}) } static cloneDeep(t) { return JSON.parse(JSON.stringify(t)) } onJoin(t) { this.caller.onJoin = t } onLeave(t) { this.caller.onLeave = t } onSync(t) { this.caller.onSync = t } inPendingSyncState() { return !this.joinRef || this.joinRef !== this.channel._joinRef() } } var Am; (function (r) { r.ALL = "*", r.INSERT = "INSERT", r.UPDATE = "UPDATE", r.DELETE = "DELETE" })(Am || (Am = {})); var Lo; (function (r) { r.BROADCAST = "broadcast", r.PRESENCE = "presence", r.POSTGRES_CHANGES = "postgres_changes", r.SYSTEM = "system" })(Lo || (Lo = {})); var Pn; (function (r) { r.SUBSCRIBED = "SUBSCRIBED", r.TIMED_OUT = "TIMED_OUT", r.CLOSED = "CLOSED", r.CHANNEL_ERROR = "CHANNEL_ERROR" })(Pn || (Pn = {})); class Od { constructor(t, s = { config: {} }, o) { var a, l; if (this.topic = t, this.params = s, this.socket = o, this.bindings = {}, this.state = it.closed, this.joinedOnce = !1, this.pushBuffer = [], this.subTopic = t.replace(/^realtime:/i, ""), this.params.config = Object.assign({ broadcast: { ack: !1, self: !1 }, presence: { key: "", enabled: !1 }, private: !1 }, s.config), this.timeout = this.socket.timeout, this.joinPush = new iu(this, sn.join, this.params, this.timeout), this.rejoinTimer = new My(() => this._rejoinUntilConnected(), this.socket.reconnectAfterMs), this.joinPush.receive("ok", () => { this.state = it.joined, this.rejoinTimer.reset(), this.pushBuffer.forEach(u => u.send()), this.pushBuffer = [] }), this._onClose(() => { this.rejoinTimer.reset(), this.socket.log("channel", `close ${this.topic} ${this._joinRef()}`), this.state = it.closed, this.socket._remove(this) }), this._onError(u => { this._isLeaving() || this._isClosed() || (this.socket.log("channel", `error ${this.topic}`, u), this.state = it.errored, this.rejoinTimer.scheduleTimeout()) }), this.joinPush.receive("timeout", () => { this._isJoining() && (this.socket.log("channel", `timeout ${this.topic}`, this.joinPush.timeout), this.state = it.errored, this.rejoinTimer.scheduleTimeout()) }), this.joinPush.receive("error", u => { this._isLeaving() || this._isClosed() || (this.socket.log("channel", `error ${this.topic}`, u), this.state = it.errored, this.rejoinTimer.scheduleTimeout()) }), this._on(sn.reply, {}, (u, f) => { this._trigger(this._replyEventName(f), u) }), this.presence = new $o(this), this.broadcastEndpointURL = zy(this.socket.endPoint), this.private = this.params.config.private || !1, !this.private && (!((l = (a = this.params.config) === null || a === void 0 ? void 0 : a.broadcast) === null || l === void 0) && l.replay)) throw `tried to use replay on public channel '${this.topic}'. It must be a private channel.` } subscribe(t, s = this.timeout) { var o, a, l; if (this.socket.isConnected() || this.socket.connect(), this.state == it.closed) { const { config: { broadcast: u, presence: f, private: p } } = this.params, m = (a = (o = this.bindings.postgres_changes) === null || o === void 0 ? void 0 : o.map(S => S.filter)) !== null && a !== void 0 ? a : [], v = !!this.bindings[Lo.PRESENCE] && this.bindings[Lo.PRESENCE].length > 0 || ((l = this.params.config.presence) === null || l === void 0 ? void 0 : l.enabled) === !0, y = {}, _ = { broadcast: u, presence: Object.assign(Object.assign({}, f), { enabled: v }), postgres_changes: m, private: p }; this.socket.accessTokenValue && (y.access_token = this.socket.accessTokenValue), this._onError(S => t?.(Pn.CHANNEL_ERROR, S)), this._onClose(() => t?.(Pn.CLOSED)), this.updateJoinPayload(Object.assign({ config: _ }, y)), this.joinedOnce = !0, this._rejoin(s), this.joinPush.receive("ok", async ({ postgres_changes: S }) => { var E; if (this.socket.setAuth(), S === void 0) { t?.(Pn.SUBSCRIBED); return } else { const b = this.bindings.postgres_changes, k = (E = b?.length) !== null && E !== void 0 ? E : 0, C = []; for (let T = 0; T < k; T++) { const P = b[T], { filter: { event: I, schema: O, table: V, filter: M } } = P, R = S && S[T]; if (R && R.event === I && R.schema === O && R.table === V && R.filter === M) C.push(Object.assign(Object.assign({}, P), { id: R.id })); else { this.unsubscribe(), this.state = it.errored, t?.(Pn.CHANNEL_ERROR, new Error("mismatch between server and client bindings for postgres changes")); return } } this.bindings.postgres_changes = C, t && t(Pn.SUBSCRIBED); return } }).receive("error", S => { this.state = it.errored, t?.(Pn.CHANNEL_ERROR, new Error(JSON.stringify(Object.values(S).join(", ") || "error"))) }).receive("timeout", () => { t?.(Pn.TIMED_OUT) }) } return this } presenceState() { return this.presence.state } async track(t, s = {}) { return await this.send({ type: "presence", event: "track", payload: t }, s.timeout || this.timeout) } async untrack(t = {}) { return await this.send({ type: "presence", event: "untrack" }, t) } on(t, s, o) { return this.state === it.joined && t === Lo.PRESENCE && (this.socket.log("channel", `resubscribe to ${this.topic} due to change in presence callbacks on joined channel`), this.unsubscribe().then(() => this.subscribe())), this._on(t, s, o) } async send(t, s = {}) { var o, a; if (!this._canPush() && t.type === "broadcast") { const { event: l, payload: u } = t, p = { method: "POST", headers: { Authorization: this.socket.accessTokenValue ? `Bearer ${this.socket.accessTokenValue}` : "", apikey: this.socket.apiKey ? this.socket.apiKey : "", "Content-Type": "application/json" }, body: JSON.stringify({ messages: [{ topic: this.subTopic, event: l, payload: u, private: this.private }] }) }; try { const m = await this._fetchWithTimeout(this.broadcastEndpointURL, p, (o = s.timeout) !== null && o !== void 0 ? o : this.timeout); return await ((a = m.body) === null || a === void 0 ? void 0 : a.cancel()), m.ok ? "ok" : "error" } catch (m) { return m.name === "AbortError" ? "timed out" : "error" } } else return new Promise(l => { var u, f, p; const m = this._push(t.type, t, s.timeout || this.timeout); t.type === "broadcast" && !(!((p = (f = (u = this.params) === null || u === void 0 ? void 0 : u.config) === null || f === void 0 ? void 0 : f.broadcast) === null || p === void 0) && p.ack) && l("ok"), m.receive("ok", () => l("ok")), m.receive("error", () => l("error")), m.receive("timeout", () => l("timed out")) }) } updateJoinPayload(t) { this.joinPush.updatePayload(t) } unsubscribe(t = this.timeout) { this.state = it.leaving; const s = () => { this.socket.log("channel", `leave ${this.topic}`), this._trigger(sn.close, "leave", this._joinRef()) }; this.joinPush.destroy(); let o = null; return new Promise(a => { o = new iu(this, sn.leave, {}, t), o.receive("ok", () => { s(), a("ok") }).receive("timeout", () => { s(), a("timed out") }).receive("error", () => { a("error") }), o.send(), this._canPush() || o.trigger("ok", {}) }).finally(() => { o?.destroy() }) } teardown() { this.pushBuffer.forEach(t => t.destroy()), this.pushBuffer = [], this.rejoinTimer.reset(), this.joinPush.destroy(), this.state = it.closed, this.bindings = {} } async _fetchWithTimeout(t, s, o) { const a = new AbortController, l = setTimeout(() => a.abort(), o), u = await this.socket.fetch(t, Object.assign(Object.assign({}, s), { signal: a.signal })); return clearTimeout(l), u } _push(t, s, o = this.timeout) { if (!this.joinedOnce) throw `tried to push '${t}' to '${this.topic}' before joining. Use channel.subscribe() before pushing events`; let a = new iu(this, t, s, o); return this._canPush() ? a.send() : this._addToPushBuffer(a), a } _addToPushBuffer(t) { if (t.startTimeout(), this.pushBuffer.push(t), this.pushBuffer.length > ZE) { const s = this.pushBuffer.shift(); s && (s.destroy(), this.socket.log("channel", `discarded push due to buffer overflow: ${s.event}`, s.payload)) } } _onMessage(t, s, o) { return s } _isMember(t) { return this.topic === t } _joinRef() { return this.joinPush.ref } _trigger(t, s, o) { var a, l; const u = t.toLocaleLowerCase(), { close: f, error: p, leave: m, join: v } = sn; if (o && [f, p, m, v].indexOf(u) >= 0 && o !== this._joinRef()) return; let _ = this._onMessage(u, s, o); if (s && !_) throw "channel onMessage callbacks must return the payload, modified or unmodified";["insert", "update", "delete"].includes(u) ? (a = this.bindings.postgres_changes) === null || a === void 0 || a.filter(S => { var E, b, k; return ((E = S.filter) === null || E === void 0 ? void 0 : E.event) === "*" || ((k = (b = S.filter) === null || b === void 0 ? void 0 : b.event) === null || k === void 0 ? void 0 : k.toLocaleLowerCase()) === u }).map(S => S.callback(_, o)) : (l = this.bindings[u]) === null || l === void 0 || l.filter(S => { var E, b, k, C, T, P; if (["broadcast", "presence", "postgres_changes"].includes(u)) if ("id" in S) { const I = S.id, O = (E = S.filter) === null || E === void 0 ? void 0 : E.event; return I && ((b = s.ids) === null || b === void 0 ? void 0 : b.includes(I)) && (O === "*" || O?.toLocaleLowerCase() === ((k = s.data) === null || k === void 0 ? void 0 : k.type.toLocaleLowerCase())) } else { const I = (T = (C = S?.filter) === null || C === void 0 ? void 0 : C.event) === null || T === void 0 ? void 0 : T.toLocaleLowerCase(); return I === "*" || I === ((P = s?.event) === null || P === void 0 ? void 0 : P.toLocaleLowerCase()) } else return S.type.toLocaleLowerCase() === u }).map(S => { if (typeof _ == "object" && "ids" in _) { const E = _.data, { schema: b, table: k, commit_timestamp: C, type: T, errors: P } = E; _ = Object.assign(Object.assign({}, { schema: b, table: k, commit_timestamp: C, eventType: T, new: {}, old: {}, errors: P }), this._getPayloadRecords(E)) } S.callback(_, o) }) } _isClosed() { return this.state === it.closed } _isJoined() { return this.state === it.joined } _isJoining() { return this.state === it.joining } _isLeaving() { return this.state === it.leaving } _replyEventName(t) { return `chan_reply_${t}` } _on(t, s, o) { const a = t.toLocaleLowerCase(), l = { type: a, filter: s, callback: o }; return this.bindings[a] ? this.bindings[a].push(l) : this.bindings[a] = [l], this } _off(t, s) { const o = t.toLocaleLowerCase(); return this.bindings[o] && (this.bindings[o] = this.bindings[o].filter(a => { var l; return !(((l = a.type) === null || l === void 0 ? void 0 : l.toLocaleLowerCase()) === o && Od.isEqual(a.filter, s)) })), this } static isEqual(t, s) { if (Object.keys(t).length !== Object.keys(s).length) return !1; for (const o in t) if (t[o] !== s[o]) return !1; return !0 } _rejoinUntilConnected() { this.rejoinTimer.scheduleTimeout(), this.socket.isConnected() && this._rejoin() } _onClose(t) { this._on(sn.close, {}, t) } _onError(t) { this._on(sn.error, {}, s => t(s)) } _canPush() { return this.socket.isConnected() && this._isJoined() } _rejoin(t = this.timeout) { this._isLeaving() || (this.socket._leaveOpenTopic(this.topic), this.state = it.joining, this.joinPush.resend(t)) } _getPayloadRecords(t) { const s = { new: {}, old: {} }; return (t.type === "INSERT" || t.type === "UPDATE") && (s.new = Pm(t.columns, t.record)), (t.type === "UPDATE" || t.type === "DELETE") && (s.old = Pm(t.columns, t.old_record)), s } } const au = () => { }, ga = { HEARTBEAT_INTERVAL: 25e3, RECONNECT_DELAY: 10, HEARTBEAT_TIMEOUT_FALLBACK: 100 }, aj = [1e3, 2e3, 5e3, 1e4], lj = 1e4, cj = `
  addEventListener("message", (e) => {
    if (e.data.event === "start") {
      setInterval(() => postMessage({ event: "keepAlive" }), e.data.interval);
    }
  });`; class uj {
  constructor(t, s) { var o; if (this.accessTokenValue = null, this.apiKey = null, this.channels = new Array, this.endPoint = "", this.httpEndpoint = "", this.headers = {}, this.params = {}, this.timeout = Lu, this.transport = null, this.heartbeatIntervalMs = ga.HEARTBEAT_INTERVAL, this.heartbeatTimer = void 0, this.pendingHeartbeatRef = null, this.heartbeatCallback = au, this.ref = 0, this.reconnectTimer = null, this.logger = au, this.conn = null, this.sendBuffer = [], this.serializer = new ej, this.stateChangeCallbacks = { open: [], close: [], error: [], message: [] }, this.accessToken = null, this._connectionState = "disconnected", this._wasManualDisconnect = !1, this._authPromise = null, this._resolveFetch = a => { let l; return a ? l = a : typeof fetch > "u" ? l = (...u) => Yo(async () => { const { default: f } = await Promise.resolve().then(() => Ws); return { default: f } }, void 0).then(({ default: f }) => f(...u)).catch(f => { throw new Error(`Failed to load @supabase/node-fetch: ${f.message}. This is required for HTTP requests in Node.js environments without native fetch.`) }) : l = fetch, (...u) => l(...u) }, !(!((o = s?.params) === null || o === void 0) && o.apikey)) throw new Error("API key is required to connect to Realtime"); this.apiKey = s.params.apikey, this.endPoint = `${t}/${Mu.websocket}`, this.httpEndpoint = zy(t), this._initializeOptions(s), this._setupReconnectionTimer(), this.fetch = this._resolveFetch(s?.fetch) } connect() {
    if (!(this.isConnecting() || this.isDisconnecting() || this.conn !== null && this.isConnected())) {
      if (this._setConnectionState("connecting"), this._setAuthSafely("connect"), this.transport) this.conn = new this.transport(this.endpointURL()); else try { this.conn = GE.createWebSocket(this.endpointURL()) } catch (t) {
        this._setConnectionState("disconnected"); const s = t.message; throw s.includes("Node.js") ? new Error(`${s}

To use Realtime in Node.js, you need to provide a WebSocket implementation:

Option 1: Use Node.js 22+ which has native WebSocket support
Option 2: Install and provide the "ws" package:

  npm install ws

  import ws from "ws"
  const client = new RealtimeClient(url, {
    ...options,
    transport: ws
  })`) : new Error(`WebSocket not available: ${s}`)
      } this._setupConnectionHandlers()
    }
  } endpointURL() { return this._appendParams(this.endPoint, Object.assign({}, this.params, { vsn: QE })) } disconnect(t, s) { if (!this.isDisconnecting()) if (this._setConnectionState("disconnecting", !0), this.conn) { const o = setTimeout(() => { this._setConnectionState("disconnected") }, 100); this.conn.onclose = () => { clearTimeout(o), this._setConnectionState("disconnected") }, t ? this.conn.close(t, s ?? "") : this.conn.close(), this._teardownConnection() } else this._setConnectionState("disconnected") } getChannels() { return this.channels } async removeChannel(t) { const s = await t.unsubscribe(); return this.channels.length === 0 && this.disconnect(), s } async removeAllChannels() { const t = await Promise.all(this.channels.map(s => s.unsubscribe())); return this.channels = [], this.disconnect(), t } log(t, s, o) { this.logger(t, s, o) } connectionState() { switch (this.conn && this.conn.readyState) { case Do.connecting: return Tr.Connecting; case Do.open: return Tr.Open; case Do.closing: return Tr.Closing; default: return Tr.Closed } } isConnected() { return this.connectionState() === Tr.Open } isConnecting() { return this._connectionState === "connecting" } isDisconnecting() { return this._connectionState === "disconnecting" } channel(t, s = { config: {} }) { const o = `realtime:${t}`, a = this.getChannels().find(l => l.topic === o); if (a) return a; { const l = new Od(`realtime:${t}`, s, this); return this.channels.push(l), l } } push(t) { const { topic: s, event: o, payload: a, ref: l } = t, u = () => { this.encode(t, f => { var p; (p = this.conn) === null || p === void 0 || p.send(f) }) }; this.log("push", `${s} ${o} (${l})`, a), this.isConnected() ? u() : this.sendBuffer.push(u) } async setAuth(t = null) { this._authPromise = this._performAuth(t); try { await this._authPromise } finally { this._authPromise = null } } async sendHeartbeat() { var t; if (!this.isConnected()) { try { this.heartbeatCallback("disconnected") } catch (s) { this.log("error", "error in heartbeat callback", s) } return } if (this.pendingHeartbeatRef) { this.pendingHeartbeatRef = null, this.log("transport", "heartbeat timeout. Attempting to re-establish connection"); try { this.heartbeatCallback("timeout") } catch (s) { this.log("error", "error in heartbeat callback", s) } this._wasManualDisconnect = !1, (t = this.conn) === null || t === void 0 || t.close(XE, "heartbeat timeout"), setTimeout(() => { var s; this.isConnected() || (s = this.reconnectTimer) === null || s === void 0 || s.scheduleTimeout() }, ga.HEARTBEAT_TIMEOUT_FALLBACK); return } this.pendingHeartbeatRef = this._makeRef(), this.push({ topic: "phoenix", event: "heartbeat", payload: {}, ref: this.pendingHeartbeatRef }); try { this.heartbeatCallback("sent") } catch (s) { this.log("error", "error in heartbeat callback", s) } this._setAuthSafely("heartbeat") } onHeartbeat(t) { this.heartbeatCallback = t } flushSendBuffer() { this.isConnected() && this.sendBuffer.length > 0 && (this.sendBuffer.forEach(t => t()), this.sendBuffer = []) } _makeRef() { let t = this.ref + 1; return t === this.ref ? this.ref = 0 : this.ref = t, this.ref.toString() } _leaveOpenTopic(t) { let s = this.channels.find(o => o.topic === t && (o._isJoined() || o._isJoining())); s && (this.log("transport", `leaving duplicate topic "${t}"`), s.unsubscribe()) } _remove(t) { this.channels = this.channels.filter(s => s.topic !== t.topic) } _onConnMessage(t) { this.decode(t.data, s => { if (s.topic === "phoenix" && s.event === "phx_reply") try { this.heartbeatCallback(s.payload.status === "ok" ? "ok" : "error") } catch (m) { this.log("error", "error in heartbeat callback", m) } s.ref && s.ref === this.pendingHeartbeatRef && (this.pendingHeartbeatRef = null); const { topic: o, event: a, payload: l, ref: u } = s, f = u ? `(${u})` : "", p = l.status || ""; this.log("receive", `${p} ${o} ${a} ${f}`.trim(), l), this.channels.filter(m => m._isMember(o)).forEach(m => m._trigger(a, l, u)), this._triggerStateCallbacks("message", s) }) } _clearTimer(t) { var s; t === "heartbeat" && this.heartbeatTimer ? (clearInterval(this.heartbeatTimer), this.heartbeatTimer = void 0) : t === "reconnect" && ((s = this.reconnectTimer) === null || s === void 0 || s.reset()) } _clearAllTimers() { this._clearTimer("heartbeat"), this._clearTimer("reconnect") } _setupConnectionHandlers() { this.conn && ("binaryType" in this.conn && (this.conn.binaryType = "arraybuffer"), this.conn.onopen = () => this._onConnOpen(), this.conn.onerror = t => this._onConnError(t), this.conn.onmessage = t => this._onConnMessage(t), this.conn.onclose = t => this._onConnClose(t)) } _teardownConnection() { this.conn && (this.conn.onopen = null, this.conn.onerror = null, this.conn.onmessage = null, this.conn.onclose = null, this.conn = null), this._clearAllTimers(), this.channels.forEach(t => t.teardown()) } _onConnOpen() { this._setConnectionState("connected"), this.log("transport", `connected to ${this.endpointURL()}`), this.flushSendBuffer(), this._clearTimer("reconnect"), this.worker ? this.workerRef || this._startWorkerHeartbeat() : this._startHeartbeat(), this._triggerStateCallbacks("open") } _startHeartbeat() { this.heartbeatTimer && clearInterval(this.heartbeatTimer), this.heartbeatTimer = setInterval(() => this.sendHeartbeat(), this.heartbeatIntervalMs) } _startWorkerHeartbeat() { this.workerUrl ? this.log("worker", `starting worker for from ${this.workerUrl}`) : this.log("worker", "starting default worker"); const t = this._workerObjectUrl(this.workerUrl); this.workerRef = new Worker(t), this.workerRef.onerror = s => { this.log("worker", "worker error", s.message), this.workerRef.terminate() }, this.workerRef.onmessage = s => { s.data.event === "keepAlive" && this.sendHeartbeat() }, this.workerRef.postMessage({ event: "start", interval: this.heartbeatIntervalMs }) } _onConnClose(t) { var s; this._setConnectionState("disconnected"), this.log("transport", "close", t), this._triggerChanError(), this._clearTimer("heartbeat"), this._wasManualDisconnect || (s = this.reconnectTimer) === null || s === void 0 || s.scheduleTimeout(), this._triggerStateCallbacks("close", t) } _onConnError(t) { this._setConnectionState("disconnected"), this.log("transport", `${t}`), this._triggerChanError(), this._triggerStateCallbacks("error", t) } _triggerChanError() { this.channels.forEach(t => t._trigger(sn.error)) } _appendParams(t, s) { if (Object.keys(s).length === 0) return t; const o = t.match(/\?/) ? "&" : "?", a = new URLSearchParams(s); return `${t}${o}${a}` } _workerObjectUrl(t) { let s; if (t) s = t; else { const o = new Blob([cj], { type: "application/javascript" }); s = URL.createObjectURL(o) } return s } _setConnectionState(t, s = !1) { this._connectionState = t, t === "connecting" ? this._wasManualDisconnect = !1 : t === "disconnecting" && (this._wasManualDisconnect = s) } async _performAuth(t = null) { let s; t ? s = t : this.accessToken ? s = await this.accessToken() : s = this.accessTokenValue, this.accessTokenValue != s && (this.accessTokenValue = s, this.channels.forEach(o => { const a = { access_token: s, version: JE }; s && o.updateJoinPayload(a), o.joinedOnce && o._isJoined() && o._push(sn.access_token, { access_token: s }) })) } async _waitForAuthIfNeeded() { this._authPromise && await this._authPromise } _setAuthSafely(t = "general") { this.setAuth().catch(s => { this.log("error", `error setting auth in ${t}`, s) }) } _triggerStateCallbacks(t, s) { try { this.stateChangeCallbacks[t].forEach(o => { try { o(s) } catch (a) { this.log("error", `error in ${t} callback`, a) } }) } catch (o) { this.log("error", `error triggering ${t} callbacks`, o) } } _setupReconnectionTimer() { this.reconnectTimer = new My(async () => { setTimeout(async () => { await this._waitForAuthIfNeeded(), this.isConnected() || this.connect() }, ga.RECONNECT_DELAY) }, this.reconnectAfterMs) } _initializeOptions(t) { var s, o, a, l, u, f, p, m, v; if (this.transport = (s = t?.transport) !== null && s !== void 0 ? s : null, this.timeout = (o = t?.timeout) !== null && o !== void 0 ? o : Lu, this.heartbeatIntervalMs = (a = t?.heartbeatIntervalMs) !== null && a !== void 0 ? a : ga.HEARTBEAT_INTERVAL, this.worker = (l = t?.worker) !== null && l !== void 0 ? l : !1, this.accessToken = (u = t?.accessToken) !== null && u !== void 0 ? u : null, this.heartbeatCallback = (f = t?.heartbeatCallback) !== null && f !== void 0 ? f : au, t?.params && (this.params = t.params), t?.logger && (this.logger = t.logger), (t?.logLevel || t?.log_level) && (this.logLevel = t.logLevel || t.log_level, this.params = Object.assign(Object.assign({}, this.params), { log_level: this.logLevel })), this.reconnectAfterMs = (p = t?.reconnectAfterMs) !== null && p !== void 0 ? p : (y => aj[y - 1] || lj), this.encode = (m = t?.encode) !== null && m !== void 0 ? m : ((y, _) => _(JSON.stringify(y))), this.decode = (v = t?.decode) !== null && v !== void 0 ? v : this.serializer.decode.bind(this.serializer), this.worker) { if (typeof window < "u" && !window.Worker) throw new Error("Web Worker is not supported"); this.workerUrl = t?.workerUrl } }
} class Id extends Error { constructor(t) { super(t), this.__isStorageError = !0, this.name = "StorageError" } } function tt(r) { return typeof r == "object" && r !== null && "__isStorageError" in r } class dj extends Id { constructor(t, s, o) { super(t), this.name = "StorageApiError", this.status = s, this.statusCode = o } toJSON() { return { name: this.name, message: this.message, status: this.status, statusCode: this.statusCode } } } class zu extends Id { constructor(t, s) { super(t), this.name = "StorageUnknownError", this.originalError = s } } var fj = function (r, t, s, o) { function a(l) { return l instanceof s ? l : new s(function (u) { u(l) }) } return new (s || (s = Promise))(function (l, u) { function f(v) { try { m(o.next(v)) } catch (y) { u(y) } } function p(v) { try { m(o.throw(v)) } catch (y) { u(y) } } function m(v) { v.done ? l(v.value) : a(v.value).then(f, p) } m((o = o.apply(r, t || [])).next()) }) }; const Fy = r => { let t; return r ? t = r : typeof fetch > "u" ? t = (...s) => Yo(async () => { const { default: o } = await Promise.resolve().then(() => Ws); return { default: o } }, void 0).then(({ default: o }) => o(...s)) : t = fetch, (...s) => t(...s) }, hj = () => fj(void 0, void 0, void 0, function* () { return typeof Response > "u" ? (yield Yo(() => Promise.resolve().then(() => Ws), void 0)).Response : Response }), Fu = r => { if (Array.isArray(r)) return r.map(s => Fu(s)); if (typeof r == "function" || r !== Object(r)) return r; const t = {}; return Object.entries(r).forEach(([s, o]) => { const a = s.replace(/([-_][a-z])/gi, l => l.toUpperCase().replace(/[-_]/g, "")); t[a] = Fu(o) }), t }, pj = r => { if (typeof r != "object" || r === null) return !1; const t = Object.getPrototypeOf(r); return (t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) && !(Symbol.toStringTag in r) && !(Symbol.iterator in r) }; var Lr = function (r, t, s, o) { function a(l) { return l instanceof s ? l : new s(function (u) { u(l) }) } return new (s || (s = Promise))(function (l, u) { function f(v) { try { m(o.next(v)) } catch (y) { u(y) } } function p(v) { try { m(o.throw(v)) } catch (y) { u(y) } } function m(v) { v.done ? l(v.value) : a(v.value).then(f, p) } m((o = o.apply(r, t || [])).next()) }) }; const lu = r => r.msg || r.message || r.error_description || r.error || JSON.stringify(r), mj = (r, t, s) => Lr(void 0, void 0, void 0, function* () { const o = yield hj(); r instanceof o && !s?.noResolveJson ? r.json().then(a => { const l = r.status || 500, u = a?.statusCode || l + ""; t(new dj(lu(a), l, u)) }).catch(a => { t(new zu(lu(a), a)) }) : t(new zu(lu(r), r)) }), gj = (r, t, s, o) => { const a = { method: r, headers: t?.headers || {} }; return r === "GET" || !o ? a : (pj(o) ? (a.headers = Object.assign({ "Content-Type": "application/json" }, t?.headers), a.body = JSON.stringify(o)) : a.body = o, t?.duplex && (a.duplex = t.duplex), Object.assign(Object.assign({}, a), s)) }; function Jo(r, t, s, o, a, l) { return Lr(this, void 0, void 0, function* () { return new Promise((u, f) => { r(s, gj(t, o, a, l)).then(p => { if (!p.ok) throw p; return o?.noResolveJson ? p : p.json() }).then(p => u(p)).catch(p => mj(p, f, o)) }) }) } function Ra(r, t, s, o) { return Lr(this, void 0, void 0, function* () { return Jo(r, "GET", t, s, o) }) } function pn(r, t, s, o, a) { return Lr(this, void 0, void 0, function* () { return Jo(r, "POST", t, o, a, s) }) } function Bu(r, t, s, o, a) { return Lr(this, void 0, void 0, function* () { return Jo(r, "PUT", t, o, a, s) }) } function vj(r, t, s, o) { return Lr(this, void 0, void 0, function* () { return Jo(r, "HEAD", t, Object.assign(Object.assign({}, s), { noResolveJson: !0 }), o) }) } function By(r, t, s, o, a) { return Lr(this, void 0, void 0, function* () { return Jo(r, "DELETE", t, o, a, s) }) } var yj = function (r, t, s, o) { function a(l) { return l instanceof s ? l : new s(function (u) { u(l) }) } return new (s || (s = Promise))(function (l, u) { function f(v) { try { m(o.next(v)) } catch (y) { u(y) } } function p(v) { try { m(o.throw(v)) } catch (y) { u(y) } } function m(v) { v.done ? l(v.value) : a(v.value).then(f, p) } m((o = o.apply(r, t || [])).next()) }) }; class wj { constructor(t, s) { this.downloadFn = t, this.shouldThrowOnError = s } then(t, s) { return this.execute().then(t, s) } execute() { return yj(this, void 0, void 0, function* () { try { return { data: (yield this.downloadFn()).body, error: null } } catch (t) { if (this.shouldThrowOnError) throw t; if (tt(t)) return { data: null, error: t }; throw t } }) } } var xj = function (r, t, s, o) { function a(l) { return l instanceof s ? l : new s(function (u) { u(l) }) } return new (s || (s = Promise))(function (l, u) { function f(v) { try { m(o.next(v)) } catch (y) { u(y) } } function p(v) { try { m(o.throw(v)) } catch (y) { u(y) } } function m(v) { v.done ? l(v.value) : a(v.value).then(f, p) } m((o = o.apply(r, t || [])).next()) }) }; class bj { constructor(t, s) { this.downloadFn = t, this.shouldThrowOnError = s } asStream() { return new wj(this.downloadFn, this.shouldThrowOnError) } then(t, s) { return this.execute().then(t, s) } execute() { return xj(this, void 0, void 0, function* () { try { return { data: yield (yield this.downloadFn()).blob(), error: null } } catch (t) { if (this.shouldThrowOnError) throw t; if (tt(t)) return { data: null, error: t }; throw t } }) } } var Pt = function (r, t, s, o) { function a(l) { return l instanceof s ? l : new s(function (u) { u(l) }) } return new (s || (s = Promise))(function (l, u) { function f(v) { try { m(o.next(v)) } catch (y) { u(y) } } function p(v) { try { m(o.throw(v)) } catch (y) { u(y) } } function m(v) { v.done ? l(v.value) : a(v.value).then(f, p) } m((o = o.apply(r, t || [])).next()) }) }; const _j = { limit: 100, offset: 0, sortBy: { column: "name", order: "asc" } }, Om = { cacheControl: "3600", contentType: "text/plain;charset=UTF-8", upsert: !1 }; class Sj { constructor(t, s = {}, o, a) { this.shouldThrowOnError = !1, this.url = t, this.headers = s, this.bucketId = o, this.fetch = Fy(a) } throwOnError() { return this.shouldThrowOnError = !0, this } uploadOrUpdate(t, s, o, a) { return Pt(this, void 0, void 0, function* () { try { let l; const u = Object.assign(Object.assign({}, Om), a); let f = Object.assign(Object.assign({}, this.headers), t === "POST" && { "x-upsert": String(u.upsert) }); const p = u.metadata; typeof Blob < "u" && o instanceof Blob ? (l = new FormData, l.append("cacheControl", u.cacheControl), p && l.append("metadata", this.encodeMetadata(p)), l.append("", o)) : typeof FormData < "u" && o instanceof FormData ? (l = o, l.append("cacheControl", u.cacheControl), p && l.append("metadata", this.encodeMetadata(p))) : (l = o, f["cache-control"] = `max-age=${u.cacheControl}`, f["content-type"] = u.contentType, p && (f["x-metadata"] = this.toBase64(this.encodeMetadata(p)))), a?.headers && (f = Object.assign(Object.assign({}, f), a.headers)); const m = this._removeEmptyFolders(s), v = this._getFinalPath(m), y = yield (t == "PUT" ? Bu : pn)(this.fetch, `${this.url}/object/${v}`, l, Object.assign({ headers: f }, u?.duplex ? { duplex: u.duplex } : {})); return { data: { path: m, id: y.Id, fullPath: y.Key }, error: null } } catch (l) { if (this.shouldThrowOnError) throw l; if (tt(l)) return { data: null, error: l }; throw l } }) } upload(t, s, o) { return Pt(this, void 0, void 0, function* () { return this.uploadOrUpdate("POST", t, s, o) }) } uploadToSignedUrl(t, s, o, a) { return Pt(this, void 0, void 0, function* () { const l = this._removeEmptyFolders(t), u = this._getFinalPath(l), f = new URL(this.url + `/object/upload/sign/${u}`); f.searchParams.set("token", s); try { let p; const m = Object.assign({ upsert: Om.upsert }, a), v = Object.assign(Object.assign({}, this.headers), { "x-upsert": String(m.upsert) }); typeof Blob < "u" && o instanceof Blob ? (p = new FormData, p.append("cacheControl", m.cacheControl), p.append("", o)) : typeof FormData < "u" && o instanceof FormData ? (p = o, p.append("cacheControl", m.cacheControl)) : (p = o, v["cache-control"] = `max-age=${m.cacheControl}`, v["content-type"] = m.contentType); const y = yield Bu(this.fetch, f.toString(), p, { headers: v }); return { data: { path: l, fullPath: y.Key }, error: null } } catch (p) { if (this.shouldThrowOnError) throw p; if (tt(p)) return { data: null, error: p }; throw p } }) } createSignedUploadUrl(t, s) { return Pt(this, void 0, void 0, function* () { try { let o = this._getFinalPath(t); const a = Object.assign({}, this.headers); s?.upsert && (a["x-upsert"] = "true"); const l = yield pn(this.fetch, `${this.url}/object/upload/sign/${o}`, {}, { headers: a }), u = new URL(this.url + l.url), f = u.searchParams.get("token"); if (!f) throw new Id("No token returned by API"); return { data: { signedUrl: u.toString(), path: t, token: f }, error: null } } catch (o) { if (this.shouldThrowOnError) throw o; if (tt(o)) return { data: null, error: o }; throw o } }) } update(t, s, o) { return Pt(this, void 0, void 0, function* () { return this.uploadOrUpdate("PUT", t, s, o) }) } move(t, s, o) { return Pt(this, void 0, void 0, function* () { try { return { data: yield pn(this.fetch, `${this.url}/object/move`, { bucketId: this.bucketId, sourceKey: t, destinationKey: s, destinationBucket: o?.destinationBucket }, { headers: this.headers }), error: null } } catch (a) { if (this.shouldThrowOnError) throw a; if (tt(a)) return { data: null, error: a }; throw a } }) } copy(t, s, o) { return Pt(this, void 0, void 0, function* () { try { return { data: { path: (yield pn(this.fetch, `${this.url}/object/copy`, { bucketId: this.bucketId, sourceKey: t, destinationKey: s, destinationBucket: o?.destinationBucket }, { headers: this.headers })).Key }, error: null } } catch (a) { if (this.shouldThrowOnError) throw a; if (tt(a)) return { data: null, error: a }; throw a } }) } createSignedUrl(t, s, o) { return Pt(this, void 0, void 0, function* () { try { let a = this._getFinalPath(t), l = yield pn(this.fetch, `${this.url}/object/sign/${a}`, Object.assign({ expiresIn: s }, o?.transform ? { transform: o.transform } : {}), { headers: this.headers }); const u = o?.download ? `&download=${o.download === !0 ? "" : o.download}` : ""; return l = { signedUrl: encodeURI(`${this.url}${l.signedURL}${u}`) }, { data: l, error: null } } catch (a) { if (this.shouldThrowOnError) throw a; if (tt(a)) return { data: null, error: a }; throw a } }) } createSignedUrls(t, s, o) { return Pt(this, void 0, void 0, function* () { try { const a = yield pn(this.fetch, `${this.url}/object/sign/${this.bucketId}`, { expiresIn: s, paths: t }, { headers: this.headers }), l = o?.download ? `&download=${o.download === !0 ? "" : o.download}` : ""; return { data: a.map(u => Object.assign(Object.assign({}, u), { signedUrl: u.signedURL ? encodeURI(`${this.url}${u.signedURL}${l}`) : null })), error: null } } catch (a) { if (this.shouldThrowOnError) throw a; if (tt(a)) return { data: null, error: a }; throw a } }) } download(t, s) { const a = typeof s?.transform < "u" ? "render/image/authenticated" : "object", l = this.transformOptsToQueryString(s?.transform || {}), u = l ? `?${l}` : "", f = this._getFinalPath(t), p = () => Ra(this.fetch, `${this.url}/${a}/${f}${u}`, { headers: this.headers, noResolveJson: !0 }); return new bj(p, this.shouldThrowOnError) } info(t) { return Pt(this, void 0, void 0, function* () { const s = this._getFinalPath(t); try { const o = yield Ra(this.fetch, `${this.url}/object/info/${s}`, { headers: this.headers }); return { data: Fu(o), error: null } } catch (o) { if (this.shouldThrowOnError) throw o; if (tt(o)) return { data: null, error: o }; throw o } }) } exists(t) { return Pt(this, void 0, void 0, function* () { const s = this._getFinalPath(t); try { return yield vj(this.fetch, `${this.url}/object/${s}`, { headers: this.headers }), { data: !0, error: null } } catch (o) { if (this.shouldThrowOnError) throw o; if (tt(o) && o instanceof zu) { const a = o.originalError; if ([400, 404].includes(a?.status)) return { data: !1, error: o } } throw o } }) } getPublicUrl(t, s) { const o = this._getFinalPath(t), a = [], l = s?.download ? `download=${s.download === !0 ? "" : s.download}` : ""; l !== "" && a.push(l); const f = typeof s?.transform < "u" ? "render/image" : "object", p = this.transformOptsToQueryString(s?.transform || {}); p !== "" && a.push(p); let m = a.join("&"); return m !== "" && (m = `?${m}`), { data: { publicUrl: encodeURI(`${this.url}/${f}/public/${o}${m}`) } } } remove(t) { return Pt(this, void 0, void 0, function* () { try { return { data: yield By(this.fetch, `${this.url}/object/${this.bucketId}`, { prefixes: t }, { headers: this.headers }), error: null } } catch (s) { if (this.shouldThrowOnError) throw s; if (tt(s)) return { data: null, error: s }; throw s } }) } list(t, s, o) { return Pt(this, void 0, void 0, function* () { try { const a = Object.assign(Object.assign(Object.assign({}, _j), s), { prefix: t || "" }); return { data: yield pn(this.fetch, `${this.url}/object/list/${this.bucketId}`, a, { headers: this.headers }, o), error: null } } catch (a) { if (this.shouldThrowOnError) throw a; if (tt(a)) return { data: null, error: a }; throw a } }) } listV2(t, s) { return Pt(this, void 0, void 0, function* () { try { const o = Object.assign({}, t); return { data: yield pn(this.fetch, `${this.url}/object/list-v2/${this.bucketId}`, o, { headers: this.headers }, s), error: null } } catch (o) { if (this.shouldThrowOnError) throw o; if (tt(o)) return { data: null, error: o }; throw o } }) } encodeMetadata(t) { return JSON.stringify(t) } toBase64(t) { return typeof Buffer < "u" ? Buffer.from(t).toString("base64") : btoa(t) } _getFinalPath(t) { return `${this.bucketId}/${t.replace(/^\/+/, "")}` } _removeEmptyFolders(t) { return t.replace(/^\/|\/$/g, "").replace(/\/+/g, "/") } transformOptsToQueryString(t) { const s = []; return t.width && s.push(`width=${t.width}`), t.height && s.push(`height=${t.height}`), t.resize && s.push(`resize=${t.resize}`), t.format && s.push(`format=${t.format}`), t.quality && s.push(`quality=${t.quality}`), s.join("&") } } const kj = "2.75.0", Ej = { "X-Client-Info": `storage-js/${kj}` }; var xs = function (r, t, s, o) { function a(l) { return l instanceof s ? l : new s(function (u) { u(l) }) } return new (s || (s = Promise))(function (l, u) { function f(v) { try { m(o.next(v)) } catch (y) { u(y) } } function p(v) { try { m(o.throw(v)) } catch (y) { u(y) } } function m(v) { v.done ? l(v.value) : a(v.value).then(f, p) } m((o = o.apply(r, t || [])).next()) }) }; class jj { constructor(t, s = {}, o, a) { this.shouldThrowOnError = !1; const l = new URL(t); a?.useNewHostname && /supabase\.(co|in|red)$/.test(l.hostname) && !l.hostname.includes("storage.supabase.") && (l.hostname = l.hostname.replace("supabase.", "storage.supabase.")), this.url = l.href.replace(/\/$/, ""), this.headers = Object.assign(Object.assign({}, Ej), s), this.fetch = Fy(o) } throwOnError() { return this.shouldThrowOnError = !0, this } listBuckets() { return xs(this, void 0, void 0, function* () { try { return { data: yield Ra(this.fetch, `${this.url}/bucket`, { headers: this.headers }), error: null } } catch (t) { if (this.shouldThrowOnError) throw t; if (tt(t)) return { data: null, error: t }; throw t } }) } getBucket(t) { return xs(this, void 0, void 0, function* () { try { return { data: yield Ra(this.fetch, `${this.url}/bucket/${t}`, { headers: this.headers }), error: null } } catch (s) { if (this.shouldThrowOnError) throw s; if (tt(s)) return { data: null, error: s }; throw s } }) } createBucket(t) { return xs(this, arguments, void 0, function* (s, o = { public: !1 }) { try { return { data: yield pn(this.fetch, `${this.url}/bucket`, { id: s, name: s, type: o.type, public: o.public, file_size_limit: o.fileSizeLimit, allowed_mime_types: o.allowedMimeTypes }, { headers: this.headers }), error: null } } catch (a) { if (this.shouldThrowOnError) throw a; if (tt(a)) return { data: null, error: a }; throw a } }) } updateBucket(t, s) { return xs(this, void 0, void 0, function* () { try { return { data: yield Bu(this.fetch, `${this.url}/bucket/${t}`, { id: t, name: t, public: s.public, file_size_limit: s.fileSizeLimit, allowed_mime_types: s.allowedMimeTypes }, { headers: this.headers }), error: null } } catch (o) { if (this.shouldThrowOnError) throw o; if (tt(o)) return { data: null, error: o }; throw o } }) } emptyBucket(t) { return xs(this, void 0, void 0, function* () { try { return { data: yield pn(this.fetch, `${this.url}/bucket/${t}/empty`, {}, { headers: this.headers }), error: null } } catch (s) { if (this.shouldThrowOnError) throw s; if (tt(s)) return { data: null, error: s }; throw s } }) } deleteBucket(t) { return xs(this, void 0, void 0, function* () { try { return { data: yield By(this.fetch, `${this.url}/bucket/${t}`, {}, { headers: this.headers }), error: null } } catch (s) { if (this.shouldThrowOnError) throw s; if (tt(s)) return { data: null, error: s }; throw s } }) } } class Cj extends jj { constructor(t, s = {}, o, a) { super(t, s, o, a) } from(t) { return new Sj(this.url, this.headers, t, this.fetch) } } const Nj = "2.75.0"; let Io = ""; typeof Deno < "u" ? Io = "deno" : typeof document < "u" ? Io = "web" : typeof navigator < "u" && navigator.product === "ReactNative" ? Io = "react-native" : Io = "node"; const Tj = { "X-Client-Info": `supabase-js-${Io}/${Nj}` }, Pj = { headers: Tj }, Rj = { schema: "public" }, Aj = { autoRefreshToken: !0, persistSession: !0, detectSessionInUrl: !0, flowType: "implicit" }, Oj = {}; var Ij = function (r, t, s, o) { function a(l) { return l instanceof s ? l : new s(function (u) { u(l) }) } return new (s || (s = Promise))(function (l, u) { function f(v) { try { m(o.next(v)) } catch (y) { u(y) } } function p(v) { try { m(o.throw(v)) } catch (y) { u(y) } } function m(v) { v.done ? l(v.value) : a(v.value).then(f, p) } m((o = o.apply(r, t || [])).next()) }) }; const Dj = r => { let t; return r ? t = r : typeof fetch > "u" ? t = Ay : t = fetch, (...s) => t(...s) }, $j = () => typeof Headers > "u" ? Oy : Headers, Lj = (r, t, s) => { const o = Dj(s), a = $j(); return (l, u) => Ij(void 0, void 0, void 0, function* () { var f; const p = (f = yield t()) !== null && f !== void 0 ? f : r; let m = new a(u?.headers); return m.has("apikey") || m.set("apikey", r), m.has("Authorization") || m.set("Authorization", `Bearer ${p}`), o(l, Object.assign(Object.assign({}, u), { headers: m })) }) }; var Mj = function (r, t, s, o) { function a(l) { return l instanceof s ? l : new s(function (u) { u(l) }) } return new (s || (s = Promise))(function (l, u) { function f(v) { try { m(o.next(v)) } catch (y) { u(y) } } function p(v) { try { m(o.throw(v)) } catch (y) { u(y) } } function m(v) { v.done ? l(v.value) : a(v.value).then(f, p) } m((o = o.apply(r, t || [])).next()) }) }; function Uj(r) { return r.endsWith("/") ? r : r + "/" } function zj(r, t) { var s, o; const { db: a, auth: l, realtime: u, global: f } = r, { db: p, auth: m, realtime: v, global: y } = t, _ = { db: Object.assign(Object.assign({}, p), a), auth: Object.assign(Object.assign({}, m), l), realtime: Object.assign(Object.assign({}, v), u), storage: {}, global: Object.assign(Object.assign(Object.assign({}, y), f), { headers: Object.assign(Object.assign({}, (s = y?.headers) !== null && s !== void 0 ? s : {}), (o = f?.headers) !== null && o !== void 0 ? o : {}) }), accessToken: () => Mj(this, void 0, void 0, function* () { return "" }) }; return r.accessToken ? _.accessToken = r.accessToken : delete _.accessToken, _ } function Fj(r) { const t = r?.trim(); if (!t) throw new Error("supabaseUrl is required."); if (!t.match(/^https?:\/\//i)) throw new Error("Invalid supabaseUrl: Must be a valid HTTP or HTTPS URL."); try { return new URL(Uj(t)) } catch { throw Error("Invalid supabaseUrl: Provided URL is malformed.") } } const Vy = "2.75.0", js = 30 * 1e3, Vu = 3, cu = Vu * js, Bj = "http://localhost:9999", Vj = "supabase.auth.token", Wj = { "X-Client-Info": `gotrue-js/${Vy}` }, Wu = "X-Supabase-Api-Version", Wy = { "2024-01-01": { timestamp: Date.parse("2024-01-01T00:00:00.0Z"), name: "2024-01-01" } }, Hj = /^([a-z0-9_-]{4})*($|[a-z0-9_-]{3}$|[a-z0-9_-]{2}$)$/i, Kj = 600 * 1e3; class Vo extends Error { constructor(t, s, o) { super(t), this.__isAuthError = !0, this.name = "AuthError", this.status = s, this.code = o } } function xe(r) { return typeof r == "object" && r !== null && "__isAuthError" in r } class qj extends Vo { constructor(t, s, o) { super(t, s, o), this.name = "AuthApiError", this.status = s, this.code = o } } function Gj(r) { return xe(r) && r.name === "AuthApiError" } class Pr extends Vo { constructor(t, s) { super(t), this.name = "AuthUnknownError", this.originalError = s } } class ur extends Vo { constructor(t, s, o, a) { super(t, o, a), this.name = s, this.status = o } } class tr extends ur { constructor() { super("Auth session missing!", "AuthSessionMissingError", 400, void 0) } } function Yj(r) { return xe(r) && r.name === "AuthSessionMissingError" } class bs extends ur { constructor() { super("Auth session or user missing", "AuthInvalidTokenResponseError", 500, void 0) } } class va extends ur { constructor(t) { super(t, "AuthInvalidCredentialsError", 400, void 0) } } class ya extends ur { constructor(t, s = null) { super(t, "AuthImplicitGrantRedirectError", 500, void 0), this.details = null, this.details = s } toJSON() { return { name: this.name, message: this.message, status: this.status, details: this.details } } } function Jj(r) { return xe(r) && r.name === "AuthImplicitGrantRedirectError" } class Im extends ur { constructor(t, s = null) { super(t, "AuthPKCEGrantCodeExchangeError", 500, void 0), this.details = null, this.details = s } toJSON() { return { name: this.name, message: this.message, status: this.status, details: this.details } } } class Hu extends ur { constructor(t, s) { super(t, "AuthRetryableFetchError", s, void 0) } } function uu(r) { return xe(r) && r.name === "AuthRetryableFetchError" } class Dm extends ur { constructor(t, s, o) { super(t, "AuthWeakPasswordError", s, "weak_password"), this.reasons = o } } class Ku extends ur { constructor(t) { super(t, "AuthInvalidJwtError", 400, "invalid_jwt") } } const Aa = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_".split(""), $m = ` 	
\r=`.split(""), Qj = (() => { const r = new Array(128); for (let t = 0; t < r.length; t += 1)r[t] = -1; for (let t = 0; t < $m.length; t += 1)r[$m[t].charCodeAt(0)] = -2; for (let t = 0; t < Aa.length; t += 1)r[Aa[t].charCodeAt(0)] = t; return r })(); function Lm(r, t, s) { if (r !== null) for (t.queue = t.queue << 8 | r, t.queuedBits += 8; t.queuedBits >= 6;) { const o = t.queue >> t.queuedBits - 6 & 63; s(Aa[o]), t.queuedBits -= 6 } else if (t.queuedBits > 0) for (t.queue = t.queue << 6 - t.queuedBits, t.queuedBits = 6; t.queuedBits >= 6;) { const o = t.queue >> t.queuedBits - 6 & 63; s(Aa[o]), t.queuedBits -= 6 } } function Hy(r, t, s) { const o = Qj[r]; if (o > -1) for (t.queue = t.queue << 6 | o, t.queuedBits += 6; t.queuedBits >= 8;)s(t.queue >> t.queuedBits - 8 & 255), t.queuedBits -= 8; else { if (o === -2) return; throw new Error(`Invalid Base64-URL character "${String.fromCharCode(r)}"`) } } function Mm(r) { const t = [], s = u => { t.push(String.fromCodePoint(u)) }, o = { utf8seq: 0, codepoint: 0 }, a = { queue: 0, queuedBits: 0 }, l = u => { eC(u, o, s) }; for (let u = 0; u < r.length; u += 1)Hy(r.charCodeAt(u), a, l); return t.join("") } function Xj(r, t) { if (r <= 127) { t(r); return } else if (r <= 2047) { t(192 | r >> 6), t(128 | r & 63); return } else if (r <= 65535) { t(224 | r >> 12), t(128 | r >> 6 & 63), t(128 | r & 63); return } else if (r <= 1114111) { t(240 | r >> 18), t(128 | r >> 12 & 63), t(128 | r >> 6 & 63), t(128 | r & 63); return } throw new Error(`Unrecognized Unicode codepoint: ${r.toString(16)}`) } function Zj(r, t) { for (let s = 0; s < r.length; s += 1) { let o = r.charCodeAt(s); if (o > 55295 && o <= 56319) { const a = (o - 55296) * 1024 & 65535; o = (r.charCodeAt(s + 1) - 56320 & 65535 | a) + 65536, s += 1 } Xj(o, t) } } function eC(r, t, s) { if (t.utf8seq === 0) { if (r <= 127) { s(r); return } for (let o = 1; o < 6; o += 1)if ((r >> 7 - o & 1) === 0) { t.utf8seq = o; break } if (t.utf8seq === 2) t.codepoint = r & 31; else if (t.utf8seq === 3) t.codepoint = r & 15; else if (t.utf8seq === 4) t.codepoint = r & 7; else throw new Error("Invalid UTF-8 sequence"); t.utf8seq -= 1 } else if (t.utf8seq > 0) { if (r <= 127) throw new Error("Invalid UTF-8 sequence"); t.codepoint = t.codepoint << 6 | r & 63, t.utf8seq -= 1, t.utf8seq === 0 && s(t.codepoint) } } function As(r) { const t = [], s = { queue: 0, queuedBits: 0 }, o = a => { t.push(a) }; for (let a = 0; a < r.length; a += 1)Hy(r.charCodeAt(a), s, o); return new Uint8Array(t) } function tC(r) { const t = []; return Zj(r, s => t.push(s)), new Uint8Array(t) } function Rr(r) { const t = [], s = { queue: 0, queuedBits: 0 }, o = a => { t.push(a) }; return r.forEach(a => Lm(a, s, o)), Lm(null, s, o), t.join("") } function nC(r) { return Math.round(Date.now() / 1e3) + r } function rC() { return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (r) { const t = Math.random() * 16 | 0; return (r == "x" ? t : t & 3 | 8).toString(16) }) } const $t = () => typeof window < "u" && typeof document < "u", jr = { tested: !1, writable: !1 }, Ky = () => { if (!$t()) return !1; try { if (typeof globalThis.localStorage != "object") return !1 } catch { return !1 } if (jr.tested) return jr.writable; const r = `lswt-${Math.random()}${Math.random()}`; try { globalThis.localStorage.setItem(r, r), globalThis.localStorage.removeItem(r), jr.tested = !0, jr.writable = !0 } catch { jr.tested = !0, jr.writable = !1 } return jr.writable }; function sC(r) { const t = {}, s = new URL(r); if (s.hash && s.hash[0] === "#") try { new URLSearchParams(s.hash.substring(1)).forEach((a, l) => { t[l] = a }) } catch { } return s.searchParams.forEach((o, a) => { t[a] = o }), t } const qy = r => { let t; return r ? t = r : typeof fetch > "u" ? t = (...s) => Yo(async () => { const { default: o } = await Promise.resolve().then(() => Ws); return { default: o } }, void 0).then(({ default: o }) => o(...s)) : t = fetch, (...s) => t(...s) }, oC = r => typeof r == "object" && r !== null && "status" in r && "ok" in r && "json" in r && typeof r.json == "function", Cs = async (r, t, s) => { await r.setItem(t, JSON.stringify(s)) }, Cr = async (r, t) => { const s = await r.getItem(t); if (!s) return null; try { return JSON.parse(s) } catch { return s } }, Zn = async (r, t) => { await r.removeItem(t) }; class Ya { constructor() { this.promise = new Ya.promiseConstructor((t, s) => { this.resolve = t, this.reject = s }) } } Ya.promiseConstructor = Promise; function du(r) { const t = r.split("."); if (t.length !== 3) throw new Ku("Invalid JWT structure"); for (let o = 0; o < t.length; o++)if (!Hj.test(t[o])) throw new Ku("JWT not in base64url format"); return { header: JSON.parse(Mm(t[0])), payload: JSON.parse(Mm(t[1])), signature: As(t[2]), raw: { header: t[0], payload: t[1] } } } async function iC(r) { return await new Promise(t => { setTimeout(() => t(null), r) }) } function aC(r, t) { return new Promise((o, a) => { (async () => { for (let l = 0; l < 1 / 0; l++)try { const u = await r(l); if (!t(l, null, u)) { o(u); return } } catch (u) { if (!t(l, u)) { a(u); return } } })() }) } function lC(r) { return ("0" + r.toString(16)).substr(-2) } function cC() { const t = new Uint32Array(56); if (typeof crypto > "u") { const s = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~", o = s.length; let a = ""; for (let l = 0; l < 56; l++)a += s.charAt(Math.floor(Math.random() * o)); return a } return crypto.getRandomValues(t), Array.from(t, lC).join("") } async function uC(r) { const s = new TextEncoder().encode(r), o = await crypto.subtle.digest("SHA-256", s), a = new Uint8Array(o); return Array.from(a).map(l => String.fromCharCode(l)).join("") } async function dC(r) { if (!(typeof crypto < "u" && typeof crypto.subtle < "u" && typeof TextEncoder < "u")) return console.warn("WebCrypto API is not supported. Code challenge method will default to use plain instead of sha256."), r; const s = await uC(r); return btoa(s).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "") } async function _s(r, t, s = !1) { const o = cC(); let a = o; s && (a += "/PASSWORD_RECOVERY"), await Cs(r, `${t}-code-verifier`, a); const l = await dC(o); return [l, o === l ? "plain" : "s256"] } const fC = /^2[0-9]{3}-(0[1-9]|1[0-2])-(0[1-9]|1[0-9]|2[0-9]|3[0-1])$/i; function hC(r) { const t = r.headers.get(Wu); if (!t || !t.match(fC)) return null; try { return new Date(`${t}T00:00:00.0Z`) } catch { return null } } function pC(r) { if (!r) throw new Error("Missing exp claim"); const t = Math.floor(Date.now() / 1e3); if (r <= t) throw new Error("JWT has expired") } function mC(r) { switch (r) { case "RS256": return { name: "RSASSA-PKCS1-v1_5", hash: { name: "SHA-256" } }; case "ES256": return { name: "ECDSA", namedCurve: "P-256", hash: { name: "SHA-256" } }; default: throw new Error("Invalid alg claim") } } const gC = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/; function Ss(r) { if (!gC.test(r)) throw new Error("@supabase/auth-js: Expected parameter to be UUID but is not") } function fu() { const r = {}; return new Proxy(r, { get: (t, s) => { if (s === "__isUserNotAvailableProxy") return !0; if (typeof s == "symbol") { const o = s.toString(); if (o === "Symbol(Symbol.toPrimitive)" || o === "Symbol(Symbol.toStringTag)" || o === "Symbol(util.inspect.custom)") return } throw new Error(`@supabase/auth-js: client was created with userStorage option and there was no user stored in the user storage. Accessing the "${s}" property of the session object is not supported. Please use getUser() instead.`) }, set: (t, s) => { throw new Error(`@supabase/auth-js: client was created with userStorage option and there was no user stored in the user storage. Setting the "${s}" property of the session object is not supported. Please use getUser() to fetch a user object you can manipulate.`) }, deleteProperty: (t, s) => { throw new Error(`@supabase/auth-js: client was created with userStorage option and there was no user stored in the user storage. Deleting the "${s}" property of the session object is not supported. Please use getUser() to fetch a user object you can manipulate.`) } }) } function Um(r) { return JSON.parse(JSON.stringify(r)) } var vC = function (r, t) { var s = {}; for (var o in r) Object.prototype.hasOwnProperty.call(r, o) && t.indexOf(o) < 0 && (s[o] = r[o]); if (r != null && typeof Object.getOwnPropertySymbols == "function") for (var a = 0, o = Object.getOwnPropertySymbols(r); a < o.length; a++)t.indexOf(o[a]) < 0 && Object.prototype.propertyIsEnumerable.call(r, o[a]) && (s[o[a]] = r[o[a]]); return s }; const Nr = r => r.msg || r.message || r.error_description || r.error || JSON.stringify(r), yC = [502, 503, 504]; async function zm(r) { var t; if (!oC(r)) throw new Hu(Nr(r), 0); if (yC.includes(r.status)) throw new Hu(Nr(r), r.status); let s; try { s = await r.json() } catch (l) { throw new Pr(Nr(l), l) } let o; const a = hC(r); if (a && a.getTime() >= Wy["2024-01-01"].timestamp && typeof s == "object" && s && typeof s.code == "string" ? o = s.code : typeof s == "object" && s && typeof s.error_code == "string" && (o = s.error_code), o) { if (o === "weak_password") throw new Dm(Nr(s), r.status, ((t = s.weak_password) === null || t === void 0 ? void 0 : t.reasons) || []); if (o === "session_not_found") throw new tr } else if (typeof s == "object" && s && typeof s.weak_password == "object" && s.weak_password && Array.isArray(s.weak_password.reasons) && s.weak_password.reasons.length && s.weak_password.reasons.reduce((l, u) => l && typeof u == "string", !0)) throw new Dm(Nr(s), r.status, s.weak_password.reasons); throw new qj(Nr(s), r.status || 500, o) } const wC = (r, t, s, o) => { const a = { method: r, headers: t?.headers || {} }; return r === "GET" ? a : (a.headers = Object.assign({ "Content-Type": "application/json;charset=UTF-8" }, t?.headers), a.body = JSON.stringify(o), Object.assign(Object.assign({}, a), s)) }; async function Se(r, t, s, o) { var a; const l = Object.assign({}, o?.headers); l[Wu] || (l[Wu] = Wy["2024-01-01"].name), o?.jwt && (l.Authorization = `Bearer ${o.jwt}`); const u = (a = o?.query) !== null && a !== void 0 ? a : {}; o?.redirectTo && (u.redirect_to = o.redirectTo); const f = Object.keys(u).length ? "?" + new URLSearchParams(u).toString() : "", p = await xC(r, t, s + f, { headers: l, noResolveJson: o?.noResolveJson }, {}, o?.body); return o?.xform ? o?.xform(p) : { data: Object.assign({}, p), error: null } } async function xC(r, t, s, o, a, l) { const u = wC(t, o, a, l); let f; try { f = await r(s, Object.assign({}, u)) } catch (p) { throw console.error(p), new Hu(Nr(p), 0) } if (f.ok || await zm(f), o?.noResolveJson) return f; try { return await f.json() } catch (p) { await zm(p) } } function nn(r) { var t; let s = null; SC(r) && (s = Object.assign({}, r), r.expires_at || (s.expires_at = nC(r.expires_in))); const o = (t = r.user) !== null && t !== void 0 ? t : r; return { data: { session: s, user: o }, error: null } } function Fm(r) { const t = nn(r); return !t.error && r.weak_password && typeof r.weak_password == "object" && Array.isArray(r.weak_password.reasons) && r.weak_password.reasons.length && r.weak_password.message && typeof r.weak_password.message == "string" && r.weak_password.reasons.reduce((s, o) => s && typeof o == "string", !0) && (t.data.weak_password = r.weak_password), t } function nr(r) { var t; return { data: { user: (t = r.user) !== null && t !== void 0 ? t : r }, error: null } } function bC(r) { return { data: r, error: null } } function _C(r) { const { action_link: t, email_otp: s, hashed_token: o, redirect_to: a, verification_type: l } = r, u = vC(r, ["action_link", "email_otp", "hashed_token", "redirect_to", "verification_type"]), f = { action_link: t, email_otp: s, hashed_token: o, redirect_to: a, verification_type: l }, p = Object.assign({}, u); return { data: { properties: f, user: p }, error: null } } function Bm(r) { return r } function SC(r) { return r.access_token && r.refresh_token && r.expires_in } const hu = ["global", "local", "others"]; var kC = function (r, t) { var s = {}; for (var o in r) Object.prototype.hasOwnProperty.call(r, o) && t.indexOf(o) < 0 && (s[o] = r[o]); if (r != null && typeof Object.getOwnPropertySymbols == "function") for (var a = 0, o = Object.getOwnPropertySymbols(r); a < o.length; a++)t.indexOf(o[a]) < 0 && Object.prototype.propertyIsEnumerable.call(r, o[a]) && (s[o[a]] = r[o[a]]); return s }; class EC { constructor({ url: t = "", headers: s = {}, fetch: o }) { this.url = t, this.headers = s, this.fetch = qy(o), this.mfa = { listFactors: this._listFactors.bind(this), deleteFactor: this._deleteFactor.bind(this) }, this.oauth = { listClients: this._listOAuthClients.bind(this), createClient: this._createOAuthClient.bind(this), getClient: this._getOAuthClient.bind(this), deleteClient: this._deleteOAuthClient.bind(this), regenerateClientSecret: this._regenerateOAuthClientSecret.bind(this) } } async signOut(t, s = hu[0]) { if (hu.indexOf(s) < 0) throw new Error(`@supabase/auth-js: Parameter scope must be one of ${hu.join(", ")}`); try { return await Se(this.fetch, "POST", `${this.url}/logout?scope=${s}`, { headers: this.headers, jwt: t, noResolveJson: !0 }), { data: null, error: null } } catch (o) { if (xe(o)) return { data: null, error: o }; throw o } } async inviteUserByEmail(t, s = {}) { try { return await Se(this.fetch, "POST", `${this.url}/invite`, { body: { email: t, data: s.data }, headers: this.headers, redirectTo: s.redirectTo, xform: nr }) } catch (o) { if (xe(o)) return { data: { user: null }, error: o }; throw o } } async generateLink(t) { try { const { options: s } = t, o = kC(t, ["options"]), a = Object.assign(Object.assign({}, o), s); return "newEmail" in o && (a.new_email = o?.newEmail, delete a.newEmail), await Se(this.fetch, "POST", `${this.url}/admin/generate_link`, { body: a, headers: this.headers, xform: _C, redirectTo: s?.redirectTo }) } catch (s) { if (xe(s)) return { data: { properties: null, user: null }, error: s }; throw s } } async createUser(t) { try { return await Se(this.fetch, "POST", `${this.url}/admin/users`, { body: t, headers: this.headers, xform: nr }) } catch (s) { if (xe(s)) return { data: { user: null }, error: s }; throw s } } async listUsers(t) { var s, o, a, l, u, f, p; try { const m = { nextPage: null, lastPage: 0, total: 0 }, v = await Se(this.fetch, "GET", `${this.url}/admin/users`, { headers: this.headers, noResolveJson: !0, query: { page: (o = (s = t?.page) === null || s === void 0 ? void 0 : s.toString()) !== null && o !== void 0 ? o : "", per_page: (l = (a = t?.perPage) === null || a === void 0 ? void 0 : a.toString()) !== null && l !== void 0 ? l : "" }, xform: Bm }); if (v.error) throw v.error; const y = await v.json(), _ = (u = v.headers.get("x-total-count")) !== null && u !== void 0 ? u : 0, S = (p = (f = v.headers.get("link")) === null || f === void 0 ? void 0 : f.split(",")) !== null && p !== void 0 ? p : []; return S.length > 0 && (S.forEach(E => { const b = parseInt(E.split(";")[0].split("=")[1].substring(0, 1)), k = JSON.parse(E.split(";")[1].split("=")[1]); m[`${k}Page`] = b }), m.total = parseInt(_)), { data: Object.assign(Object.assign({}, y), m), error: null } } catch (m) { if (xe(m)) return { data: { users: [] }, error: m }; throw m } } async getUserById(t) { Ss(t); try { return await Se(this.fetch, "GET", `${this.url}/admin/users/${t}`, { headers: this.headers, xform: nr }) } catch (s) { if (xe(s)) return { data: { user: null }, error: s }; throw s } } async updateUserById(t, s) { Ss(t); try { return await Se(this.fetch, "PUT", `${this.url}/admin/users/${t}`, { body: s, headers: this.headers, xform: nr }) } catch (o) { if (xe(o)) return { data: { user: null }, error: o }; throw o } } async deleteUser(t, s = !1) { Ss(t); try { return await Se(this.fetch, "DELETE", `${this.url}/admin/users/${t}`, { headers: this.headers, body: { should_soft_delete: s }, xform: nr }) } catch (o) { if (xe(o)) return { data: { user: null }, error: o }; throw o } } async _listFactors(t) { Ss(t.id); try { const { data: s, error: o } = await Se(this.fetch, "GET", `${this.url}/admin/users/${t.id}/factors`, { headers: this.headers, xform: a => ({ data: { factors: a }, error: null }) }); return { data: s, error: o } } catch (s) { if (xe(s)) return { data: null, error: s }; throw s } } async _deleteFactor(t) { Ss(t.id), Ss(t.id); try { return { data: await Se(this.fetch, "DELETE", `${this.url}/admin/users/${t.id}/factors/${t.id}`, { headers: this.headers }), error: null } } catch (s) { if (xe(s)) return { data: null, error: s }; throw s } } async _listOAuthClients(t) { var s, o, a, l, u, f, p; try { const m = { nextPage: null, lastPage: 0, total: 0 }, v = await Se(this.fetch, "GET", `${this.url}/admin/oauth/clients`, { headers: this.headers, noResolveJson: !0, query: { page: (o = (s = t?.page) === null || s === void 0 ? void 0 : s.toString()) !== null && o !== void 0 ? o : "", per_page: (l = (a = t?.perPage) === null || a === void 0 ? void 0 : a.toString()) !== null && l !== void 0 ? l : "" }, xform: Bm }); if (v.error) throw v.error; const y = await v.json(), _ = (u = v.headers.get("x-total-count")) !== null && u !== void 0 ? u : 0, S = (p = (f = v.headers.get("link")) === null || f === void 0 ? void 0 : f.split(",")) !== null && p !== void 0 ? p : []; return S.length > 0 && (S.forEach(E => { const b = parseInt(E.split(";")[0].split("=")[1].substring(0, 1)), k = JSON.parse(E.split(";")[1].split("=")[1]); m[`${k}Page`] = b }), m.total = parseInt(_)), { data: Object.assign(Object.assign({}, y), m), error: null } } catch (m) { if (xe(m)) return { data: { clients: [] }, error: m }; throw m } } async _createOAuthClient(t) { try { return await Se(this.fetch, "POST", `${this.url}/admin/oauth/clients`, { body: t, headers: this.headers, xform: s => ({ data: s, error: null }) }) } catch (s) { if (xe(s)) return { data: null, error: s }; throw s } } async _getOAuthClient(t) { try { return await Se(this.fetch, "GET", `${this.url}/admin/oauth/clients/${t}`, { headers: this.headers, xform: s => ({ data: s, error: null }) }) } catch (s) { if (xe(s)) return { data: null, error: s }; throw s } } async _deleteOAuthClient(t) { try { return await Se(this.fetch, "DELETE", `${this.url}/admin/oauth/clients/${t}`, { headers: this.headers, xform: s => ({ data: s, error: null }) }) } catch (s) { if (xe(s)) return { data: null, error: s }; throw s } } async _regenerateOAuthClientSecret(t) { try { return await Se(this.fetch, "POST", `${this.url}/admin/oauth/clients/${t}/regenerate_secret`, { headers: this.headers, xform: s => ({ data: s, error: null }) }) } catch (s) { if (xe(s)) return { data: null, error: s }; throw s } } } function Vm(r = {}) { return { getItem: t => r[t] || null, setItem: (t, s) => { r[t] = s }, removeItem: t => { delete r[t] } } } const ks = { debug: !!(globalThis && Ky() && globalThis.localStorage && globalThis.localStorage.getItem("supabase.gotrue-js.locks.debug") === "true") }; class Gy extends Error { constructor(t) { super(t), this.isAcquireTimeout = !0 } } class jC extends Gy { } async function CC(r, t, s) { ks.debug && console.log("@supabase/gotrue-js: navigatorLock: acquire lock", r, t); const o = new globalThis.AbortController; return t > 0 && setTimeout(() => { o.abort(), ks.debug && console.log("@supabase/gotrue-js: navigatorLock acquire timed out", r) }, t), await Promise.resolve().then(() => globalThis.navigator.locks.request(r, t === 0 ? { mode: "exclusive", ifAvailable: !0 } : { mode: "exclusive", signal: o.signal }, async a => { if (a) { ks.debug && console.log("@supabase/gotrue-js: navigatorLock: acquired", r, a.name); try { return await s() } finally { ks.debug && console.log("@supabase/gotrue-js: navigatorLock: released", r, a.name) } } else { if (t === 0) throw ks.debug && console.log("@supabase/gotrue-js: navigatorLock: not immediately available", r), new jC(`Acquiring an exclusive Navigator LockManager lock "${r}" immediately failed`); if (ks.debug) try { const l = await globalThis.navigator.locks.query(); console.log("@supabase/gotrue-js: Navigator LockManager state", JSON.stringify(l, null, "  ")) } catch (l) { console.warn("@supabase/gotrue-js: Error when querying Navigator LockManager state", l) } return console.warn("@supabase/gotrue-js: Navigator LockManager returned a null lock when using #request without ifAvailable set to true, it appears this browser is not following the LockManager spec https://developer.mozilla.org/en-US/docs/Web/API/LockManager/request"), await s() } })) } function NC() { if (typeof globalThis != "object") try { Object.defineProperty(Object.prototype, "__magic__", { get: function () { return this }, configurable: !0 }), __magic__.globalThis = __magic__, delete Object.prototype.__magic__ } catch { typeof self < "u" && (self.globalThis = self) } } function Yy(r) { if (!/^0x[a-fA-F0-9]{40}$/.test(r)) throw new Error(`@supabase/auth-js: Address "${r}" is invalid.`); return r.toLowerCase() } function TC(r) { return parseInt(r, 16) } function PC(r) { const t = new TextEncoder().encode(r); return "0x" + Array.from(t, o => o.toString(16).padStart(2, "0")).join("") } function RC(r) {
  var t; const { chainId: s, domain: o, expirationTime: a, issuedAt: l = new Date, nonce: u, notBefore: f, requestId: p, resources: m, scheme: v, uri: y, version: _ } = r; {
    if (!Number.isInteger(s)) throw new Error(`@supabase/auth-js: Invalid SIWE message field "chainId". Chain ID must be a EIP-155 chain ID. Provided value: ${s}`); if (!o) throw new Error('@supabase/auth-js: Invalid SIWE message field "domain". Domain must be provided.'); if (u && u.length < 8) throw new Error(`@supabase/auth-js: Invalid SIWE message field "nonce". Nonce must be at least 8 characters. Provided value: ${u}`); if (!y) throw new Error('@supabase/auth-js: Invalid SIWE message field "uri". URI must be provided.'); if (_ !== "1") throw new Error(`@supabase/auth-js: Invalid SIWE message field "version". Version must be '1'. Provided value: ${_}`); if (!((t = r.statement) === null || t === void 0) && t.includes(`
`)) throw new Error(`@supabase/auth-js: Invalid SIWE message field "statement". Statement must not include '\\n'. Provided value: ${r.statement}`)
  } const S = Yy(r.address), E = v ? `${v}://${o}` : o, b = r.statement ? `${r.statement}
`: "", k = `${E} wants you to sign in with your Ethereum account:
${S}

${b}`; let C = `URI: ${y}
Version: ${_}
Chain ID: ${s}${u ? `
Nonce: ${u}` : ""}
Issued At: ${l.toISOString()}`; if (a && (C += `
Expiration Time: ${a.toISOString()}`), f && (C += `
Not Before: ${f.toISOString()}`), p && (C += `
Request ID: ${p}`), m) {
    let T = `
Resources:`; for (const P of m) {
      if (!P || typeof P != "string") throw new Error(`@supabase/auth-js: Invalid SIWE message field "resources". Every resource must be a valid string. Provided value: ${P}`); T += `
- ${P}`
    } C += T
  } return `${k}
${C}`
} class et extends Error { constructor({ message: t, code: s, cause: o, name: a }) { var l; super(t, { cause: o }), this.__isWebAuthnError = !0, this.name = (l = a ?? (o instanceof Error ? o.name : void 0)) !== null && l !== void 0 ? l : "Unknown Error", this.code = s } } class Oa extends et { constructor(t, s) { super({ code: "ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY", cause: s, message: t }), this.name = "WebAuthnUnknownError", this.originalError = s } } function AC({ error: r, options: t }) { var s, o, a; const { publicKey: l } = t; if (!l) throw Error("options was missing required publicKey property"); if (r.name === "AbortError") { if (t.signal instanceof AbortSignal) return new et({ message: "Registration ceremony was sent an abort signal", code: "ERROR_CEREMONY_ABORTED", cause: r }) } else if (r.name === "ConstraintError") { if (((s = l.authenticatorSelection) === null || s === void 0 ? void 0 : s.requireResidentKey) === !0) return new et({ message: "Discoverable credentials were required but no available authenticator supported it", code: "ERROR_AUTHENTICATOR_MISSING_DISCOVERABLE_CREDENTIAL_SUPPORT", cause: r }); if (t.mediation === "conditional" && ((o = l.authenticatorSelection) === null || o === void 0 ? void 0 : o.userVerification) === "required") return new et({ message: "User verification was required during automatic registration but it could not be performed", code: "ERROR_AUTO_REGISTER_USER_VERIFICATION_FAILURE", cause: r }); if (((a = l.authenticatorSelection) === null || a === void 0 ? void 0 : a.userVerification) === "required") return new et({ message: "User verification was required but no available authenticator supported it", code: "ERROR_AUTHENTICATOR_MISSING_USER_VERIFICATION_SUPPORT", cause: r }) } else { if (r.name === "InvalidStateError") return new et({ message: "The authenticator was previously registered", code: "ERROR_AUTHENTICATOR_PREVIOUSLY_REGISTERED", cause: r }); if (r.name === "NotAllowedError") return new et({ message: r.message, code: "ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY", cause: r }); if (r.name === "NotSupportedError") return l.pubKeyCredParams.filter(f => f.type === "public-key").length === 0 ? new et({ message: 'No entry in pubKeyCredParams was of type "public-key"', code: "ERROR_MALFORMED_PUBKEYCREDPARAMS", cause: r }) : new et({ message: "No available authenticator supported any of the specified pubKeyCredParams algorithms", code: "ERROR_AUTHENTICATOR_NO_SUPPORTED_PUBKEYCREDPARAMS_ALG", cause: r }); if (r.name === "SecurityError") { const u = window.location.hostname; if (Qy(u)) { if (l.rp.id !== u) return new et({ message: `The RP ID "${l.rp.id}" is invalid for this domain`, code: "ERROR_INVALID_RP_ID", cause: r }) } else return new et({ message: `${window.location.hostname} is an invalid domain`, code: "ERROR_INVALID_DOMAIN", cause: r }) } else if (r.name === "TypeError") { if (l.user.id.byteLength < 1 || l.user.id.byteLength > 64) return new et({ message: "User ID was not between 1 and 64 characters", code: "ERROR_INVALID_USER_ID_LENGTH", cause: r }) } else if (r.name === "UnknownError") return new et({ message: "The authenticator was unable to process the specified options, or could not create a new credential", code: "ERROR_AUTHENTICATOR_GENERAL_ERROR", cause: r }) } return new et({ message: "a Non-Webauthn related error has occurred", code: "ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY", cause: r }) } function OC({ error: r, options: t }) { const { publicKey: s } = t; if (!s) throw Error("options was missing required publicKey property"); if (r.name === "AbortError") { if (t.signal instanceof AbortSignal) return new et({ message: "Authentication ceremony was sent an abort signal", code: "ERROR_CEREMONY_ABORTED", cause: r }) } else { if (r.name === "NotAllowedError") return new et({ message: r.message, code: "ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY", cause: r }); if (r.name === "SecurityError") { const o = window.location.hostname; if (Qy(o)) { if (s.rpId !== o) return new et({ message: `The RP ID "${s.rpId}" is invalid for this domain`, code: "ERROR_INVALID_RP_ID", cause: r }) } else return new et({ message: `${window.location.hostname} is an invalid domain`, code: "ERROR_INVALID_DOMAIN", cause: r }) } else if (r.name === "UnknownError") return new et({ message: "The authenticator was unable to process the specified options, or could not create a new assertion signature", code: "ERROR_AUTHENTICATOR_GENERAL_ERROR", cause: r }) } return new et({ message: "a Non-Webauthn related error has occurred", code: "ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY", cause: r }) } var Jy = function (r, t) { var s = {}; for (var o in r) Object.prototype.hasOwnProperty.call(r, o) && t.indexOf(o) < 0 && (s[o] = r[o]); if (r != null && typeof Object.getOwnPropertySymbols == "function") for (var a = 0, o = Object.getOwnPropertySymbols(r); a < o.length; a++)t.indexOf(o[a]) < 0 && Object.prototype.propertyIsEnumerable.call(r, o[a]) && (s[o[a]] = r[o[a]]); return s }; class IC { createNewAbortSignal() { if (this.controller) { const s = new Error("Cancelling existing WebAuthn API call for new one"); s.name = "AbortError", this.controller.abort(s) } const t = new AbortController; return this.controller = t, t.signal } cancelCeremony() { if (this.controller) { const t = new Error("Manually cancelling existing WebAuthn API call"); t.name = "AbortError", this.controller.abort(t), this.controller = void 0 } } } const DC = new IC; function $C(r) { if (!r) throw new Error("Credential creation options are required"); if (typeof PublicKeyCredential < "u" && "parseCreationOptionsFromJSON" in PublicKeyCredential && typeof PublicKeyCredential.parseCreationOptionsFromJSON == "function") return PublicKeyCredential.parseCreationOptionsFromJSON(r); const { challenge: t, user: s, excludeCredentials: o } = r, a = Jy(r, ["challenge", "user", "excludeCredentials"]), l = As(t).buffer, u = Object.assign(Object.assign({}, s), { id: As(s.id).buffer }), f = Object.assign(Object.assign({}, a), { challenge: l, user: u }); if (o && o.length > 0) { f.excludeCredentials = new Array(o.length); for (let p = 0; p < o.length; p++) { const m = o[p]; f.excludeCredentials[p] = Object.assign(Object.assign({}, m), { id: As(m.id).buffer, type: m.type || "public-key", transports: m.transports }) } } return f } function LC(r) { if (!r) throw new Error("Credential request options are required"); if (typeof PublicKeyCredential < "u" && "parseRequestOptionsFromJSON" in PublicKeyCredential && typeof PublicKeyCredential.parseRequestOptionsFromJSON == "function") return PublicKeyCredential.parseRequestOptionsFromJSON(r); const { challenge: t, allowCredentials: s } = r, o = Jy(r, ["challenge", "allowCredentials"]), a = As(t).buffer, l = Object.assign(Object.assign({}, o), { challenge: a }); if (s && s.length > 0) { l.allowCredentials = new Array(s.length); for (let u = 0; u < s.length; u++) { const f = s[u]; l.allowCredentials[u] = Object.assign(Object.assign({}, f), { id: As(f.id).buffer, type: f.type || "public-key", transports: f.transports }) } } return l } function MC(r) { var t; if ("toJSON" in r && typeof r.toJSON == "function") return r.toJSON(); const s = r; return { id: r.id, rawId: r.id, response: { attestationObject: Rr(new Uint8Array(r.response.attestationObject)), clientDataJSON: Rr(new Uint8Array(r.response.clientDataJSON)) }, type: "public-key", clientExtensionResults: r.getClientExtensionResults(), authenticatorAttachment: (t = s.authenticatorAttachment) !== null && t !== void 0 ? t : void 0 } } function UC(r) { var t; if ("toJSON" in r && typeof r.toJSON == "function") return r.toJSON(); const s = r, o = r.getClientExtensionResults(), a = r.response; return { id: r.id, rawId: r.id, response: { authenticatorData: Rr(new Uint8Array(a.authenticatorData)), clientDataJSON: Rr(new Uint8Array(a.clientDataJSON)), signature: Rr(new Uint8Array(a.signature)), userHandle: a.userHandle ? Rr(new Uint8Array(a.userHandle)) : void 0 }, type: "public-key", clientExtensionResults: o, authenticatorAttachment: (t = s.authenticatorAttachment) !== null && t !== void 0 ? t : void 0 } } function Qy(r) { return r === "localhost" || /^([a-z0-9]+(-[a-z0-9]+)*\.)+[a-z]{2,}$/i.test(r) } function Wm() { var r, t; return !!($t() && "PublicKeyCredential" in window && window.PublicKeyCredential && "credentials" in navigator && typeof ((r = navigator?.credentials) === null || r === void 0 ? void 0 : r.create) == "function" && typeof ((t = navigator?.credentials) === null || t === void 0 ? void 0 : t.get) == "function") } async function zC(r) { try { const t = await navigator.credentials.create(r); return t ? t instanceof PublicKeyCredential ? { data: t, error: null } : { data: null, error: new Oa("Browser returned unexpected credential type", t) } : { data: null, error: new Oa("Empty credential response", t) } } catch (t) { return { data: null, error: AC({ error: t, options: r }) } } } async function FC(r) { try { const t = await navigator.credentials.get(r); return t ? t instanceof PublicKeyCredential ? { data: t, error: null } : { data: null, error: new Oa("Browser returned unexpected credential type", t) } : { data: null, error: new Oa("Empty credential response", t) } } catch (t) { return { data: null, error: OC({ error: t, options: r }) } } } const BC = { hints: ["security-key"], authenticatorSelection: { authenticatorAttachment: "cross-platform", requireResidentKey: !1, userVerification: "preferred", residentKey: "discouraged" }, attestation: "none" }, VC = { userVerification: "preferred", hints: ["security-key"] }; function Ia(...r) { const t = a => a !== null && typeof a == "object" && !Array.isArray(a), s = a => a instanceof ArrayBuffer || ArrayBuffer.isView(a), o = {}; for (const a of r) if (a) for (const l in a) { const u = a[l]; if (u !== void 0) if (Array.isArray(u)) o[l] = u; else if (s(u)) o[l] = u; else if (t(u)) { const f = o[l]; t(f) ? o[l] = Ia(f, u) : o[l] = Ia(u) } else o[l] = u } return o } function WC(r, t) { return Ia(BC, r, t || {}) } function HC(r, t) { return Ia(VC, r, t || {}) } class KC { constructor(t) { this.client = t, this.enroll = this._enroll.bind(this), this.challenge = this._challenge.bind(this), this.verify = this._verify.bind(this), this.authenticate = this._authenticate.bind(this), this.register = this._register.bind(this) } async _enroll(t) { return this.client.mfa.enroll(Object.assign(Object.assign({}, t), { factorType: "webauthn" })) } async _challenge({ factorId: t, webauthn: s, friendlyName: o, signal: a }, l) { try { const { data: u, error: f } = await this.client.mfa.challenge({ factorId: t, webauthn: s }); if (!u) return { data: null, error: f }; const p = a ?? DC.createNewAbortSignal(); if (u.webauthn.type === "create") { const { user: m } = u.webauthn.credential_options.publicKey; m.name || (m.name = `${m.id}:${o}`), m.displayName || (m.displayName = m.name) } switch (u.webauthn.type) { case "create": { const m = WC(u.webauthn.credential_options.publicKey, l?.create), { data: v, error: y } = await zC({ publicKey: m, signal: p }); return v ? { data: { factorId: t, challengeId: u.id, webauthn: { type: u.webauthn.type, credential_response: v } }, error: null } : { data: null, error: y } } case "request": { const m = HC(u.webauthn.credential_options.publicKey, l?.request), { data: v, error: y } = await FC(Object.assign(Object.assign({}, u.webauthn.credential_options), { publicKey: m, signal: p })); return v ? { data: { factorId: t, challengeId: u.id, webauthn: { type: u.webauthn.type, credential_response: v } }, error: null } : { data: null, error: y } } } } catch (u) { return xe(u) ? { data: null, error: u } : { data: null, error: new Pr("Unexpected error in challenge", u) } } } async _verify({ challengeId: t, factorId: s, webauthn: o }) { return this.client.mfa.verify({ factorId: s, challengeId: t, webauthn: o }) } async _authenticate({ factorId: t, webauthn: { rpId: s = typeof window < "u" ? window.location.hostname : void 0, rpOrigins: o = typeof window < "u" ? [window.location.origin] : void 0, signal: a } }, l) { if (!s) return { data: null, error: new Vo("rpId is required for WebAuthn authentication") }; try { if (!Wm()) return { data: null, error: new Pr("Browser does not support WebAuthn", null) }; const { data: u, error: f } = await this.challenge({ factorId: t, webauthn: { rpId: s, rpOrigins: o }, signal: a }, { request: l }); if (!u) return { data: null, error: f }; const { webauthn: p } = u; return this._verify({ factorId: t, challengeId: u.challengeId, webauthn: { type: p.type, rpId: s, rpOrigins: o, credential_response: p.credential_response } }) } catch (u) { return xe(u) ? { data: null, error: u } : { data: null, error: new Pr("Unexpected error in authenticate", u) } } } async _register({ friendlyName: t, rpId: s = typeof window < "u" ? window.location.hostname : void 0, rpOrigins: o = typeof window < "u" ? [window.location.origin] : void 0, signal: a }, l) { if (!s) return { data: null, error: new Vo("rpId is required for WebAuthn registration") }; try { if (!Wm()) return { data: null, error: new Pr("Browser does not support WebAuthn", null) }; const { data: u, error: f } = await this._enroll({ friendlyName: t }); if (!u) return await this.client.mfa.listFactors().then(v => { var y; return (y = v.data) === null || y === void 0 ? void 0 : y.all.find(_ => _.factor_type === "webauthn" && _.friendly_name === t && _.status !== "unverified") }).then(v => v ? this.client.mfa.unenroll({ factorId: v?.id }) : void 0), { data: null, error: f }; const { data: p, error: m } = await this._challenge({ factorId: u.id, friendlyName: u.friendly_name, webauthn: { rpId: s, rpOrigins: o }, signal: a }, { create: l }); return p ? this._verify({ factorId: u.id, challengeId: p.challengeId, webauthn: { rpId: s, rpOrigins: o, type: p.webauthn.type, credential_response: p.webauthn.credential_response } }) : { data: null, error: m } } catch (u) { return xe(u) ? { data: null, error: u } : { data: null, error: new Pr("Unexpected error in register", u) } } } } NC(); const qC = { url: Bj, storageKey: Vj, autoRefreshToken: !0, persistSession: !0, detectSessionInUrl: !0, headers: Wj, flowType: "implicit", debug: !1, hasCustomAuthorizationHeader: !1 }; async function Hm(r, t, s) { return await s() } const Es = {}; class Wo {
  get jwks() { var t, s; return (s = (t = Es[this.storageKey]) === null || t === void 0 ? void 0 : t.jwks) !== null && s !== void 0 ? s : { keys: [] } } set jwks(t) { Es[this.storageKey] = Object.assign(Object.assign({}, Es[this.storageKey]), { jwks: t }) } get jwks_cached_at() { var t, s; return (s = (t = Es[this.storageKey]) === null || t === void 0 ? void 0 : t.cachedAt) !== null && s !== void 0 ? s : Number.MIN_SAFE_INTEGER } set jwks_cached_at(t) { Es[this.storageKey] = Object.assign(Object.assign({}, Es[this.storageKey]), { cachedAt: t }) } constructor(t) { var s, o; this.userStorage = null, this.memoryStorage = null, this.stateChangeEmitters = new Map, this.autoRefreshTicker = null, this.visibilityChangedCallback = null, this.refreshingDeferred = null, this.initializePromise = null, this.detectSessionInUrl = !0, this.hasCustomAuthorizationHeader = !1, this.suppressGetSessionWarning = !1, this.lockAcquired = !1, this.pendingInLock = [], this.broadcastChannel = null, this.logger = console.log, this.instanceID = Wo.nextInstanceID, Wo.nextInstanceID += 1, this.instanceID > 0 && $t() && console.warn("Multiple GoTrueClient instances detected in the same browser context. It is not an error, but this should be avoided as it may produce undefined behavior when used concurrently under the same storage key."); const a = Object.assign(Object.assign({}, qC), t); if (this.logDebugMessages = !!a.debug, typeof a.debug == "function" && (this.logger = a.debug), this.persistSession = a.persistSession, this.storageKey = a.storageKey, this.autoRefreshToken = a.autoRefreshToken, this.admin = new EC({ url: a.url, headers: a.headers, fetch: a.fetch }), this.url = a.url, this.headers = a.headers, this.fetch = qy(a.fetch), this.lock = a.lock || Hm, this.detectSessionInUrl = a.detectSessionInUrl, this.flowType = a.flowType, this.hasCustomAuthorizationHeader = a.hasCustomAuthorizationHeader, a.lock ? this.lock = a.lock : $t() && (!((s = globalThis?.navigator) === null || s === void 0) && s.locks) ? this.lock = CC : this.lock = Hm, this.jwks || (this.jwks = { keys: [] }, this.jwks_cached_at = Number.MIN_SAFE_INTEGER), this.mfa = { verify: this._verify.bind(this), enroll: this._enroll.bind(this), unenroll: this._unenroll.bind(this), challenge: this._challenge.bind(this), listFactors: this._listFactors.bind(this), challengeAndVerify: this._challengeAndVerify.bind(this), getAuthenticatorAssuranceLevel: this._getAuthenticatorAssuranceLevel.bind(this), webauthn: new KC(this) }, this.persistSession ? (a.storage ? this.storage = a.storage : Ky() ? this.storage = globalThis.localStorage : (this.memoryStorage = {}, this.storage = Vm(this.memoryStorage)), a.userStorage && (this.userStorage = a.userStorage)) : (this.memoryStorage = {}, this.storage = Vm(this.memoryStorage)), $t() && globalThis.BroadcastChannel && this.persistSession && this.storageKey) { try { this.broadcastChannel = new globalThis.BroadcastChannel(this.storageKey) } catch (l) { console.error("Failed to create a new BroadcastChannel, multi-tab state changes will not be available", l) } (o = this.broadcastChannel) === null || o === void 0 || o.addEventListener("message", async l => { this._debug("received broadcast notification from other tab or client", l), await this._notifyAllSubscribers(l.data.event, l.data.session, !1) }) } this.initialize() } _debug(...t) { return this.logDebugMessages && this.logger(`GoTrueClient@${this.instanceID} (${Vy}) ${new Date().toISOString()}`, ...t), this } async initialize() { return this.initializePromise ? await this.initializePromise : (this.initializePromise = (async () => await this._acquireLock(-1, async () => await this._initialize()))(), await this.initializePromise) } async _initialize() { var t; try { const s = sC(window.location.href); let o = "none"; if (this._isImplicitGrantCallback(s) ? o = "implicit" : await this._isPKCECallback(s) && (o = "pkce"), $t() && this.detectSessionInUrl && o !== "none") { const { data: a, error: l } = await this._getSessionFromURL(s, o); if (l) { if (this._debug("#_initialize()", "error detecting session from URL", l), Jj(l)) { const p = (t = l.details) === null || t === void 0 ? void 0 : t.code; if (p === "identity_already_exists" || p === "identity_not_found" || p === "single_identity_not_deletable") return { error: l } } return await this._removeSession(), { error: l } } const { session: u, redirectType: f } = a; return this._debug("#_initialize()", "detected session in URL", u, "redirect type", f), await this._saveSession(u), setTimeout(async () => { f === "recovery" ? await this._notifyAllSubscribers("PASSWORD_RECOVERY", u) : await this._notifyAllSubscribers("SIGNED_IN", u) }, 0), { error: null } } return await this._recoverAndRefresh(), { error: null } } catch (s) { return xe(s) ? { error: s } : { error: new Pr("Unexpected error during initialization", s) } } finally { await this._handleVisibilityChange(), this._debug("#_initialize()", "end") } } async signInAnonymously(t) { var s, o, a; try { const l = await Se(this.fetch, "POST", `${this.url}/signup`, { headers: this.headers, body: { data: (o = (s = t?.options) === null || s === void 0 ? void 0 : s.data) !== null && o !== void 0 ? o : {}, gotrue_meta_security: { captcha_token: (a = t?.options) === null || a === void 0 ? void 0 : a.captchaToken } }, xform: nn }), { data: u, error: f } = l; if (f || !u) return { data: { user: null, session: null }, error: f }; const p = u.session, m = u.user; return u.session && (await this._saveSession(u.session), await this._notifyAllSubscribers("SIGNED_IN", p)), { data: { user: m, session: p }, error: null } } catch (l) { if (xe(l)) return { data: { user: null, session: null }, error: l }; throw l } } async signUp(t) { var s, o, a; try { let l; if ("email" in t) { const { email: v, password: y, options: _ } = t; let S = null, E = null; this.flowType === "pkce" && ([S, E] = await _s(this.storage, this.storageKey)), l = await Se(this.fetch, "POST", `${this.url}/signup`, { headers: this.headers, redirectTo: _?.emailRedirectTo, body: { email: v, password: y, data: (s = _?.data) !== null && s !== void 0 ? s : {}, gotrue_meta_security: { captcha_token: _?.captchaToken }, code_challenge: S, code_challenge_method: E }, xform: nn }) } else if ("phone" in t) { const { phone: v, password: y, options: _ } = t; l = await Se(this.fetch, "POST", `${this.url}/signup`, { headers: this.headers, body: { phone: v, password: y, data: (o = _?.data) !== null && o !== void 0 ? o : {}, channel: (a = _?.channel) !== null && a !== void 0 ? a : "sms", gotrue_meta_security: { captcha_token: _?.captchaToken } }, xform: nn }) } else throw new va("You must provide either an email or phone number and a password"); const { data: u, error: f } = l; if (f || !u) return { data: { user: null, session: null }, error: f }; const p = u.session, m = u.user; return u.session && (await this._saveSession(u.session), await this._notifyAllSubscribers("SIGNED_IN", p)), { data: { user: m, session: p }, error: null } } catch (l) { if (xe(l)) return { data: { user: null, session: null }, error: l }; throw l } } async signInWithPassword(t) { try { let s; if ("email" in t) { const { email: l, password: u, options: f } = t; s = await Se(this.fetch, "POST", `${this.url}/token?grant_type=password`, { headers: this.headers, body: { email: l, password: u, gotrue_meta_security: { captcha_token: f?.captchaToken } }, xform: Fm }) } else if ("phone" in t) { const { phone: l, password: u, options: f } = t; s = await Se(this.fetch, "POST", `${this.url}/token?grant_type=password`, { headers: this.headers, body: { phone: l, password: u, gotrue_meta_security: { captcha_token: f?.captchaToken } }, xform: Fm }) } else throw new va("You must provide either an email or phone number and a password"); const { data: o, error: a } = s; return a ? { data: { user: null, session: null }, error: a } : !o || !o.session || !o.user ? { data: { user: null, session: null }, error: new bs } : (o.session && (await this._saveSession(o.session), await this._notifyAllSubscribers("SIGNED_IN", o.session)), { data: Object.assign({ user: o.user, session: o.session }, o.weak_password ? { weakPassword: o.weak_password } : null), error: a }) } catch (s) { if (xe(s)) return { data: { user: null, session: null }, error: s }; throw s } } async signInWithOAuth(t) { var s, o, a, l; return await this._handleProviderSignIn(t.provider, { redirectTo: (s = t.options) === null || s === void 0 ? void 0 : s.redirectTo, scopes: (o = t.options) === null || o === void 0 ? void 0 : o.scopes, queryParams: (a = t.options) === null || a === void 0 ? void 0 : a.queryParams, skipBrowserRedirect: (l = t.options) === null || l === void 0 ? void 0 : l.skipBrowserRedirect }) } async exchangeCodeForSession(t) { return await this.initializePromise, this._acquireLock(-1, async () => this._exchangeCodeForSession(t)) } async signInWithWeb3(t) { const { chain: s } = t; switch (s) { case "ethereum": return await this.signInWithEthereum(t); case "solana": return await this.signInWithSolana(t); default: throw new Error(`@supabase/auth-js: Unsupported chain "${s}"`) } } async signInWithEthereum(t) { var s, o, a, l, u, f, p, m, v, y, _; let S, E; if ("message" in t) S = t.message, E = t.signature; else { const { chain: b, wallet: k, statement: C, options: T } = t; let P; if ($t()) if (typeof k == "object") P = k; else { const L = window; if ("ethereum" in L && typeof L.ethereum == "object" && "request" in L.ethereum && typeof L.ethereum.request == "function") P = L.ethereum; else throw new Error("@supabase/auth-js: No compatible Ethereum wallet interface on the window object (window.ethereum) detected. Make sure the user already has a wallet installed and connected for this app. Prefer passing the wallet interface object directly to signInWithWeb3({ chain: 'ethereum', wallet: resolvedUserWallet }) instead.") } else { if (typeof k != "object" || !T?.url) throw new Error("@supabase/auth-js: Both wallet and url must be specified in non-browser environments."); P = k } const I = new URL((s = T?.url) !== null && s !== void 0 ? s : window.location.href), O = await P.request({ method: "eth_requestAccounts" }).then(L => L).catch(() => { throw new Error("@supabase/auth-js: Wallet method eth_requestAccounts is missing or invalid") }); if (!O || O.length === 0) throw new Error("@supabase/auth-js: No accounts available. Please ensure the wallet is connected."); const V = Yy(O[0]); let M = (o = T?.signInWithEthereum) === null || o === void 0 ? void 0 : o.chainId; if (!M) { const L = await P.request({ method: "eth_chainId" }); M = TC(L) } const R = { domain: I.host, address: V, statement: C, uri: I.href, version: "1", chainId: M, nonce: (a = T?.signInWithEthereum) === null || a === void 0 ? void 0 : a.nonce, issuedAt: (u = (l = T?.signInWithEthereum) === null || l === void 0 ? void 0 : l.issuedAt) !== null && u !== void 0 ? u : new Date, expirationTime: (f = T?.signInWithEthereum) === null || f === void 0 ? void 0 : f.expirationTime, notBefore: (p = T?.signInWithEthereum) === null || p === void 0 ? void 0 : p.notBefore, requestId: (m = T?.signInWithEthereum) === null || m === void 0 ? void 0 : m.requestId, resources: (v = T?.signInWithEthereum) === null || v === void 0 ? void 0 : v.resources }; S = RC(R), E = await P.request({ method: "personal_sign", params: [PC(S), V] }) } try { const { data: b, error: k } = await Se(this.fetch, "POST", `${this.url}/token?grant_type=web3`, { headers: this.headers, body: Object.assign({ chain: "ethereum", message: S, signature: E }, !((y = t.options) === null || y === void 0) && y.captchaToken ? { gotrue_meta_security: { captcha_token: (_ = t.options) === null || _ === void 0 ? void 0 : _.captchaToken } } : null), xform: nn }); if (k) throw k; return !b || !b.session || !b.user ? { data: { user: null, session: null }, error: new bs } : (b.session && (await this._saveSession(b.session), await this._notifyAllSubscribers("SIGNED_IN", b.session)), { data: Object.assign({}, b), error: k }) } catch (b) { if (xe(b)) return { data: { user: null, session: null }, error: b }; throw b } } async signInWithSolana(t) {
    var s, o, a, l, u, f, p, m, v, y, _, S; let E, b; if ("message" in t) E = t.message, b = t.signature; else {
      const { chain: k, wallet: C, statement: T, options: P } = t; let I; if ($t()) if (typeof C == "object") I = C; else { const V = window; if ("solana" in V && typeof V.solana == "object" && ("signIn" in V.solana && typeof V.solana.signIn == "function" || "signMessage" in V.solana && typeof V.solana.signMessage == "function")) I = V.solana; else throw new Error("@supabase/auth-js: No compatible Solana wallet interface on the window object (window.solana) detected. Make sure the user already has a wallet installed and connected for this app. Prefer passing the wallet interface object directly to signInWithWeb3({ chain: 'solana', wallet: resolvedUserWallet }) instead.") } else { if (typeof C != "object" || !P?.url) throw new Error("@supabase/auth-js: Both wallet and url must be specified in non-browser environments."); I = C } const O = new URL((s = P?.url) !== null && s !== void 0 ? s : window.location.href); if ("signIn" in I && I.signIn) { const V = await I.signIn(Object.assign(Object.assign(Object.assign({ issuedAt: new Date().toISOString() }, P?.signInWithSolana), { version: "1", domain: O.host, uri: O.href }), T ? { statement: T } : null)); let M; if (Array.isArray(V) && V[0] && typeof V[0] == "object") M = V[0]; else if (V && typeof V == "object" && "signedMessage" in V && "signature" in V) M = V; else throw new Error("@supabase/auth-js: Wallet method signIn() returned unrecognized value"); if ("signedMessage" in M && "signature" in M && (typeof M.signedMessage == "string" || M.signedMessage instanceof Uint8Array) && M.signature instanceof Uint8Array) E = typeof M.signedMessage == "string" ? M.signedMessage : new TextDecoder().decode(M.signedMessage), b = M.signature; else throw new Error("@supabase/auth-js: Wallet method signIn() API returned object without signedMessage and signature fields") } else {
        if (!("signMessage" in I) || typeof I.signMessage != "function" || !("publicKey" in I) || typeof I != "object" || !I.publicKey || !("toBase58" in I.publicKey) || typeof I.publicKey.toBase58 != "function") throw new Error("@supabase/auth-js: Wallet does not have a compatible signMessage() and publicKey.toBase58() API"); E = [`${O.host} wants you to sign in with your Solana account:`, I.publicKey.toBase58(), ...T ? ["", T, ""] : [""], "Version: 1", `URI: ${O.href}`, `Issued At: ${(a = (o = P?.signInWithSolana) === null || o === void 0 ? void 0 : o.issuedAt) !== null && a !== void 0 ? a : new Date().toISOString()}`, ...!((l = P?.signInWithSolana) === null || l === void 0) && l.notBefore ? [`Not Before: ${P.signInWithSolana.notBefore}`] : [], ...!((u = P?.signInWithSolana) === null || u === void 0) && u.expirationTime ? [`Expiration Time: ${P.signInWithSolana.expirationTime}`] : [], ...!((f = P?.signInWithSolana) === null || f === void 0) && f.chainId ? [`Chain ID: ${P.signInWithSolana.chainId}`] : [], ...!((p = P?.signInWithSolana) === null || p === void 0) && p.nonce ? [`Nonce: ${P.signInWithSolana.nonce}`] : [], ...!((m = P?.signInWithSolana) === null || m === void 0) && m.requestId ? [`Request ID: ${P.signInWithSolana.requestId}`] : [], ...!((y = (v = P?.signInWithSolana) === null || v === void 0 ? void 0 : v.resources) === null || y === void 0) && y.length ? ["Resources", ...P.signInWithSolana.resources.map(M => `- ${M}`)] : []].join(`
`); const V = await I.signMessage(new TextEncoder().encode(E), "utf8"); if (!V || !(V instanceof Uint8Array)) throw new Error("@supabase/auth-js: Wallet signMessage() API returned an recognized value"); b = V
      }
    } try { const { data: k, error: C } = await Se(this.fetch, "POST", `${this.url}/token?grant_type=web3`, { headers: this.headers, body: Object.assign({ chain: "solana", message: E, signature: Rr(b) }, !((_ = t.options) === null || _ === void 0) && _.captchaToken ? { gotrue_meta_security: { captcha_token: (S = t.options) === null || S === void 0 ? void 0 : S.captchaToken } } : null), xform: nn }); if (C) throw C; return !k || !k.session || !k.user ? { data: { user: null, session: null }, error: new bs } : (k.session && (await this._saveSession(k.session), await this._notifyAllSubscribers("SIGNED_IN", k.session)), { data: Object.assign({}, k), error: C }) } catch (k) { if (xe(k)) return { data: { user: null, session: null }, error: k }; throw k }
  } async _exchangeCodeForSession(t) { const s = await Cr(this.storage, `${this.storageKey}-code-verifier`), [o, a] = (s ?? "").split("/"); try { const { data: l, error: u } = await Se(this.fetch, "POST", `${this.url}/token?grant_type=pkce`, { headers: this.headers, body: { auth_code: t, code_verifier: o }, xform: nn }); if (await Zn(this.storage, `${this.storageKey}-code-verifier`), u) throw u; return !l || !l.session || !l.user ? { data: { user: null, session: null, redirectType: null }, error: new bs } : (l.session && (await this._saveSession(l.session), await this._notifyAllSubscribers("SIGNED_IN", l.session)), { data: Object.assign(Object.assign({}, l), { redirectType: a ?? null }), error: u }) } catch (l) { if (xe(l)) return { data: { user: null, session: null, redirectType: null }, error: l }; throw l } } async signInWithIdToken(t) { try { const { options: s, provider: o, token: a, access_token: l, nonce: u } = t, f = await Se(this.fetch, "POST", `${this.url}/token?grant_type=id_token`, { headers: this.headers, body: { provider: o, id_token: a, access_token: l, nonce: u, gotrue_meta_security: { captcha_token: s?.captchaToken } }, xform: nn }), { data: p, error: m } = f; return m ? { data: { user: null, session: null }, error: m } : !p || !p.session || !p.user ? { data: { user: null, session: null }, error: new bs } : (p.session && (await this._saveSession(p.session), await this._notifyAllSubscribers("SIGNED_IN", p.session)), { data: p, error: m }) } catch (s) { if (xe(s)) return { data: { user: null, session: null }, error: s }; throw s } } async signInWithOtp(t) { var s, o, a, l, u; try { if ("email" in t) { const { email: f, options: p } = t; let m = null, v = null; this.flowType === "pkce" && ([m, v] = await _s(this.storage, this.storageKey)); const { error: y } = await Se(this.fetch, "POST", `${this.url}/otp`, { headers: this.headers, body: { email: f, data: (s = p?.data) !== null && s !== void 0 ? s : {}, create_user: (o = p?.shouldCreateUser) !== null && o !== void 0 ? o : !0, gotrue_meta_security: { captcha_token: p?.captchaToken }, code_challenge: m, code_challenge_method: v }, redirectTo: p?.emailRedirectTo }); return { data: { user: null, session: null }, error: y } } if ("phone" in t) { const { phone: f, options: p } = t, { data: m, error: v } = await Se(this.fetch, "POST", `${this.url}/otp`, { headers: this.headers, body: { phone: f, data: (a = p?.data) !== null && a !== void 0 ? a : {}, create_user: (l = p?.shouldCreateUser) !== null && l !== void 0 ? l : !0, gotrue_meta_security: { captcha_token: p?.captchaToken }, channel: (u = p?.channel) !== null && u !== void 0 ? u : "sms" } }); return { data: { user: null, session: null, messageId: m?.message_id }, error: v } } throw new va("You must provide either an email or phone number.") } catch (f) { if (xe(f)) return { data: { user: null, session: null }, error: f }; throw f } } async verifyOtp(t) { var s, o; try { let a, l; "options" in t && (a = (s = t.options) === null || s === void 0 ? void 0 : s.redirectTo, l = (o = t.options) === null || o === void 0 ? void 0 : o.captchaToken); const { data: u, error: f } = await Se(this.fetch, "POST", `${this.url}/verify`, { headers: this.headers, body: Object.assign(Object.assign({}, t), { gotrue_meta_security: { captcha_token: l } }), redirectTo: a, xform: nn }); if (f) throw f; if (!u) throw new Error("An error occurred on token verification."); const p = u.session, m = u.user; return p?.access_token && (await this._saveSession(p), await this._notifyAllSubscribers(t.type == "recovery" ? "PASSWORD_RECOVERY" : "SIGNED_IN", p)), { data: { user: m, session: p }, error: null } } catch (a) { if (xe(a)) return { data: { user: null, session: null }, error: a }; throw a } } async signInWithSSO(t) { var s, o, a; try { let l = null, u = null; return this.flowType === "pkce" && ([l, u] = await _s(this.storage, this.storageKey)), await Se(this.fetch, "POST", `${this.url}/sso`, { body: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, "providerId" in t ? { provider_id: t.providerId } : null), "domain" in t ? { domain: t.domain } : null), { redirect_to: (o = (s = t.options) === null || s === void 0 ? void 0 : s.redirectTo) !== null && o !== void 0 ? o : void 0 }), !((a = t?.options) === null || a === void 0) && a.captchaToken ? { gotrue_meta_security: { captcha_token: t.options.captchaToken } } : null), { skip_http_redirect: !0, code_challenge: l, code_challenge_method: u }), headers: this.headers, xform: bC }) } catch (l) { if (xe(l)) return { data: null, error: l }; throw l } } async reauthenticate() { return await this.initializePromise, await this._acquireLock(-1, async () => await this._reauthenticate()) } async _reauthenticate() { try { return await this._useSession(async t => { const { data: { session: s }, error: o } = t; if (o) throw o; if (!s) throw new tr; const { error: a } = await Se(this.fetch, "GET", `${this.url}/reauthenticate`, { headers: this.headers, jwt: s.access_token }); return { data: { user: null, session: null }, error: a } }) } catch (t) { if (xe(t)) return { data: { user: null, session: null }, error: t }; throw t } } async resend(t) { try { const s = `${this.url}/resend`; if ("email" in t) { const { email: o, type: a, options: l } = t, { error: u } = await Se(this.fetch, "POST", s, { headers: this.headers, body: { email: o, type: a, gotrue_meta_security: { captcha_token: l?.captchaToken } }, redirectTo: l?.emailRedirectTo }); return { data: { user: null, session: null }, error: u } } else if ("phone" in t) { const { phone: o, type: a, options: l } = t, { data: u, error: f } = await Se(this.fetch, "POST", s, { headers: this.headers, body: { phone: o, type: a, gotrue_meta_security: { captcha_token: l?.captchaToken } } }); return { data: { user: null, session: null, messageId: u?.message_id }, error: f } } throw new va("You must provide either an email or phone number and a type") } catch (s) { if (xe(s)) return { data: { user: null, session: null }, error: s }; throw s } } async getSession() { return await this.initializePromise, await this._acquireLock(-1, async () => this._useSession(async s => s)) } async _acquireLock(t, s) { this._debug("#_acquireLock", "begin", t); try { if (this.lockAcquired) { const o = this.pendingInLock.length ? this.pendingInLock[this.pendingInLock.length - 1] : Promise.resolve(), a = (async () => (await o, await s()))(); return this.pendingInLock.push((async () => { try { await a } catch { } })()), a } return await this.lock(`lock:${this.storageKey}`, t, async () => { this._debug("#_acquireLock", "lock acquired for storage key", this.storageKey); try { this.lockAcquired = !0; const o = s(); for (this.pendingInLock.push((async () => { try { await o } catch { } })()), await o; this.pendingInLock.length;) { const a = [...this.pendingInLock]; await Promise.all(a), this.pendingInLock.splice(0, a.length) } return await o } finally { this._debug("#_acquireLock", "lock released for storage key", this.storageKey), this.lockAcquired = !1 } }) } finally { this._debug("#_acquireLock", "end") } } async _useSession(t) { this._debug("#_useSession", "begin"); try { const s = await this.__loadSession(); return await t(s) } finally { this._debug("#_useSession", "end") } } async __loadSession() { this._debug("#__loadSession()", "begin"), this.lockAcquired || this._debug("#__loadSession()", "used outside of an acquired lock!", new Error().stack); try { let t = null; const s = await Cr(this.storage, this.storageKey); if (this._debug("#getSession()", "session from storage", s), s !== null && (this._isValidSession(s) ? t = s : (this._debug("#getSession()", "session from storage is not valid"), await this._removeSession())), !t) return { data: { session: null }, error: null }; const o = t.expires_at ? t.expires_at * 1e3 - Date.now() < cu : !1; if (this._debug("#__loadSession()", `session has${o ? "" : " not"} expired`, "expires_at", t.expires_at), !o) { if (this.userStorage) { const u = await Cr(this.userStorage, this.storageKey + "-user"); u?.user ? t.user = u.user : t.user = fu() } if (this.storage.isServer && t.user) { let u = this.suppressGetSessionWarning; t = new Proxy(t, { get: (p, m, v) => (!u && m === "user" && (console.warn("Using the user object as returned from supabase.auth.getSession() or from some supabase.auth.onAuthStateChange() events could be insecure! This value comes directly from the storage medium (usually cookies on the server) and may not be authentic. Use supabase.auth.getUser() instead which authenticates the data by contacting the Supabase Auth server."), u = !0, this.suppressGetSessionWarning = !0), Reflect.get(p, m, v)) }) } return { data: { session: t }, error: null } } const { data: a, error: l } = await this._callRefreshToken(t.refresh_token); return l ? { data: { session: null }, error: l } : { data: { session: a }, error: null } } finally { this._debug("#__loadSession()", "end") } } async getUser(t) { return t ? await this._getUser(t) : (await this.initializePromise, await this._acquireLock(-1, async () => await this._getUser())) } async _getUser(t) { try { return t ? await Se(this.fetch, "GET", `${this.url}/user`, { headers: this.headers, jwt: t, xform: nr }) : await this._useSession(async s => { var o, a, l; const { data: u, error: f } = s; if (f) throw f; return !(!((o = u.session) === null || o === void 0) && o.access_token) && !this.hasCustomAuthorizationHeader ? { data: { user: null }, error: new tr } : await Se(this.fetch, "GET", `${this.url}/user`, { headers: this.headers, jwt: (l = (a = u.session) === null || a === void 0 ? void 0 : a.access_token) !== null && l !== void 0 ? l : void 0, xform: nr }) }) } catch (s) { if (xe(s)) return Yj(s) && (await this._removeSession(), await Zn(this.storage, `${this.storageKey}-code-verifier`)), { data: { user: null }, error: s }; throw s } } async updateUser(t, s = {}) { return await this.initializePromise, await this._acquireLock(-1, async () => await this._updateUser(t, s)) } async _updateUser(t, s = {}) { try { return await this._useSession(async o => { const { data: a, error: l } = o; if (l) throw l; if (!a.session) throw new tr; const u = a.session; let f = null, p = null; this.flowType === "pkce" && t.email != null && ([f, p] = await _s(this.storage, this.storageKey)); const { data: m, error: v } = await Se(this.fetch, "PUT", `${this.url}/user`, { headers: this.headers, redirectTo: s?.emailRedirectTo, body: Object.assign(Object.assign({}, t), { code_challenge: f, code_challenge_method: p }), jwt: u.access_token, xform: nr }); if (v) throw v; return u.user = m.user, await this._saveSession(u), await this._notifyAllSubscribers("USER_UPDATED", u), { data: { user: u.user }, error: null } }) } catch (o) { if (xe(o)) return { data: { user: null }, error: o }; throw o } } async setSession(t) { return await this.initializePromise, await this._acquireLock(-1, async () => await this._setSession(t)) } async _setSession(t) { try { if (!t.access_token || !t.refresh_token) throw new tr; const s = Date.now() / 1e3; let o = s, a = !0, l = null; const { payload: u } = du(t.access_token); if (u.exp && (o = u.exp, a = o <= s), a) { const { data: f, error: p } = await this._callRefreshToken(t.refresh_token); if (p) return { data: { user: null, session: null }, error: p }; if (!f) return { data: { user: null, session: null }, error: null }; l = f } else { const { data: f, error: p } = await this._getUser(t.access_token); if (p) throw p; l = { access_token: t.access_token, refresh_token: t.refresh_token, user: f.user, token_type: "bearer", expires_in: o - s, expires_at: o }, await this._saveSession(l), await this._notifyAllSubscribers("SIGNED_IN", l) } return { data: { user: l.user, session: l }, error: null } } catch (s) { if (xe(s)) return { data: { session: null, user: null }, error: s }; throw s } } async refreshSession(t) { return await this.initializePromise, await this._acquireLock(-1, async () => await this._refreshSession(t)) } async _refreshSession(t) { try { return await this._useSession(async s => { var o; if (!t) { const { data: u, error: f } = s; if (f) throw f; t = (o = u.session) !== null && o !== void 0 ? o : void 0 } if (!t?.refresh_token) throw new tr; const { data: a, error: l } = await this._callRefreshToken(t.refresh_token); return l ? { data: { user: null, session: null }, error: l } : a ? { data: { user: a.user, session: a }, error: null } : { data: { user: null, session: null }, error: null } }) } catch (s) { if (xe(s)) return { data: { user: null, session: null }, error: s }; throw s } } async _getSessionFromURL(t, s) { try { if (!$t()) throw new ya("No browser detected."); if (t.error || t.error_description || t.error_code) throw new ya(t.error_description || "Error in URL with unspecified error_description", { error: t.error || "unspecified_error", code: t.error_code || "unspecified_code" }); switch (s) { case "implicit": if (this.flowType === "pkce") throw new Im("Not a valid PKCE flow url."); break; case "pkce": if (this.flowType === "implicit") throw new ya("Not a valid implicit grant flow url."); break; default: }if (s === "pkce") { if (this._debug("#_initialize()", "begin", "is PKCE flow", !0), !t.code) throw new Im("No code detected."); const { data: T, error: P } = await this._exchangeCodeForSession(t.code); if (P) throw P; const I = new URL(window.location.href); return I.searchParams.delete("code"), window.history.replaceState(window.history.state, "", I.toString()), { data: { session: T.session, redirectType: null }, error: null } } const { provider_token: o, provider_refresh_token: a, access_token: l, refresh_token: u, expires_in: f, expires_at: p, token_type: m } = t; if (!l || !f || !u || !m) throw new ya("No session defined in URL"); const v = Math.round(Date.now() / 1e3), y = parseInt(f); let _ = v + y; p && (_ = parseInt(p)); const S = _ - v; S * 1e3 <= js && console.warn(`@supabase/gotrue-js: Session as retrieved from URL expires in ${S}s, should have been closer to ${y}s`); const E = _ - y; v - E >= 120 ? console.warn("@supabase/gotrue-js: Session as retrieved from URL was issued over 120s ago, URL could be stale", E, _, v) : v - E < 0 && console.warn("@supabase/gotrue-js: Session as retrieved from URL was issued in the future? Check the device clock for skew", E, _, v); const { data: b, error: k } = await this._getUser(l); if (k) throw k; const C = { provider_token: o, provider_refresh_token: a, access_token: l, expires_in: y, expires_at: _, refresh_token: u, token_type: m, user: b.user }; return window.location.hash = "", this._debug("#_getSessionFromURL()", "clearing window.location.hash"), { data: { session: C, redirectType: t.type }, error: null } } catch (o) { if (xe(o)) return { data: { session: null, redirectType: null }, error: o }; throw o } } _isImplicitGrantCallback(t) { return !!(t.access_token || t.error_description) } async _isPKCECallback(t) { const s = await Cr(this.storage, `${this.storageKey}-code-verifier`); return !!(t.code && s) } async signOut(t = { scope: "global" }) { return await this.initializePromise, await this._acquireLock(-1, async () => await this._signOut(t)) } async _signOut({ scope: t } = { scope: "global" }) { return await this._useSession(async s => { var o; const { data: a, error: l } = s; if (l) return { error: l }; const u = (o = a.session) === null || o === void 0 ? void 0 : o.access_token; if (u) { const { error: f } = await this.admin.signOut(u, t); if (f && !(Gj(f) && (f.status === 404 || f.status === 401 || f.status === 403))) return { error: f } } return t !== "others" && (await this._removeSession(), await Zn(this.storage, `${this.storageKey}-code-verifier`)), { error: null } }) } onAuthStateChange(t) { const s = rC(), o = { id: s, callback: t, unsubscribe: () => { this._debug("#unsubscribe()", "state change callback with id removed", s), this.stateChangeEmitters.delete(s) } }; return this._debug("#onAuthStateChange()", "registered callback with id", s), this.stateChangeEmitters.set(s, o), (async () => (await this.initializePromise, await this._acquireLock(-1, async () => { this._emitInitialSession(s) })))(), { data: { subscription: o } } } async _emitInitialSession(t) { return await this._useSession(async s => { var o, a; try { const { data: { session: l }, error: u } = s; if (u) throw u; await ((o = this.stateChangeEmitters.get(t)) === null || o === void 0 ? void 0 : o.callback("INITIAL_SESSION", l)), this._debug("INITIAL_SESSION", "callback id", t, "session", l) } catch (l) { await ((a = this.stateChangeEmitters.get(t)) === null || a === void 0 ? void 0 : a.callback("INITIAL_SESSION", null)), this._debug("INITIAL_SESSION", "callback id", t, "error", l), console.error(l) } }) } async resetPasswordForEmail(t, s = {}) { let o = null, a = null; this.flowType === "pkce" && ([o, a] = await _s(this.storage, this.storageKey, !0)); try { return await Se(this.fetch, "POST", `${this.url}/recover`, { body: { email: t, code_challenge: o, code_challenge_method: a, gotrue_meta_security: { captcha_token: s.captchaToken } }, headers: this.headers, redirectTo: s.redirectTo }) } catch (l) { if (xe(l)) return { data: null, error: l }; throw l } } async getidentities() { var t; try { const { data: s, error: o } = await this.getUser(); if (o) throw o; return { data: { identities: (t = s.user.identities) !== null && t !== void 0 ? t : [] }, error: null } } catch (s) { if (xe(s)) return { data: null, error: s }; throw s } } async linkIdentity(t) { return "token" in t ? this.linkIdentityIdToken(t) : this.linkIdentityOAuth(t) } async linkIdentityOAuth(t) { var s; try { const { data: o, error: a } = await this._useSession(async l => { var u, f, p, m, v; const { data: y, error: _ } = l; if (_) throw _; const S = await this._getUrlForProvider(`${this.url}/user/identities/authorize`, t.provider, { redirectTo: (u = t.options) === null || u === void 0 ? void 0 : u.redirectTo, scopes: (f = t.options) === null || f === void 0 ? void 0 : f.scopes, queryParams: (p = t.options) === null || p === void 0 ? void 0 : p.queryParams, skipBrowserRedirect: !0 }); return await Se(this.fetch, "GET", S, { headers: this.headers, jwt: (v = (m = y.session) === null || m === void 0 ? void 0 : m.access_token) !== null && v !== void 0 ? v : void 0 }) }); if (a) throw a; return $t() && !(!((s = t.options) === null || s === void 0) && s.skipBrowserRedirect) && window.location.assign(o?.url), { data: { provider: t.provider, url: o?.url }, error: null } } catch (o) { if (xe(o)) return { data: { provider: t.provider, url: null }, error: o }; throw o } } async linkIdentityIdToken(t) { return await this._useSession(async s => { var o; try { const { error: a, data: { session: l } } = s; if (a) throw a; const { options: u, provider: f, token: p, access_token: m, nonce: v } = t, y = await Se(this.fetch, "POST", `${this.url}/token?grant_type=id_token`, { headers: this.headers, jwt: (o = l?.access_token) !== null && o !== void 0 ? o : void 0, body: { provider: f, id_token: p, access_token: m, nonce: v, link_identity: !0, gotrue_meta_security: { captcha_token: u?.captchaToken } }, xform: nn }), { data: _, error: S } = y; return S ? { data: { user: null, session: null }, error: S } : !_ || !_.session || !_.user ? { data: { user: null, session: null }, error: new bs } : (_.session && (await this._saveSession(_.session), await this._notifyAllSubscribers("USER_UPDATED", _.session)), { data: _, error: S }) } catch (a) { if (xe(a)) return { data: { user: null, session: null }, error: a }; throw a } }) } async unlinkIdentity(t) { try { return await this._useSession(async s => { var o, a; const { data: l, error: u } = s; if (u) throw u; return await Se(this.fetch, "DELETE", `${this.url}/user/identities/${t.identity_id}`, { headers: this.headers, jwt: (a = (o = l.session) === null || o === void 0 ? void 0 : o.access_token) !== null && a !== void 0 ? a : void 0 }) }) } catch (s) { if (xe(s)) return { data: null, error: s }; throw s } } async _refreshAccessToken(t) { const s = `#_refreshAccessToken(${t.substring(0, 5)}...)`; this._debug(s, "begin"); try { const o = Date.now(); return await aC(async a => (a > 0 && await iC(200 * Math.pow(2, a - 1)), this._debug(s, "refreshing attempt", a), await Se(this.fetch, "POST", `${this.url}/token?grant_type=refresh_token`, { body: { refresh_token: t }, headers: this.headers, xform: nn })), (a, l) => { const u = 200 * Math.pow(2, a); return l && uu(l) && Date.now() + u - o < js }) } catch (o) { if (this._debug(s, "error", o), xe(o)) return { data: { session: null, user: null }, error: o }; throw o } finally { this._debug(s, "end") } } _isValidSession(t) { return typeof t == "object" && t !== null && "access_token" in t && "refresh_token" in t && "expires_at" in t } async _handleProviderSignIn(t, s) { const o = await this._getUrlForProvider(`${this.url}/authorize`, t, { redirectTo: s.redirectTo, scopes: s.scopes, queryParams: s.queryParams }); return this._debug("#_handleProviderSignIn()", "provider", t, "options", s, "url", o), $t() && !s.skipBrowserRedirect && window.location.assign(o), { data: { provider: t, url: o }, error: null } } async _recoverAndRefresh() { var t, s; const o = "#_recoverAndRefresh()"; this._debug(o, "begin"); try { const a = await Cr(this.storage, this.storageKey); if (a && this.userStorage) { let u = await Cr(this.userStorage, this.storageKey + "-user"); !this.storage.isServer && Object.is(this.storage, this.userStorage) && !u && (u = { user: a.user }, await Cs(this.userStorage, this.storageKey + "-user", u)), a.user = (t = u?.user) !== null && t !== void 0 ? t : fu() } else if (a && !a.user && !a.user) { const u = await Cr(this.storage, this.storageKey + "-user"); u && u?.user ? (a.user = u.user, await Zn(this.storage, this.storageKey + "-user"), await Cs(this.storage, this.storageKey, a)) : a.user = fu() } if (this._debug(o, "session from storage", a), !this._isValidSession(a)) { this._debug(o, "session is not valid"), a !== null && await this._removeSession(); return } const l = ((s = a.expires_at) !== null && s !== void 0 ? s : 1 / 0) * 1e3 - Date.now() < cu; if (this._debug(o, `session has${l ? "" : " not"} expired with margin of ${cu}s`), l) { if (this.autoRefreshToken && a.refresh_token) { const { error: u } = await this._callRefreshToken(a.refresh_token); u && (console.error(u), uu(u) || (this._debug(o, "refresh failed with a non-retryable error, removing the session", u), await this._removeSession())) } } else if (a.user && a.user.__isUserNotAvailableProxy === !0) try { const { data: u, error: f } = await this._getUser(a.access_token); !f && u?.user ? (a.user = u.user, await this._saveSession(a), await this._notifyAllSubscribers("SIGNED_IN", a)) : this._debug(o, "could not get user data, skipping SIGNED_IN notification") } catch (u) { console.error("Error getting user data:", u), this._debug(o, "error getting user data, skipping SIGNED_IN notification", u) } else await this._notifyAllSubscribers("SIGNED_IN", a) } catch (a) { this._debug(o, "error", a), console.error(a); return } finally { this._debug(o, "end") } } async _callRefreshToken(t) { var s, o; if (!t) throw new tr; if (this.refreshingDeferred) return this.refreshingDeferred.promise; const a = `#_callRefreshToken(${t.substring(0, 5)}...)`; this._debug(a, "begin"); try { this.refreshingDeferred = new Ya; const { data: l, error: u } = await this._refreshAccessToken(t); if (u) throw u; if (!l.session) throw new tr; await this._saveSession(l.session), await this._notifyAllSubscribers("TOKEN_REFRESHED", l.session); const f = { data: l.session, error: null }; return this.refreshingDeferred.resolve(f), f } catch (l) { if (this._debug(a, "error", l), xe(l)) { const u = { data: null, error: l }; return uu(l) || await this._removeSession(), (s = this.refreshingDeferred) === null || s === void 0 || s.resolve(u), u } throw (o = this.refreshingDeferred) === null || o === void 0 || o.reject(l), l } finally { this.refreshingDeferred = null, this._debug(a, "end") } } async _notifyAllSubscribers(t, s, o = !0) { const a = `#_notifyAllSubscribers(${t})`; this._debug(a, "begin", s, `broadcast = ${o}`); try { this.broadcastChannel && o && this.broadcastChannel.postMessage({ event: t, session: s }); const l = [], u = Array.from(this.stateChangeEmitters.values()).map(async f => { try { await f.callback(t, s) } catch (p) { l.push(p) } }); if (await Promise.all(u), l.length > 0) { for (let f = 0; f < l.length; f += 1)console.error(l[f]); throw l[0] } } finally { this._debug(a, "end") } } async _saveSession(t) { this._debug("#_saveSession()", t), this.suppressGetSessionWarning = !0; const s = Object.assign({}, t), o = s.user && s.user.__isUserNotAvailableProxy === !0; if (this.userStorage) { !o && s.user && await Cs(this.userStorage, this.storageKey + "-user", { user: s.user }); const a = Object.assign({}, s); delete a.user; const l = Um(a); await Cs(this.storage, this.storageKey, l) } else { const a = Um(s); await Cs(this.storage, this.storageKey, a) } } async _removeSession() { this._debug("#_removeSession()"), await Zn(this.storage, this.storageKey), await Zn(this.storage, this.storageKey + "-code-verifier"), await Zn(this.storage, this.storageKey + "-user"), this.userStorage && await Zn(this.userStorage, this.storageKey + "-user"), await this._notifyAllSubscribers("SIGNED_OUT", null) } _removeVisibilityChangedCallback() { this._debug("#_removeVisibilityChangedCallback()"); const t = this.visibilityChangedCallback; this.visibilityChangedCallback = null; try { t && $t() && window?.removeEventListener && window.removeEventListener("visibilitychange", t) } catch (s) { console.error("removing visibilitychange callback failed", s) } } async _startAutoRefresh() { await this._stopAutoRefresh(), this._debug("#_startAutoRefresh()"); const t = setInterval(() => this._autoRefreshTokenTick(), js); this.autoRefreshTicker = t, t && typeof t == "object" && typeof t.unref == "function" ? t.unref() : typeof Deno < "u" && typeof Deno.unrefTimer == "function" && Deno.unrefTimer(t), setTimeout(async () => { await this.initializePromise, await this._autoRefreshTokenTick() }, 0) } async _stopAutoRefresh() { this._debug("#_stopAutoRefresh()"); const t = this.autoRefreshTicker; this.autoRefreshTicker = null, t && clearInterval(t) } async startAutoRefresh() { this._removeVisibilityChangedCallback(), await this._startAutoRefresh() } async stopAutoRefresh() { this._removeVisibilityChangedCallback(), await this._stopAutoRefresh() } async _autoRefreshTokenTick() { this._debug("#_autoRefreshTokenTick()", "begin"); try { await this._acquireLock(0, async () => { try { const t = Date.now(); try { return await this._useSession(async s => { const { data: { session: o } } = s; if (!o || !o.refresh_token || !o.expires_at) { this._debug("#_autoRefreshTokenTick()", "no session"); return } const a = Math.floor((o.expires_at * 1e3 - t) / js); this._debug("#_autoRefreshTokenTick()", `access token expires in ${a} ticks, a tick lasts ${js}ms, refresh threshold is ${Vu} ticks`), a <= Vu && await this._callRefreshToken(o.refresh_token) }) } catch (s) { console.error("Auto refresh tick failed with error. This is likely a transient error.", s) } } finally { this._debug("#_autoRefreshTokenTick()", "end") } }) } catch (t) { if (t.isAcquireTimeout || t instanceof Gy) this._debug("auto refresh token tick lock not available"); else throw t } } async _handleVisibilityChange() { if (this._debug("#_handleVisibilityChange()"), !$t() || !window?.addEventListener) return this.autoRefreshToken && this.startAutoRefresh(), !1; try { this.visibilityChangedCallback = async () => await this._onVisibilityChanged(!1), window?.addEventListener("visibilitychange", this.visibilityChangedCallback), await this._onVisibilityChanged(!0) } catch (t) { console.error("_handleVisibilityChange", t) } } async _onVisibilityChanged(t) { const s = `#_onVisibilityChanged(${t})`; this._debug(s, "visibilityState", document.visibilityState), document.visibilityState === "visible" ? (this.autoRefreshToken && this._startAutoRefresh(), t || (await this.initializePromise, await this._acquireLock(-1, async () => { if (document.visibilityState !== "visible") { this._debug(s, "acquired the lock to recover the session, but the browser visibilityState is no longer visible, aborting"); return } await this._recoverAndRefresh() }))) : document.visibilityState === "hidden" && this.autoRefreshToken && this._stopAutoRefresh() } async _getUrlForProvider(t, s, o) { const a = [`provider=${encodeURIComponent(s)}`]; if (o?.redirectTo && a.push(`redirect_to=${encodeURIComponent(o.redirectTo)}`), o?.scopes && a.push(`scopes=${encodeURIComponent(o.scopes)}`), this.flowType === "pkce") { const [l, u] = await _s(this.storage, this.storageKey), f = new URLSearchParams({ code_challenge: `${encodeURIComponent(l)}`, code_challenge_method: `${encodeURIComponent(u)}` }); a.push(f.toString()) } if (o?.queryParams) { const l = new URLSearchParams(o.queryParams); a.push(l.toString()) } return o?.skipBrowserRedirect && a.push(`skip_http_redirect=${o.skipBrowserRedirect}`), `${t}?${a.join("&")}` } async _unenroll(t) { try { return await this._useSession(async s => { var o; const { data: a, error: l } = s; return l ? { data: null, error: l } : await Se(this.fetch, "DELETE", `${this.url}/factors/${t.factorId}`, { headers: this.headers, jwt: (o = a?.session) === null || o === void 0 ? void 0 : o.access_token }) }) } catch (s) { if (xe(s)) return { data: null, error: s }; throw s } } async _enroll(t) { try { return await this._useSession(async s => { var o, a; const { data: l, error: u } = s; if (u) return { data: null, error: u }; const f = Object.assign({ friendly_name: t.friendlyName, factor_type: t.factorType }, t.factorType === "phone" ? { phone: t.phone } : t.factorType === "totp" ? { issuer: t.issuer } : {}), { data: p, error: m } = await Se(this.fetch, "POST", `${this.url}/factors`, { body: f, headers: this.headers, jwt: (o = l?.session) === null || o === void 0 ? void 0 : o.access_token }); return m ? { data: null, error: m } : (t.factorType === "totp" && p.type === "totp" && (!((a = p?.totp) === null || a === void 0) && a.qr_code) && (p.totp.qr_code = `data:image/svg+xml;utf-8,${p.totp.qr_code}`), { data: p, error: null }) }) } catch (s) { if (xe(s)) return { data: null, error: s }; throw s } } async _verify(t) { return this._acquireLock(-1, async () => { try { return await this._useSession(async s => { var o; const { data: a, error: l } = s; if (l) return { data: null, error: l }; const u = Object.assign({ challenge_id: t.challengeId }, "webauthn" in t ? { webauthn: Object.assign(Object.assign({}, t.webauthn), { credential_response: t.webauthn.type === "create" ? MC(t.webauthn.credential_response) : UC(t.webauthn.credential_response) }) } : { code: t.code }), { data: f, error: p } = await Se(this.fetch, "POST", `${this.url}/factors/${t.factorId}/verify`, { body: u, headers: this.headers, jwt: (o = a?.session) === null || o === void 0 ? void 0 : o.access_token }); return p ? { data: null, error: p } : (await this._saveSession(Object.assign({ expires_at: Math.round(Date.now() / 1e3) + f.expires_in }, f)), await this._notifyAllSubscribers("MFA_CHALLENGE_VERIFIED", f), { data: f, error: p }) }) } catch (s) { if (xe(s)) return { data: null, error: s }; throw s } }) } async _challenge(t) { return this._acquireLock(-1, async () => { try { return await this._useSession(async s => { var o; const { data: a, error: l } = s; if (l) return { data: null, error: l }; const u = await Se(this.fetch, "POST", `${this.url}/factors/${t.factorId}/challenge`, { body: t, headers: this.headers, jwt: (o = a?.session) === null || o === void 0 ? void 0 : o.access_token }); if (u.error) return u; const { data: f } = u; if (f.type !== "webauthn") return { data: f, error: null }; switch (f.webauthn.type) { case "create": return { data: Object.assign(Object.assign({}, f), { webauthn: Object.assign(Object.assign({}, f.webauthn), { credential_options: Object.assign(Object.assign({}, f.webauthn.credential_options), { publicKey: $C(f.webauthn.credential_options.publicKey) }) }) }), error: null }; case "request": return { data: Object.assign(Object.assign({}, f), { webauthn: Object.assign(Object.assign({}, f.webauthn), { credential_options: Object.assign(Object.assign({}, f.webauthn.credential_options), { publicKey: LC(f.webauthn.credential_options.publicKey) }) }) }), error: null } } }) } catch (s) { if (xe(s)) return { data: null, error: s }; throw s } }) } async _challengeAndVerify(t) { const { data: s, error: o } = await this._challenge({ factorId: t.factorId }); return o ? { data: null, error: o } : await this._verify({ factorId: t.factorId, challengeId: s.id, code: t.code }) } async _listFactors() { var t; const { data: { user: s }, error: o } = await this.getUser(); if (o) return { data: null, error: o }; const a = { all: [], phone: [], totp: [], webauthn: [] }; for (const l of (t = s?.factors) !== null && t !== void 0 ? t : []) a.all.push(l), l.status === "verified" && a[l.factor_type].push(l); return { data: a, error: null } } async _getAuthenticatorAssuranceLevel() { return this._acquireLock(-1, async () => await this._useSession(async t => { var s, o; const { data: { session: a }, error: l } = t; if (l) return { data: null, error: l }; if (!a) return { data: { currentLevel: null, nextLevel: null, currentAuthenticationMethods: [] }, error: null }; const { payload: u } = du(a.access_token); let f = null; u.aal && (f = u.aal); let p = f; ((o = (s = a.user.factors) === null || s === void 0 ? void 0 : s.filter(y => y.status === "verified")) !== null && o !== void 0 ? o : []).length > 0 && (p = "aal2"); const v = u.amr || []; return { data: { currentLevel: f, nextLevel: p, currentAuthenticationMethods: v }, error: null } })) } async fetchJwk(t, s = { keys: [] }) { let o = s.keys.find(f => f.kid === t); if (o) return o; const a = Date.now(); if (o = this.jwks.keys.find(f => f.kid === t), o && this.jwks_cached_at + Kj > a) return o; const { data: l, error: u } = await Se(this.fetch, "GET", `${this.url}/.well-known/jwks.json`, { headers: this.headers }); if (u) throw u; return !l.keys || l.keys.length === 0 || (this.jwks = l, this.jwks_cached_at = a, o = l.keys.find(f => f.kid === t), !o) ? null : o } async getClaims(t, s = {}) { try { let o = t; if (!o) { const { data: S, error: E } = await this.getSession(); if (E || !S.session) return { data: null, error: E }; o = S.session.access_token } const { header: a, payload: l, signature: u, raw: { header: f, payload: p } } = du(o); s?.allowExpired || pC(l.exp); const m = !a.alg || a.alg.startsWith("HS") || !a.kid || !("crypto" in globalThis && "subtle" in globalThis.crypto) ? null : await this.fetchJwk(a.kid, s?.keys ? { keys: s.keys } : s?.jwks); if (!m) { const { error: S } = await this.getUser(o); if (S) throw S; return { data: { claims: l, header: a, signature: u }, error: null } } const v = mC(a.alg), y = await crypto.subtle.importKey("jwk", m, v, !0, ["verify"]); if (!await crypto.subtle.verify(v, y, u, tC(`${f}.${p}`))) throw new Ku("Invalid JWT signature"); return { data: { claims: l, header: a, signature: u }, error: null } } catch (o) { if (xe(o)) return { data: null, error: o }; throw o } }
} Wo.nextInstanceID = 0; const GC = Wo; class YC extends GC { constructor(t) { super(t) } } var JC = function (r, t, s, o) { function a(l) { return l instanceof s ? l : new s(function (u) { u(l) }) } return new (s || (s = Promise))(function (l, u) { function f(v) { try { m(o.next(v)) } catch (y) { u(y) } } function p(v) { try { m(o.throw(v)) } catch (y) { u(y) } } function m(v) { v.done ? l(v.value) : a(v.value).then(f, p) } m((o = o.apply(r, t || [])).next()) }) }; class QC { constructor(t, s, o) { var a, l, u; this.supabaseUrl = t, this.supabaseKey = s; const f = Fj(t); if (!s) throw new Error("supabaseKey is required."); this.realtimeUrl = new URL("realtime/v1", f), this.realtimeUrl.protocol = this.realtimeUrl.protocol.replace("http", "ws"), this.authUrl = new URL("auth/v1", f), this.storageUrl = new URL("storage/v1", f), this.functionsUrl = new URL("functions/v1", f); const p = `sb-${f.hostname.split(".")[0]}-auth-token`, m = { db: Rj, realtime: Oj, auth: Object.assign(Object.assign({}, Aj), { storageKey: p }), global: Pj }, v = zj(o ?? {}, m); this.storageKey = (a = v.auth.storageKey) !== null && a !== void 0 ? a : "", this.headers = (l = v.global.headers) !== null && l !== void 0 ? l : {}, v.accessToken ? (this.accessToken = v.accessToken, this.auth = new Proxy({}, { get: (y, _) => { throw new Error(`@supabase/supabase-js: Supabase Client is configured with the accessToken option, accessing supabase.auth.${String(_)} is not possible`) } })) : this.auth = this._initSupabaseAuthClient((u = v.auth) !== null && u !== void 0 ? u : {}, this.headers, v.global.fetch), this.fetch = Lj(s, this._getAccessToken.bind(this), v.global.fetch), this.realtime = this._initRealtimeClient(Object.assign({ headers: this.headers, accessToken: this._getAccessToken.bind(this) }, v.realtime)), this.rest = new qE(new URL("rest/v1", f).href, { headers: this.headers, schema: v.db.schema, fetch: this.fetch }), this.storage = new Cj(this.storageUrl.href, this.headers, this.fetch, o?.storage), v.accessToken || this._listenForAuthEvents() } get functions() { return new LE(this.functionsUrl.href, { headers: this.headers, customFetch: this.fetch }) } from(t) { return this.rest.from(t) } schema(t) { return this.rest.schema(t) } rpc(t, s = {}, o = { head: !1, get: !1, count: void 0 }) { return this.rest.rpc(t, s, o) } channel(t, s = { config: {} }) { return this.realtime.channel(t, s) } getChannels() { return this.realtime.getChannels() } removeChannel(t) { return this.realtime.removeChannel(t) } removeAllChannels() { return this.realtime.removeAllChannels() } _getAccessToken() { return JC(this, void 0, void 0, function* () { var t, s; if (this.accessToken) return yield this.accessToken(); const { data: o } = yield this.auth.getSession(); return (s = (t = o.session) === null || t === void 0 ? void 0 : t.access_token) !== null && s !== void 0 ? s : this.supabaseKey }) } _initSupabaseAuthClient({ autoRefreshToken: t, persistSession: s, detectSessionInUrl: o, storage: a, userStorage: l, storageKey: u, flowType: f, lock: p, debug: m }, v, y) { const _ = { Authorization: `Bearer ${this.supabaseKey}`, apikey: `${this.supabaseKey}` }; return new YC({ url: this.authUrl.href, headers: Object.assign(Object.assign({}, _), v), storageKey: u, autoRefreshToken: t, persistSession: s, detectSessionInUrl: o, storage: a, userStorage: l, flowType: f, lock: p, debug: m, fetch: y, hasCustomAuthorizationHeader: Object.keys(this.headers).some(S => S.toLowerCase() === "authorization") }) } _initRealtimeClient(t) { return new uj(this.realtimeUrl.href, Object.assign(Object.assign({}, t), { params: Object.assign({ apikey: this.supabaseKey }, t?.params) })) } _listenForAuthEvents() { return this.auth.onAuthStateChange((s, o) => { this._handleTokenChanged(s, "CLIENT", o?.access_token) }) } _handleTokenChanged(t, s, o) { (t === "TOKEN_REFRESHED" || t === "SIGNED_IN") && this.changedAccessToken !== o ? (this.changedAccessToken = o, this.realtime.setAuth(o)) : t === "SIGNED_OUT" && (this.realtime.setAuth(), s == "STORAGE" && this.auth.signOut(), this.changedAccessToken = void 0) } } const XC = (r, t, s) => new QC(r, t, s); function ZC() { if (typeof window < "u" || typeof process > "u") return !1; const r = process.version; if (r == null) return !1; const t = r.match(/^v(\d+)\./); return t ? parseInt(t[1], 10) <= 18 : !1 } ZC() && console.warn("⚠️  Node.js 18 and below are deprecated and will no longer be supported in future versions of @supabase/supabase-js. Please upgrade to Node.js 20 or later. For more information, visit: https://github.com/orgs/supabase/discussions/37217"); XC(`https://${Re}.supabase.co`, $e); function eN({ onStatsUpdate: r }) {
  const [t, s] = x.useState([]), [o, a] = x.useState(!0), [l, u] = x.useState(!1), [f, p] = x.useState(null), [m, v] = x.useState({ title: "", subtitle: "", image: "", description: "" }), [y, _] = x.useState(!1), [S, E] = x.useState(null), [b, k] = x.useState(""); x.useEffect(() => { I() }, []); const C = async L => { try { const F = L.name.split(".").pop(), K = `category-${Date.now()}.${F}`, G = `categories/${K}`; if (L.size > 5 * 1024 * 1024) throw new Error("파일 크기는 5MB를 초과할 수 없습니다."); if (!L.type.startsWith("image/")) throw new Error("이미지 파일만 업로드 가능합니다."); console.log("Uploading file:", K, "Size:", L.size, "Type:", L.type); const oe = new FormData; oe.append("file", L), oe.append("filePath", G); const ae = await fetch(`https://${Re}.supabase.co/functions/v1/make-server-a8898ff1/images/upload`, { method: "POST", headers: { Authorization: `Bearer ${$e}` }, cache: "no-store", body: oe }), ue = await ae.json(); if (!ae.ok) throw console.error("Upload error:", ue.error || ae.statusText), new Error(ue.error || "이미지 업로드에 실패했습니다."); return console.log("Upload successful:", ue), ue.publicUrl.publicUrl } catch (F) { throw console.error("Upload image error:", F), F } }, T = L => { const F = L.target.files?.[0]; if (F) { E(F); const K = new FileReader; K.onload = G => { k(G.target?.result) }, K.readAsDataURL(F) } }, P = () => { E(null), k("") }, I = async () => { try { const L = await fetch(`https://${Re}.supabase.co/functions/v1/make-server-a8898ff1/categories`, { headers: { Authorization: `Bearer ${$e}` }, cache: "no-store" }); if (!L.ok) throw new Error("Failed to fetch categories"); const F = await L.json(); s(F.categories || []) } catch (L) { console.error("Error loading categories:", L), s([{ id: "fire", title: "화재발생 시 대응요령", subtitle: "객실 화재 발생 시 승무원 행동요령", image: "https://images.unsplash.com/photo-1581578731548-c64695cc6952?w=400&h=300&fit=crop", description: "지하철 화재 발생 시 대응 방법을 학습합니다." }, { id: "safety", title: "지하철 안전운행", subtitle: "안전한 지하철 운행을 위한 기본 수칙", image: "https://images.unsplash.com/photo-1544620347-c4fd4a3d5957?w=400&h=300&fit=crop", description: "지하철 운행 안전 수칙과 주의사항을 학습합니다." }]) } finally { a(!1) } }, O = async L => {
    L.preventDefault(), _(!0); try {
      let F = m.image; if (S) try { F = await C(S) } catch (te) {
        if (!confirm(`이미지 업로드에 실패했습니다.

${te instanceof Error ? te.message : "알 수 없는 오류"}

이미지 없이 카테고리를 저장하시겠습니까?`)) throw te; F = m.image || "https://via.placeholder.com/400x300/f0f0f0/666?text=No+Image"
      } const K = { ...m, image: F }, G = f ? `https://${Re}.supabase.co/functions/v1/make-server-a8898ff1/categories/${f.id}` : `https://${Re}.supabase.co/functions/v1/make-server-a8898ff1/categories`, ue = await (await fetch(G, { method: f ? "PUT" : "POST", headers: { "Content-Type": "application/json", Authorization: `Bearer ${$e}` }, cache: "no-store", body: JSON.stringify(K) })).json(); ue.success ? (await I(), r(), u(!1), R()) : alert(ue.error || "카테고리 저장에 실패했습니다.")
    } catch (F) {
      console.error("Error saving category:", F); let K = "카테고리 저장 중 오류가 발생했습니다."; F instanceof Error && (F.message.includes("row-level security policy") || F.message.includes("RLS") ? K = `이미지 업로드 권한이 없습니다.

Supabase Storage에서 다음 설정이 필요합니다:
1. Storage > Settings에서 RLS 비활성화
2. 또는 Public 정책 추가

관리자에게 문의하세요.`: F.message.includes("파일 크기") || F.message.includes("이미지 파일") ? K = F.message : K = `저장 실패: ${F.message}`), alert(K)
    } finally { _(!1) }
  }, V = async L => { if (confirm("정말로 이 카테고리를 삭제하시겠습니까? 해당 카테고리의 모든 영상도 함께 삭제됩니다.")) try { const K = await (await fetch(`https://${Re}.supabase.co/functions/v1/make-server-a8898ff1/categories/${L}`, { method: "DELETE", headers: { Authorization: `Bearer ${$e}`, cache: "no-store" } })).json(); K.success ? (await I(), r()) : alert(K.error || "카테고리 삭제에 실패했습니다.") } catch (F) { console.error("Error deleting category:", F), alert("카테고리 삭제 중 오류가 발생했습니다.") } }, M = L => { p(L), v({ title: L.title, subtitle: L.subtitle, image: L.image, description: L.description }), k(L.image), E(null), u(!0) }, R = () => { p(null), v({ title: "", subtitle: "", image: "", description: "" }), E(null), k("") }; return o ? d.jsx(ht, { children: d.jsx(xt, { className: "flex items-center justify-center py-12", children: d.jsxs("div", { className: "text-center", children: [d.jsx("div", { className: "animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600 mx-auto mb-4" }), d.jsx("p", { children: "데이터를 불러오는 중..." })] }) }) }) : d.jsx("div", { className: "space-y-6", children: d.jsxs(ht, { children: [d.jsxs(qt, { children: [d.jsx(Gt, { children: "카테고리 관리" }), d.jsx(Ar, { children: "교육 카테고리를 추가, 수정, 삭제할 수 있습니다." })] }), d.jsxs(xt, { children: [d.jsx("div", { className: "flex justify-end mb-6", children: d.jsxs(kd, { open: l, onOpenChange: u, children: [d.jsx(Ed, { asChild: !0, children: d.jsxs(Ne, { onClick: R, children: [d.jsx(nd, { className: "h-4 w-4 mr-2" }), "새 카테고리 추가"] }) }), d.jsxs(jd, { className: "max-w-lg", children: [d.jsxs(Cd, { children: [d.jsx(Td, { children: f ? "카테고리 수정" : "새 카테고리 추가" }), d.jsx(Pd, { children: f ? "카테고리 정보를 수정합니다." : "새로운 교육 카테고리를 추가합니다." })] }), d.jsxs("form", { onSubmit: O, className: "space-y-4", children: [d.jsxs("div", { children: [d.jsx(Qe, { htmlFor: "title", children: "카테고리 제목" }), d.jsx(wt, { id: "title", value: m.title, onChange: L => v(F => ({ ...F, title: L.target.value })), placeholder: "카테고리 제목을 입력하세요", required: !0 })] }), d.jsxs("div", { children: [d.jsx(Qe, { htmlFor: "subtitle", children: "부제목" }), d.jsx(wt, { id: "subtitle", value: m.subtitle, onChange: L => v(F => ({ ...F, subtitle: L.target.value })), placeholder: "카테고리 부제목을 입력하세요", required: !0 })] }), d.jsxs("div", { children: [d.jsx(Qe, { htmlFor: "image", children: "카테고리 이미지" }), d.jsxs("div", { className: "space-y-3", children: [d.jsxs("div", { className: "flex items-center gap-2", children: [d.jsx(wt, { id: "image", type: "file", accept: "image/*", onChange: T, className: "file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-blue-50 file:text-blue-700 hover:file:bg-blue-100" }), S && d.jsx(Ne, { type: "button", variant: "outline", size: "sm", onClick: P, children: d.jsx(Eg, { className: "h-4 w-4" }) })] }), (b || m.image) && d.jsxs("div", { className: "space-y-2", children: [d.jsx(Qe, { className: "text-sm text-gray-600", children: "미리보기:" }), d.jsxs("div", { className: "flex items-start gap-3", children: [d.jsx("img", { src: b || m.image, alt: "미리보기", className: "w-24 h-18 object-cover rounded border" }), S && d.jsxs("div", { className: "text-sm text-gray-600", children: [d.jsxs("p", { children: ["선택된 파일: ", S.name] }), d.jsxs("p", { children: ["크기: ", (S.size / 1024 / 1024).toFixed(2), "MB"] })] })] })] }), !f && !S && d.jsx("p", { className: "text-sm text-gray-500", children: "JPG, PNG, GIF 형식의 이미지를 업로드하세요. (최대 5MB)" }), f && !S && d.jsx("p", { className: "text-sm text-gray-500", children: "새 이미지를 선택하지 않으면 기존 이미지가 유지됩니다." })] })] }), d.jsxs("div", { children: [d.jsx(Qe, { htmlFor: "description", children: "설명" }), d.jsx(av, { id: "description", value: m.description, onChange: L => v(F => ({ ...F, description: L.target.value })), placeholder: "카테고리에 대한 설명을 입력하세요", rows: 3, required: !0 })] }), d.jsxs(Nd, { children: [d.jsx(Ne, { type: "button", variant: "outline", onClick: () => u(!1), disabled: y, children: "취소" }), d.jsx(Ne, { type: "submit", disabled: y, children: y ? d.jsxs(d.Fragment, { children: [d.jsx(bg, { className: "h-4 w-4 mr-2 animate-spin" }), "업로드 중..."] }) : f ? "수정" : "추가" })] })] })] })] }) }), d.jsx("div", { className: "rounded-md border", children: d.jsxs(Mo, { children: [d.jsx(Uo, { children: d.jsxs(Rt, { children: [d.jsx(Ue, { children: "이미지" }), d.jsx(Ue, { children: "제목" }), d.jsx(Ue, { children: "부제목" }), d.jsx(Ue, { children: "설명" }), d.jsx(Ue, { children: "작업" })] }) }), d.jsx(zo, { children: t.length === 0 ? d.jsx(Rt, { children: d.jsxs(Ie, { colSpan: 5, className: "text-center py-8 text-gray-500", children: [d.jsx(yg, { className: "h-12 w-12 mx-auto mb-4 text-gray-300" }), d.jsx("p", { children: "등록된 카테고리가 없습니다." })] }) }) : t.map(L => d.jsxs(Rt, { children: [d.jsx(Ie, { children: d.jsx("img", { src: L.image, alt: L.title, className: "w-16 h-12 object-cover rounded" }) }), d.jsx(Ie, { className: "font-medium", children: L.title }), d.jsx(Ie, { className: "text-gray-600", children: L.subtitle }), d.jsx(Ie, { className: "max-w-xs", children: d.jsx("div", { className: "truncate text-sm text-gray-600", title: L.description, children: L.description }) }), d.jsx(Ie, { children: d.jsxs("div", { className: "flex items-center space-x-2", children: [d.jsx(Ne, { variant: "outline", size: "sm", onClick: () => window.open(L.image, "_blank"), title: "이미지 원본 보기", children: d.jsx(wu, { className: "h-3 w-3" }) }), d.jsx(Ne, { variant: "outline", size: "sm", onClick: () => M(L), children: d.jsx(rd, { className: "h-3 w-3" }) }), d.jsx(Ne, { variant: "outline", size: "sm", onClick: () => V(L.id), className: "text-red-600 hover:text-red-700", children: d.jsx(sd, { className: "h-3 w-3" }) })] }) })] }, L.id)) })] }) })] })] }) })
} function tN({ currentAdmin: r }) { const [t, s] = x.useState([]), [o, a] = x.useState(!0), [l, u] = x.useState(!1), [f, p] = x.useState(null), [m, v] = x.useState({ name: "", employeeId: "", password: "" }); x.useEffect(() => { y() }, []); const y = async () => { try { const C = await fetch(`https://${Re}.supabase.co/functions/v1/make-server-a8898ff1/admin/list`, { headers: { Authorization: `Bearer ${$e}`, cache: "no-store" } }); if (!C.ok) throw new Error("Failed to fetch admins"); const T = await C.json(); s(T.admins || []) } catch (C) { console.error("Error loading admins:", C); const T = [{ id: "admin_001", name: "시스템 관리자", employeeId: "ADMIN001", isMainAdmin: !0, createdAt: new Date().toISOString() }, { id: "admin_002", name: "김철수", employeeId: "EMP001", isMainAdmin: !1, createdAt: new Date().toISOString() }]; s(T) } finally { a(!1) } }, _ = async C => { C.preventDefault(); try { const T = f ? `https://${Re}.supabase.co/functions/v1/make-server-a8898ff1/admin/${f.id}` : `https://${Re}.supabase.co/functions/v1/make-server-a8898ff1/admin/create`, O = await (await fetch(T, { method: f ? "PUT" : "POST", headers: { "Content-Type": "application/json", Authorization: `Bearer ${$e}`, cache: "no-store" }, body: JSON.stringify(m) })).json(); O.success ? (await y(), u(!1), b()) : alert(O.error || "관리자 저장에 실패했습니다.") } catch (T) { console.error("Error saving admin:", T), alert("관리자 저장 중 오류가 발생했습니다.") } }, S = async (C, T) => { if (T.isMainAdmin) { alert("메인 관리자는 삭제할 수 없습니다."); return } if (T.id === r.id) { alert("현재 로그인한 계정은 삭제할 수 없습니다."); return } if (confirm(`정말로 관리자 "${T.name}"을 삭제하시겠습니까?`)) try { const I = await (await fetch(`https://${Re}.supabase.co/functions/v1/make-server-a8898ff1/admin/${C}`, { method: "DELETE", headers: { Authorization: `Bearer ${$e}`, cache: "no-store" } })).json(); I.success ? await y() : alert(I.error || "관리자 삭제에 실패했습니다.") } catch (P) { console.error("Error deleting admin:", P), alert("관리자 삭제 중 오류가 발생했습니다.") } }, E = C => { p(C), v({ name: C.name, employeeId: C.employeeId, password: "" }), u(!0) }, b = () => { p(null), v({ name: "", employeeId: "", password: "" }) }, k = C => new Date(C).toLocaleString("ko-KR"); return o ? d.jsx(ht, { children: d.jsx(xt, { className: "flex items-center justify-center py-12", children: d.jsxs("div", { className: "text-center", children: [d.jsx("div", { className: "animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600 mx-auto mb-4" }), d.jsx("p", { children: "데이터를 불러오는 중..." })] }) }) }) : d.jsx("div", { className: "space-y-6", children: d.jsxs(ht, { children: [d.jsxs(qt, { children: [d.jsx(Gt, { children: "관리자 계정 관리" }), d.jsx(Ar, { children: "관리자 계정을 추가, 수정, 삭제할 수 있습니다. 메인 관리자는 삭제할 수 없습니다." })] }), d.jsxs(xt, { children: [d.jsx("div", { className: "flex justify-end mb-6", children: d.jsxs(kd, { open: l, onOpenChange: u, children: [d.jsx(Ed, { asChild: !0, children: d.jsxs(Ne, { onClick: b, children: [d.jsx(nd, { className: "h-4 w-4 mr-2" }), "새 관리자 추가"] }) }), d.jsxs(jd, { className: "max-w-lg", children: [d.jsxs(Cd, { children: [d.jsx(Td, { children: f ? "관리자 수정" : "새 관리자 추가" }), d.jsx(Pd, { children: f ? "관리자 정보를 수정합니다." : "새로운 관리자 계정을 추가합니다." })] }), d.jsxs("form", { onSubmit: _, className: "space-y-4", children: [d.jsxs("div", { children: [d.jsx(Qe, { htmlFor: "name", children: "이름" }), d.jsx(wt, { id: "name", value: m.name, onChange: C => v(T => ({ ...T, name: C.target.value })), placeholder: "관리자 이름을 입력하세요", required: !0 })] }), d.jsxs("div", { children: [d.jsx(Qe, { htmlFor: "employeeId", children: "사번" }), d.jsx(wt, { id: "employeeId", value: m.employeeId, onChange: C => v(T => ({ ...T, employeeId: C.target.value })), placeholder: "사번을 입력하세요", required: !0 })] }), d.jsxs("div", { children: [d.jsxs(Qe, { htmlFor: "password", children: ["비밀번호 ", f && d.jsx("span", { className: "text-sm text-gray-500", children: "(변경하지 않으려면 비워두세요)" })] }), d.jsx(wt, { id: "password", type: "password", value: m.password, onChange: C => v(T => ({ ...T, password: C.target.value })), placeholder: "비밀번호를 입력하세요", required: !f })] }), f && f.isMainAdmin && d.jsxs("div", { className: "flex items-center space-x-2 p-3 bg-yellow-50 border border-yellow-200 rounded", children: [d.jsx(Vb, { className: "h-4 w-4 text-yellow-600" }), d.jsx("span", { className: "text-sm text-yellow-800", children: "메인 관리자 계정입니다. 신중하게 수정해 주세요." })] }), d.jsxs(Nd, { children: [d.jsx(Ne, { type: "button", variant: "outline", onClick: () => u(!1), children: "취소" }), d.jsx(Ne, { type: "submit", children: f ? "수정" : "추가" })] })] })] })] }) }), d.jsx("div", { className: "rounded-md border", children: d.jsxs(Mo, { children: [d.jsx(Uo, { children: d.jsxs(Rt, { children: [d.jsx(Ue, { children: "이름" }), d.jsx(Ue, { children: "사번" }), d.jsx(Ue, { children: "권한" }), d.jsx(Ue, { children: "등록일" }), d.jsx(Ue, { children: "마지막 수정" }), d.jsx(Ue, { children: "작업" })] }) }), d.jsx(zo, { children: t.length === 0 ? d.jsx(Rt, { children: d.jsxs(Ie, { colSpan: 6, className: "text-center py-8 text-gray-500", children: [d.jsx(Sg, { className: "h-12 w-12 mx-auto mb-4 text-gray-300" }), d.jsx("p", { children: "등록된 관리자가 없습니다." })] }) }) : t.map(C => d.jsxs(Rt, { className: C.id === r.id ? "bg-blue-50" : "", children: [d.jsx(Ie, { className: "font-medium", children: d.jsxs("div", { className: "flex items-center space-x-2", children: [C.isMainAdmin && d.jsx(Ub, { className: "h-4 w-4 text-blue-600" }), d.jsx("span", { children: C.name }), C.id === r.id && d.jsx(yn, { variant: "secondary", className: "text-xs", children: "본인" })] }) }), d.jsx(Ie, { children: C.employeeId }), d.jsx(Ie, { children: d.jsx(yn, { variant: C.isMainAdmin ? "default" : "secondary", className: C.isMainAdmin ? "bg-blue-600" : "", children: C.isMainAdmin ? "메인 관리자" : "일반 관리자" }) }), d.jsx(Ie, { className: "text-sm text-gray-600", children: k(C.createdAt) }), d.jsx(Ie, { className: "text-sm text-gray-600", children: C.updatedAt ? k(C.updatedAt) : "-" }), d.jsx(Ie, { children: d.jsxs("div", { className: "flex items-center space-x-2", children: [d.jsx(Ne, { variant: "outline", size: "sm", onClick: () => E(C), children: d.jsx(rd, { className: "h-3 w-3" }) }), d.jsx(Ne, { variant: "outline", size: "sm", onClick: () => S(C.id, C), disabled: C.isMainAdmin || C.id === r.id, className: !C.isMainAdmin && C.id !== r.id ? "text-red-600 hover:text-red-700" : "", children: d.jsx(sd, { className: "h-3 w-3" }) })] }) })] }, C.id)) })] }) }), d.jsxs("div", { className: "mt-6 p-4 bg-gray-50 rounded-lg", children: [d.jsx("h4", { className: "font-medium text-gray-900 mb-2", children: "권한 안내" }), d.jsxs("ul", { className: "text-sm text-gray-600 space-y-1", children: [d.jsxs("li", { children: ["• ", d.jsx("strong", { children: "메인 관리자:" }), " 모든 기능에 접근 가능하며, 다른 관리자를 관리할 수 있습니다. 삭제할 수 없습니다."] }), d.jsxs("li", { children: ["• ", d.jsx("strong", { children: "일반 관리자:" }), " 영상, 카테고리, 사용자 관리 기능에 접근할 수 있습니다."] }), d.jsx("li", { children: "• 현재 로그인한 계정은 삭제할 수 없습니다." })] })] })] })] }) }) } function nN({ admin: r, onLogout: t }) { const [s, o] = x.useState({ totalUsers: 0, totalVideos: 0, totalCategories: 0, totalProgress: 0 }); x.useEffect(() => { a() }, []); const a = async () => { try { const l = await fetch(`https://${Re}.supabase.co/functions/v1/make-server-a8898ff1/categories`, { headers: { Authorization: `Bearer ${$e}` } }); if (!l.ok) throw new Error("Failed to fetch categories"); const u = await l.json(), f = await fetch(`https://${Re}.supabase.co/functions/v1/make-server-a8898ff1/admin/progress`, { headers: { Authorization: `Bearer ${$e}` } }); if (!f.ok) throw new Error("Failed to fetch progress"); const p = await f.json(), m = await fetch(`https://${Re}.supabase.co/functions/v1/make-server-a8898ff1/users`, { headers: { Authorization: `Bearer ${$e}` } }); if (!m.ok) throw new Error("Failed to fetch users"); const v = await m.json(), y = u.categories || [], _ = p.progress || []; let S = 0; for (const b of y) { const k = await fetch(`https://${Re}.supabase.co/functions/v1/make-server-a8898ff1/videos/${b.id}`, { headers: { Authorization: `Bearer ${$e}` } }); if (k.ok) { const C = await k.json(); S += (C.videos || []).length } } const E = v.users?.length || 0; o({ totalUsers: E, totalVideos: S, totalCategories: y.length, totalProgress: _.length }) } catch (l) { console.error("Error loading stats:", l), console.log("Server unavailable, falling back to demo mode"), o({ totalUsers: 5, totalVideos: 8, totalCategories: 3, totalProgress: 12 }) } }; return d.jsxs("div", { className: "min-h-screen bg-gray-50", children: [d.jsx("header", { className: "bg-white shadow-sm border-b", children: d.jsx("div", { className: "max-w-7xl mx-auto px-6 py-6", children: d.jsxs("div", { className: "flex justify-between items-center h-16", children: [d.jsxs("div", { className: "flex items-center gap-4", children: [d.jsx("img", { src: Ma, alt: "서울교통공사", className: "h-12 w-12" }), d.jsxs("div", { children: [d.jsx("h1", { className: "text-xl font-semibold text-gray-900", children: "관리자 대시보드" }), d.jsx("p", { className: "text-sm text-gray-600", children: "불안제로 관리 시스템" })] })] }), d.jsx("div", { className: "flex items-center space-x-4", children: d.jsxs(Ne, { variant: "outline", size: "sm", onClick: t, children: [d.jsx(wg, { className: "h-4 w-4 mr-2" }), "로그아웃"] }) })] }) }) }), d.jsxs("main", { className: "max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8", children: [$e === "placeholder-anon-key", d.jsxs("div", { className: "grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6 mb-8", children: [d.jsxs(ht, { children: [d.jsxs(qt, { className: "flex flex-row items-center justify-between space-y-0 pb-2", children: [d.jsx(Gt, { className: "text-sm font-medium", children: "총 사용자" }), d.jsx(Sg, { className: "h-4 w-4 text-muted-foreground" })] }), d.jsxs(xt, { children: [d.jsx("div", { className: "text-2xl font-bold", children: s.totalUsers }), d.jsx("p", { className: "text-xs text-muted-foreground", children: "시청 기록이 있는 사용자" })] })] }), d.jsxs(ht, { children: [d.jsxs(qt, { className: "flex flex-row items-center justify-between space-y-0 pb-2", children: [d.jsx(Gt, { className: "text-sm font-medium", children: "총 영상" }), d.jsx(kg, { className: "h-4 w-4 text-muted-foreground" })] }), d.jsxs(xt, { children: [d.jsx("div", { className: "text-2xl font-bold", children: s.totalVideos }), d.jsx("p", { className: "text-xs text-muted-foreground", children: "등록된 교육 영상" })] })] }), d.jsxs(ht, { children: [d.jsxs(qt, { className: "flex flex-row items-center justify-between space-y-0 pb-2", children: [d.jsx(Gt, { className: "text-sm font-medium", children: "총 카테고리" }), d.jsx(yg, { className: "h-4 w-4 text-muted-foreground" })] }), d.jsxs(xt, { children: [d.jsx("div", { className: "text-2xl font-bold", children: s.totalCategories }), d.jsx("p", { className: "text-xs text-muted-foreground", children: "교육 카테고리" })] })] }), d.jsxs(ht, { children: [d.jsxs(qt, { className: "flex flex-row items-center justify-between space-y-0 pb-2", children: [d.jsx(Gt, { className: "text-sm font-medium", children: "시청 기록" }), d.jsx(xg, { className: "h-4 w-4 text-muted-foreground" })] }), d.jsxs(xt, { children: [d.jsx("div", { className: "text-2xl font-bold", children: s.totalProgress }), d.jsx("p", { className: "text-xs text-muted-foreground", children: "총 시청 기록" })] })] })] }), d.jsxs(ov, { defaultValue: "users", className: "space-y-4", children: [d.jsxs(iv, { className: "grid w-full grid-cols-4", children: [d.jsx(Ns, { value: "users", children: "사용자 관리" }), d.jsx(Ns, { value: "videos", children: "영상 관리" }), d.jsx(Ns, { value: "categories", children: "카테고리 관리" }), d.jsx(Ns, { value: "admins", children: "관리자 관리" })] }), d.jsx(Ts, { value: "users", children: d.jsx(X_, {}) }), d.jsx(Ts, { value: "videos", children: d.jsx(AE, { onStatsUpdate: a }) }), d.jsx(Ts, { value: "categories", children: d.jsx(eN, { onStatsUpdate: a }) }), d.jsx(Ts, { value: "admins", children: d.jsx(tN, { currentAdmin: r }) })] })] })] }) } const rN = async (r, t) => { try { const s = await fetch(`https://${Re}.supabase.co/functions/v1/make-server-a8898ff1/users/validate`, { method: "POST", cache: "no-store", headers: { "Content-Type": "application/json", Authorization: `Bearer ${$e}`, "Cache-Control": "no-cache" }, body: JSON.stringify({ employeeId: r, name: t }) }); return s.ok ? !!(await s.json())?.success : (console.error("Authorization validation failed with status:", s.status), !1) } catch (s) { return console.error("Authorization validation error:", s), !1 } }; function sN({ onLogin: r, onBack: t }) { const [s, o] = x.useState(""), [a, l] = x.useState(""), [u, f] = x.useState(""), [p, m] = x.useState(!1), v = E => /^2\d{7}$/.test(E), y = E => /^[가-힣]+$/.test(E) && E.length >= 2 && E.length <= 5, _ = async () => { if (f(""), !s.trim()) { f("사번을 입력해주세요."); return } if (!v(s)) { f("올바른 사번 형식이 아닙니다."); return } if (!a.trim()) { f("이름을 입력해주세요."); return } if (!y(a.trim())) { f("이름은 2-5자리 한글만 입력 가능합니다."); return } m(!0); try { const E = s.trim(), b = a.trim(); if (!await rN(E, b)) { f("등록된 사번/이름이 아닙니다. 관리자에게 문의해주세요."); return } const C = `user_${E}`, T = localStorage.getItem(C), P = `employee_${E}`, I = { employeeId: E, name: b, id: P, loginDate: new Date().toISOString(), isNewUser: !T }, O = Date.now(), V = await fetch(`https://${Re}.supabase.co/functions/v1/make-server-a8898ff1/users?v=${O}`, { method: "POST", cache: "no-store", headers: { "Content-Type": "application/json", Authorization: `Bearer ${$e}`, "Cache-Control": "no-cache" }, body: JSON.stringify({ id: P, name: b, employeeId: E }) }); if (!V.ok) { const M = await V.text(); throw console.error("Failed to sync user info:", V.status, M), new Error("사용자 정보를 저장하지 못했습니다.") } localStorage.setItem(C, JSON.stringify(I)), localStorage.setItem("currentUser", JSON.stringify(I)), localStorage.setItem("learningHubid", P); try { const M = Date.now(), R = await fetch(`https://${Re}.supabase.co/functions/v1/make-server-a8898ff1/users/${E}/attendance?v=${M}`, { method: "POST", cache: "no-store", headers: { "Content-Type": "application/json", Authorization: `Bearer ${$e}`, "Cache-Control": "no-cache" }, body: JSON.stringify({ attendance: !0 }) }); if (R.ok) { const L = await R.json(); L?.user && localStorage.setItem("currentUser", JSON.stringify(L.user)) } else console.warn("Attendance sync failed with status", R.status) } catch (M) { console.error("Attendance sync error:", M) } r(I) } catch (E) { console.error("User login failed:", E), f("사용자 정보를 저장하지 못했습니다. 잠시 후 다시 시도해주세요.") } finally { m(!1) } }, S = E => { E.key === "Enter" && _() }; return d.jsx("div", { className: "min-h-screen bg-background flex items-center justify-center p-4 relative", children: d.jsxs("div", { className: "w-full max-w-md space-y-6 relative", children: [d.jsxs(Ne, { variant: "ghost", size: "sm", onClick: t, className: "absolute left-4 top-4 flex items-center gap-2", children: [d.jsx(td, { className: "w-4 h-4" }), "돌아가기"] }), d.jsxs("div", { className: "text-center space-y-4", children: [d.jsx("div", { className: "flex justify-center", children: d.jsx("img", { src: Ma, alt: "서울교통공사 로고", className: "w-24 h-24" }) }), d.jsxs("div", { children: [d.jsx("h1", { className: "mb-2", children: "사용자 로그인" }), d.jsx("p", { className: "text-muted-foreground", children: "동대문승무사업소 불안제로에 로그인하세요" })] })] }), d.jsxs(ht, { children: [d.jsxs(qt, { children: [d.jsxs(Gt, { className: "flex items-center gap-2", children: [d.jsx(_g, { className: "w-5 h-5" }), "로그인 정보 입력"] }), d.jsx(Ar, { children: "사번과 이름을 입력하세요" })] }), d.jsxs(xt, { className: "space-y-4", children: [u && d.jsx(Iu, { variant: "destructive", children: d.jsx(Du, { children: u }) }), d.jsxs("div", { className: "space-y-2", children: [d.jsx(Qe, { htmlFor: "employeeId", children: "사번" }), d.jsx(wt, { id: "employeeId", type: "text", value: s, onChange: E => { const b = E.target.value.replace(/\D/g, "").slice(0, 8); o(b) }, onKeyPress: S, maxLength: 8, className: "text-center tracking-wider" })] }), d.jsxs("div", { className: "space-y-2", children: [d.jsx(Qe, { htmlFor: "name", children: "이름" }), d.jsx(wt, { id: "name", type: "text", placeholder: "홍길동", value: a, onChange: E => l(E.target.value), maxLength: 5, className: "text-center" })] }), d.jsx(Ne, { onClick: _, disabled: p || !s || !a, className: "w-full", children: p ? "로그인 중..." : "로그인" }), d.jsxs("div", { className: "text-xs text-muted-foreground text-center space-y-1", children: [d.jsx("p", { children: "• 처음 로그인하시는 경우 자동으로 회원가입됩니다" }), d.jsx("p", { children: "• 개인정보는 학습 진행률 저장을 위해서만 사용됩니다" })] })] })] }), d.jsxs("div", { className: "text-center text-sm text-muted-foreground", children: [d.jsx("p", { children: "서울교통공사 동대문승무사업소" }), d.jsx("p", { children: "불안제로" })] })] }) }) } function oN(r) { if (typeof document > "u") return; let t = document.head || document.getElementsByTagName("head")[0], s = document.createElement("style"); s.type = "text/css", t.appendChild(s), s.styleSheet ? s.styleSheet.cssText = r : s.appendChild(document.createTextNode(r)) } Array(12).fill(0); let qu = 1; class iN { constructor() { this.subscribe = t => (this.subscribers.push(t), () => { const s = this.subscribers.indexOf(t); this.subscribers.splice(s, 1) }), this.publish = t => { this.subscribers.forEach(s => s(t)) }, this.addToast = t => { this.publish(t), this.toasts = [...this.toasts, t] }, this.create = t => { var s; const { message: o, ...a } = t, l = typeof t?.id == "number" || ((s = t.id) == null ? void 0 : s.length) > 0 ? t.id : qu++, u = this.toasts.find(p => p.id === l), f = t.dismissible === void 0 ? !0 : t.dismissible; return this.dismissedToasts.has(l) && this.dismissedToasts.delete(l), u ? this.toasts = this.toasts.map(p => p.id === l ? (this.publish({ ...p, ...t, id: l, title: o }), { ...p, ...t, id: l, dismissible: f, title: o }) : p) : this.addToast({ title: o, ...a, dismissible: f, id: l }), l }, this.dismiss = t => (t ? (this.dismissedToasts.add(t), requestAnimationFrame(() => this.subscribers.forEach(s => s({ id: t, dismiss: !0 })))) : this.toasts.forEach(s => { this.subscribers.forEach(o => o({ id: s.id, dismiss: !0 })) }), t), this.message = (t, s) => this.create({ ...s, message: t }), this.error = (t, s) => this.create({ ...s, message: t, type: "error" }), this.success = (t, s) => this.create({ ...s, type: "success", message: t }), this.info = (t, s) => this.create({ ...s, type: "info", message: t }), this.warning = (t, s) => this.create({ ...s, type: "warning", message: t }), this.loading = (t, s) => this.create({ ...s, type: "loading", message: t }), this.promise = (t, s) => { if (!s) return; let o; s.loading !== void 0 && (o = this.create({ ...s, promise: t, type: "loading", message: s.loading, description: typeof s.description != "function" ? s.description : void 0 })); const a = Promise.resolve(t instanceof Function ? t() : t); let l = o !== void 0, u; const f = a.then(async m => { if (u = ["resolve", m], Lt.isValidElement(m)) l = !1, this.create({ id: o, type: "default", message: m }); else if (lN(m) && !m.ok) { l = !1; const y = typeof s.error == "function" ? await s.error(`HTTP error! status: ${m.status}`) : s.error, _ = typeof s.description == "function" ? await s.description(`HTTP error! status: ${m.status}`) : s.description, E = typeof y == "object" && !Lt.isValidElement(y) ? y : { message: y }; this.create({ id: o, type: "error", description: _, ...E }) } else if (m instanceof Error) { l = !1; const y = typeof s.error == "function" ? await s.error(m) : s.error, _ = typeof s.description == "function" ? await s.description(m) : s.description, E = typeof y == "object" && !Lt.isValidElement(y) ? y : { message: y }; this.create({ id: o, type: "error", description: _, ...E }) } else if (s.success !== void 0) { l = !1; const y = typeof s.success == "function" ? await s.success(m) : s.success, _ = typeof s.description == "function" ? await s.description(m) : s.description, E = typeof y == "object" && !Lt.isValidElement(y) ? y : { message: y }; this.create({ id: o, type: "success", description: _, ...E }) } }).catch(async m => { if (u = ["reject", m], s.error !== void 0) { l = !1; const v = typeof s.error == "function" ? await s.error(m) : s.error, y = typeof s.description == "function" ? await s.description(m) : s.description, S = typeof v == "object" && !Lt.isValidElement(v) ? v : { message: v }; this.create({ id: o, type: "error", description: y, ...S }) } }).finally(() => { l && (this.dismiss(o), o = void 0), s.finally == null || s.finally.call(s) }), p = () => new Promise((m, v) => f.then(() => u[0] === "reject" ? v(u[1]) : m(u[1])).catch(v)); return typeof o != "string" && typeof o != "number" ? { unwrap: p } : Object.assign(o, { unwrap: p }) }, this.custom = (t, s) => { const o = s?.id || qu++; return this.create({ jsx: t(o), id: o, ...s }), o }, this.getActiveToasts = () => this.toasts.filter(t => !this.dismissedToasts.has(t.id)), this.subscribers = [], this.toasts = [], this.dismissedToasts = new Set } } const Kt = new iN, aN = (r, t) => { const s = t?.id || qu++; return Kt.addToast({ title: r, ...t, id: s }), s }, lN = r => r && typeof r == "object" && "ok" in r && typeof r.ok == "boolean" && "status" in r && typeof r.status == "number", cN = aN, uN = () => Kt.toasts, dN = () => Kt.getActiveToasts(), pu = Object.assign(cN, { success: Kt.success, info: Kt.info, warning: Kt.warning, error: Kt.error, custom: Kt.custom, message: Kt.message, promise: Kt.promise, dismiss: Kt.dismiss, loading: Kt.loading }, { getHistory: uN, getToasts: dN }); oN("[data-sonner-toaster][dir=ltr],html[dir=ltr]{--toast-icon-margin-start:-3px;--toast-icon-margin-end:4px;--toast-svg-margin-start:-1px;--toast-svg-margin-end:0px;--toast-button-margin-start:auto;--toast-button-margin-end:0;--toast-close-button-start:0;--toast-close-button-end:unset;--toast-close-button-transform:translate(-35%, -35%)}[data-sonner-toaster][dir=rtl],html[dir=rtl]{--toast-icon-margin-start:4px;--toast-icon-margin-end:-3px;--toast-svg-margin-start:0px;--toast-svg-margin-end:-1px;--toast-button-margin-start:0;--toast-button-margin-end:auto;--toast-close-button-start:unset;--toast-close-button-end:0;--toast-close-button-transform:translate(35%, -35%)}[data-sonner-toaster]{position:fixed;width:var(--width);font-family:ui-sans-serif,system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Arial,Noto Sans,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol,Noto Color Emoji;--gray1:hsl(0, 0%, 99%);--gray2:hsl(0, 0%, 97.3%);--gray3:hsl(0, 0%, 95.1%);--gray4:hsl(0, 0%, 93%);--gray5:hsl(0, 0%, 90.9%);--gray6:hsl(0, 0%, 88.7%);--gray7:hsl(0, 0%, 85.8%);--gray8:hsl(0, 0%, 78%);--gray9:hsl(0, 0%, 56.1%);--gray10:hsl(0, 0%, 52.3%);--gray11:hsl(0, 0%, 43.5%);--gray12:hsl(0, 0%, 9%);--border-radius:8px;box-sizing:border-box;padding:0;margin:0;list-style:none;outline:0;z-index:999999999;transition:transform .4s ease}@media (hover:none) and (pointer:coarse){[data-sonner-toaster][data-lifted=true]{transform:none}}[data-sonner-toaster][data-x-position=right]{right:var(--offset-right)}[data-sonner-toaster][data-x-position=left]{left:var(--offset-left)}[data-sonner-toaster][data-x-position=center]{left:50%;transform:translateX(-50%)}[data-sonner-toaster][data-y-position=top]{top:var(--offset-top)}[data-sonner-toaster][data-y-position=bottom]{bottom:var(--offset-bottom)}[data-sonner-toast]{--y:translateY(100%);--lift-amount:calc(var(--lift) * var(--gap));z-index:var(--z-index);position:absolute;opacity:0;transform:var(--y);touch-action:none;transition:transform .4s,opacity .4s,height .4s,box-shadow .2s;box-sizing:border-box;outline:0;overflow-wrap:anywhere}[data-sonner-toast][data-styled=true]{padding:16px;background:var(--normal-bg);border:1px solid var(--normal-border);color:var(--normal-text);border-radius:var(--border-radius);box-shadow:0 4px 12px rgba(0,0,0,.1);width:var(--width);font-size:13px;display:flex;align-items:center;gap:6px}[data-sonner-toast]:focus-visible{box-shadow:0 4px 12px rgba(0,0,0,.1),0 0 0 2px rgba(0,0,0,.2)}[data-sonner-toast][data-y-position=top]{top:0;--y:translateY(-100%);--lift:1;--lift-amount:calc(1 * var(--gap))}[data-sonner-toast][data-y-position=bottom]{bottom:0;--y:translateY(100%);--lift:-1;--lift-amount:calc(var(--lift) * var(--gap))}[data-sonner-toast][data-styled=true] [data-description]{font-weight:400;line-height:1.4;color:#3f3f3f}[data-rich-colors=true][data-sonner-toast][data-styled=true] [data-description]{color:inherit}[data-sonner-toaster][data-sonner-theme=dark] [data-description]{color:#e8e8e8}[data-sonner-toast][data-styled=true] [data-title]{font-weight:500;line-height:1.5;color:inherit}[data-sonner-toast][data-styled=true] [data-icon]{display:flex;height:16px;width:16px;position:relative;justify-content:flex-start;align-items:center;flex-shrink:0;margin-left:var(--toast-icon-margin-start);margin-right:var(--toast-icon-margin-end)}[data-sonner-toast][data-promise=true] [data-icon]>svg{opacity:0;transform:scale(.8);transform-origin:center;animation:sonner-fade-in .3s ease forwards}[data-sonner-toast][data-styled=true] [data-icon]>*{flex-shrink:0}[data-sonner-toast][data-styled=true] [data-icon] svg{margin-left:var(--toast-svg-margin-start);margin-right:var(--toast-svg-margin-end)}[data-sonner-toast][data-styled=true] [data-content]{display:flex;flex-direction:column;gap:2px}[data-sonner-toast][data-styled=true] [data-button]{border-radius:4px;padding-left:8px;padding-right:8px;height:24px;font-size:12px;color:var(--normal-bg);background:var(--normal-text);margin-left:var(--toast-button-margin-start);margin-right:var(--toast-button-margin-end);border:none;font-weight:500;cursor:pointer;outline:0;display:flex;align-items:center;flex-shrink:0;transition:opacity .4s,box-shadow .2s}[data-sonner-toast][data-styled=true] [data-button]:focus-visible{box-shadow:0 0 0 2px rgba(0,0,0,.4)}[data-sonner-toast][data-styled=true] [data-button]:first-of-type{margin-left:var(--toast-button-margin-start);margin-right:var(--toast-button-margin-end)}[data-sonner-toast][data-styled=true] [data-cancel]{color:var(--normal-text);background:rgba(0,0,0,.08)}[data-sonner-toaster][data-sonner-theme=dark] [data-sonner-toast][data-styled=true] [data-cancel]{background:rgba(255,255,255,.3)}[data-sonner-toast][data-styled=true] [data-close-button]{position:absolute;left:var(--toast-close-button-start);right:var(--toast-close-button-end);top:0;height:20px;width:20px;display:flex;justify-content:center;align-items:center;padding:0;color:var(--gray12);background:var(--normal-bg);border:1px solid var(--gray4);transform:var(--toast-close-button-transform);border-radius:50%;cursor:pointer;z-index:1;transition:opacity .1s,background .2s,border-color .2s}[data-sonner-toast][data-styled=true] [data-close-button]:focus-visible{box-shadow:0 4px 12px rgba(0,0,0,.1),0 0 0 2px rgba(0,0,0,.2)}[data-sonner-toast][data-styled=true] [data-disabled=true]{cursor:not-allowed}[data-sonner-toast][data-styled=true]:hover [data-close-button]:hover{background:var(--gray2);border-color:var(--gray5)}[data-sonner-toast][data-swiping=true]::before{content:'';position:absolute;left:-100%;right:-100%;height:100%;z-index:-1}[data-sonner-toast][data-y-position=top][data-swiping=true]::before{bottom:50%;transform:scaleY(3) translateY(50%)}[data-sonner-toast][data-y-position=bottom][data-swiping=true]::before{top:50%;transform:scaleY(3) translateY(-50%)}[data-sonner-toast][data-swiping=false][data-removed=true]::before{content:'';position:absolute;inset:0;transform:scaleY(2)}[data-sonner-toast][data-expanded=true]::after{content:'';position:absolute;left:0;height:calc(var(--gap) + 1px);bottom:100%;width:100%}[data-sonner-toast][data-mounted=true]{--y:translateY(0);opacity:1}[data-sonner-toast][data-expanded=false][data-front=false]{--scale:var(--toasts-before) * 0.05 + 1;--y:translateY(calc(var(--lift-amount) * var(--toasts-before))) scale(calc(-1 * var(--scale)));height:var(--front-toast-height)}[data-sonner-toast]>*{transition:opacity .4s}[data-sonner-toast][data-x-position=right]{right:0}[data-sonner-toast][data-x-position=left]{left:0}[data-sonner-toast][data-expanded=false][data-front=false][data-styled=true]>*{opacity:0}[data-sonner-toast][data-visible=false]{opacity:0;pointer-events:none}[data-sonner-toast][data-mounted=true][data-expanded=true]{--y:translateY(calc(var(--lift) * var(--offset)));height:var(--initial-height)}[data-sonner-toast][data-removed=true][data-front=true][data-swipe-out=false]{--y:translateY(calc(var(--lift) * -100%));opacity:0}[data-sonner-toast][data-removed=true][data-front=false][data-swipe-out=false][data-expanded=true]{--y:translateY(calc(var(--lift) * var(--offset) + var(--lift) * -100%));opacity:0}[data-sonner-toast][data-removed=true][data-front=false][data-swipe-out=false][data-expanded=false]{--y:translateY(40%);opacity:0;transition:transform .5s,opacity .2s}[data-sonner-toast][data-removed=true][data-front=false]::before{height:calc(var(--initial-height) + 20%)}[data-sonner-toast][data-swiping=true]{transform:var(--y) translateY(var(--swipe-amount-y,0)) translateX(var(--swipe-amount-x,0));transition:none}[data-sonner-toast][data-swiped=true]{user-select:none}[data-sonner-toast][data-swipe-out=true][data-y-position=bottom],[data-sonner-toast][data-swipe-out=true][data-y-position=top]{animation-duration:.2s;animation-timing-function:ease-out;animation-fill-mode:forwards}[data-sonner-toast][data-swipe-out=true][data-swipe-direction=left]{animation-name:swipe-out-left}[data-sonner-toast][data-swipe-out=true][data-swipe-direction=right]{animation-name:swipe-out-right}[data-sonner-toast][data-swipe-out=true][data-swipe-direction=up]{animation-name:swipe-out-up}[data-sonner-toast][data-swipe-out=true][data-swipe-direction=down]{animation-name:swipe-out-down}@keyframes swipe-out-left{from{transform:var(--y) translateX(var(--swipe-amount-x));opacity:1}to{transform:var(--y) translateX(calc(var(--swipe-amount-x) - 100%));opacity:0}}@keyframes swipe-out-right{from{transform:var(--y) translateX(var(--swipe-amount-x));opacity:1}to{transform:var(--y) translateX(calc(var(--swipe-amount-x) + 100%));opacity:0}}@keyframes swipe-out-up{from{transform:var(--y) translateY(var(--swipe-amount-y));opacity:1}to{transform:var(--y) translateY(calc(var(--swipe-amount-y) - 100%));opacity:0}}@keyframes swipe-out-down{from{transform:var(--y) translateY(var(--swipe-amount-y));opacity:1}to{transform:var(--y) translateY(calc(var(--swipe-amount-y) + 100%));opacity:0}}@media (max-width:600px){[data-sonner-toaster]{position:fixed;right:var(--mobile-offset-right);left:var(--mobile-offset-left);width:100%}[data-sonner-toaster][dir=rtl]{left:calc(var(--mobile-offset-left) * -1)}[data-sonner-toaster] [data-sonner-toast]{left:0;right:0;width:calc(100% - var(--mobile-offset-left) * 2)}[data-sonner-toaster][data-x-position=left]{left:var(--mobile-offset-left)}[data-sonner-toaster][data-y-position=bottom]{bottom:var(--mobile-offset-bottom)}[data-sonner-toaster][data-y-position=top]{top:var(--mobile-offset-top)}[data-sonner-toaster][data-x-position=center]{left:var(--mobile-offset-left);right:var(--mobile-offset-right);transform:none}}[data-sonner-toaster][data-sonner-theme=light]{--normal-bg:#fff;--normal-border:var(--gray4);--normal-text:var(--gray12);--success-bg:hsl(143, 85%, 96%);--success-border:hsl(145, 92%, 87%);--success-text:hsl(140, 100%, 27%);--info-bg:hsl(208, 100%, 97%);--info-border:hsl(221, 91%, 93%);--info-text:hsl(210, 92%, 45%);--warning-bg:hsl(49, 100%, 97%);--warning-border:hsl(49, 91%, 84%);--warning-text:hsl(31, 92%, 45%);--error-bg:hsl(359, 100%, 97%);--error-border:hsl(359, 100%, 94%);--error-text:hsl(360, 100%, 45%)}[data-sonner-toaster][data-sonner-theme=light] [data-sonner-toast][data-invert=true]{--normal-bg:#000;--normal-border:hsl(0, 0%, 20%);--normal-text:var(--gray1)}[data-sonner-toaster][data-sonner-theme=dark] [data-sonner-toast][data-invert=true]{--normal-bg:#fff;--normal-border:var(--gray3);--normal-text:var(--gray12)}[data-sonner-toaster][data-sonner-theme=dark]{--normal-bg:#000;--normal-bg-hover:hsl(0, 0%, 12%);--normal-border:hsl(0, 0%, 20%);--normal-border-hover:hsl(0, 0%, 25%);--normal-text:var(--gray1);--success-bg:hsl(150, 100%, 6%);--success-border:hsl(147, 100%, 12%);--success-text:hsl(150, 86%, 65%);--info-bg:hsl(215, 100%, 6%);--info-border:hsl(223, 43%, 17%);--info-text:hsl(216, 87%, 65%);--warning-bg:hsl(64, 100%, 6%);--warning-border:hsl(60, 100%, 9%);--warning-text:hsl(46, 87%, 65%);--error-bg:hsl(358, 76%, 10%);--error-border:hsl(357, 89%, 16%);--error-text:hsl(358, 100%, 81%)}[data-sonner-toaster][data-sonner-theme=dark] [data-sonner-toast] [data-close-button]{background:var(--normal-bg);border-color:var(--normal-border);color:var(--normal-text)}[data-sonner-toaster][data-sonner-theme=dark] [data-sonner-toast] [data-close-button]:hover{background:var(--normal-bg-hover);border-color:var(--normal-border-hover)}[data-rich-colors=true][data-sonner-toast][data-type=success]{background:var(--success-bg);border-color:var(--success-border);color:var(--success-text)}[data-rich-colors=true][data-sonner-toast][data-type=success] [data-close-button]{background:var(--success-bg);border-color:var(--success-border);color:var(--success-text)}[data-rich-colors=true][data-sonner-toast][data-type=info]{background:var(--info-bg);border-color:var(--info-border);color:var(--info-text)}[data-rich-colors=true][data-sonner-toast][data-type=info] [data-close-button]{background:var(--info-bg);border-color:var(--info-border);color:var(--info-text)}[data-rich-colors=true][data-sonner-toast][data-type=warning]{background:var(--warning-bg);border-color:var(--warning-border);color:var(--warning-text)}[data-rich-colors=true][data-sonner-toast][data-type=warning] [data-close-button]{background:var(--warning-bg);border-color:var(--warning-border);color:var(--warning-text)}[data-rich-colors=true][data-sonner-toast][data-type=error]{background:var(--error-bg);border-color:var(--error-border);color:var(--error-text)}[data-rich-colors=true][data-sonner-toast][data-type=error] [data-close-button]{background:var(--error-bg);border-color:var(--error-border);color:var(--error-text)}.sonner-loading-wrapper{--size:16px;height:var(--size);width:var(--size);position:absolute;inset:0;z-index:10}.sonner-loading-wrapper[data-visible=false]{transform-origin:center;animation:sonner-fade-out .2s ease forwards}.sonner-spinner{position:relative;top:50%;left:50%;height:var(--size);width:var(--size)}.sonner-loading-bar{animation:sonner-spin 1.2s linear infinite;background:var(--gray11);border-radius:6px;height:8%;left:-10%;position:absolute;top:-3.9%;width:24%}.sonner-loading-bar:first-child{animation-delay:-1.2s;transform:rotate(.0001deg) translate(146%)}.sonner-loading-bar:nth-child(2){animation-delay:-1.1s;transform:rotate(30deg) translate(146%)}.sonner-loading-bar:nth-child(3){animation-delay:-1s;transform:rotate(60deg) translate(146%)}.sonner-loading-bar:nth-child(4){animation-delay:-.9s;transform:rotate(90deg) translate(146%)}.sonner-loading-bar:nth-child(5){animation-delay:-.8s;transform:rotate(120deg) translate(146%)}.sonner-loading-bar:nth-child(6){animation-delay:-.7s;transform:rotate(150deg) translate(146%)}.sonner-loading-bar:nth-child(7){animation-delay:-.6s;transform:rotate(180deg) translate(146%)}.sonner-loading-bar:nth-child(8){animation-delay:-.5s;transform:rotate(210deg) translate(146%)}.sonner-loading-bar:nth-child(9){animation-delay:-.4s;transform:rotate(240deg) translate(146%)}.sonner-loading-bar:nth-child(10){animation-delay:-.3s;transform:rotate(270deg) translate(146%)}.sonner-loading-bar:nth-child(11){animation-delay:-.2s;transform:rotate(300deg) translate(146%)}.sonner-loading-bar:nth-child(12){animation-delay:-.1s;transform:rotate(330deg) translate(146%)}@keyframes sonner-fade-in{0%{opacity:0;transform:scale(.8)}100%{opacity:1;transform:scale(1)}}@keyframes sonner-fade-out{0%{opacity:1;transform:scale(1)}100%{opacity:0;transform:scale(.8)}}@keyframes sonner-spin{0%{opacity:1}100%{opacity:.15}}@media (prefers-reduced-motion){.sonner-loading-bar,[data-sonner-toast],[data-sonner-toast]>*{transition:none!important;animation:none!important}}.sonner-loader{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);transform-origin:center;transition:opacity .2s,transform .2s}.sonner-loader[data-visible=false]{opacity:0;transform:scale(.8) translate(-50%,-50%)}"); const fN = r => { const t = Math.floor(r / 60), s = Math.floor(r % 60); return `${t}:${s.toString().padStart(2, "0")}` }, hN = ({ videosByCategory: r, onBack: t }) => { const { progressData: s, getProgressPercentage: o } = Da(), a = typeof window < "u" ? localStorage.getItem("currentUser") : null; let l = null; try { a && (l = JSON.parse(a)) } catch { l = null } const [u, f] = x.useState(l), p = u?.employeeId, [m, v] = x.useState([]), [y, _] = x.useState(() => { const O = new Date; return `${O.getFullYear()}-${String(O.getMonth() + 1).padStart(2, "0")}` }); x.useEffect(() => { (async () => { if (p) try { const V = Date.now(), M = await fetch(`https://${window.__SUPABASE_PROJECT_ID__}.supabase.co/functions/v1/make-server-a8898ff1/users/${p}/attendance/logs?month=${y}&v=${V}`, { headers: { Authorization: `Bearer ${window.__SUPABASE_ANON_KEY__}` }, cache: "no-store" }); if (M.ok) { const R = await M.json(); v((R.logs || []).map(L => new Date(L.timestamp).toISOString())) } } catch (V) { console.error("Error fetching attendance logs", V) } })() }, [p, y]); const S = async O => { if (!u) return; const V = { ...u }, M = { ...u, attendance: O }; f(M), localStorage.setItem("currentUser", JSON.stringify(M)); try { const R = Date.now(), L = await fetch(`https://${window.__SUPABASE_PROJECT_ID__ || ""}.supabase.co/functions/v1/make-server-a8898ff1/users/${p}/attendance?v=${R}`, { method: "POST", headers: { "Content-Type": "application/json", Authorization: `Bearer ${window.__SUPABASE_ANON_KEY__ || ""}`, "Cache-Control": "no-cache" }, body: JSON.stringify({ attendance: O }) }); if (!L.ok) { const K = await L.text().catch(() => ""); f(V), localStorage.setItem("currentUser", JSON.stringify(V)), pu.error(`출석 동기화 실패: ${L.status} ${K}`), console.error("Failed to sync attendance to server", L.status, K); return } const F = await L.json(); F?.user && (f(F.user), localStorage.setItem("currentUser", JSON.stringify(F.user))), pu.success(O ? "출석이 확인되었습니다." : "출석이 취소되었습니다.") } catch (R) { f(V), localStorage.setItem("currentUser", JSON.stringify(V)), pu.error("네트워크 오류로 출석 동기화에 실패했습니다."), console.error("Error syncing attendance:", R) } }, E = x.useMemo(() => Object.values(r).flat(), [r]), b = x.useMemo(() => { if (E.length === 0) return 0; const O = E.reduce((V, M) => V + o(M.id, M.duration), 0); return Math.round(O / E.length * 10) / 10 }, [E, o]), [k, C] = y.split("-").map(O => O), T = x.useMemo(() => { const O = Number(k), V = Number(C) - 1; return new Date(O, V + 1, 0).getDate() }, [y]), P = x.useMemo(() => { const O = new Set(m.map(L => L.slice(0, 10))), V = Number(k), M = Number(C); let R = 0; return O.forEach(L => { const F = new Date(L); F.getFullYear() === V && F.getMonth() + 1 === M && R++ }), R }, [m, y]), I = T > 0 ? Math.round(P / T * 1e3) / 10 : 0; return d.jsxs("div", { className: "max-w-4xl mx-auto", children: [d.jsxs("div", { className: "mb-6 flex items-center justify-between", children: [d.jsx("h2", { className: "text-2xl font-bold", children: "마이 페이지" }), t && d.jsx(Ne, { variant: "ghost", size: "sm", onClick: t, children: "뒤로" })] }), d.jsxs("div", { className: "mb-6 p-4 rounded-lg border bg-card", children: [d.jsx(pN, {}), u && d.jsx("div", { className: "mt-4", children: d.jsxs("div", { className: "flex items-center gap-3", children: [d.jsx("div", { className: "text-sm", children: "출석 상태:" }), d.jsx(Ne, { variant: u.attendance ? "default" : "outline", size: "sm", onClick: () => S(!u.attendance), children: u.attendance ? "출석 취소" : "출석 체크" })] }) })] }), d.jsxs("section", { className: "mb-6", children: [d.jsx("h3", { className: "text-lg font-semibold mb-2", children: "출석 달력" }), d.jsxs("div", { className: "flex flex-col md:flex-row md:items-center md:justify-between gap-3 mb-3", children: [d.jsxs("div", { className: "flex items-center gap-2", children: [d.jsx(Ne, { size: "sm", variant: "outline", onClick: () => { const [O, V] = y.split("-").map(Number), M = new Date(O, V - 2); _(`${M.getFullYear()}-${String(M.getMonth() + 1).padStart(2, "0")}`) }, children: "이전 달" }), d.jsx("div", { className: "font-medium", children: y }), d.jsx(Ne, { size: "sm", variant: "outline", onClick: () => { const [O, V] = y.split("-").map(Number), M = new Date(O, V); _(`${M.getFullYear()}-${String(M.getMonth() + 1).padStart(2, "0")}`) }, children: "다음 달" })] }), d.jsxs("div", { className: "flex items-center gap-4", children: [d.jsxs("div", { className: "text-sm text-muted-foreground", children: ["출석률 (", y, ")"] }), d.jsxs("div", { className: "font-semibold text-lg", children: [I, "%"] }), d.jsx("div", { className: "w-40 md:w-64 h-3 bg-muted rounded-full overflow-hidden", children: d.jsx("div", { className: "h-full bg-primary", style: { width: `${Math.min(100, I)}%` } }) })] })] }), d.jsx("div", { className: "w-full", children: d.jsxs("div", { className: "grid grid-cols-7 gap-1 w-full auto-rows-[minmax(40px,auto)]", children: [["일", "월", "화", "수", "목", "금", "토"].map(O => d.jsx("div", { className: "text-center text-sm font-medium h-8 flex items-center justify-center", children: O }, O)), Array.from({ length: new Date(Number(y.split("-")[0]), Number(y.split("-")[1]) - 1, 1).getDay() }, (O, V) => d.jsx("div", { className: "h-10" }, `b-${V}`)), Array.from({ length: new Date(Number(y.split("-")[0]), Number(y.split("-")[1]), 0).getDate() }, (O, V) => { const M = V + 1, R = Number(y.split("-")[0]), L = Number(y.split("-")[1]) - 1, F = new Date(R, L, M).toISOString().slice(0, 10), K = new Set(m.map(oe => oe.slice(0, 10))).has(F), G = F === new Date().toISOString().slice(0, 10); return d.jsx("div", { className: "text-center flex items-center justify-center h-10", children: d.jsx("div", { role: "button", "aria-pressed": K, "aria-label": `${y}-${String(M).padStart(2, "0")}`, className: `flex items-center justify-center rounded-full transition-all duration-150 ${K ? "bg-green-500 text-white" : "bg-transparent text-foreground"} ${G ? "ring-2 ring-primary" : ""} w-8 h-8 md:w-10 md:h-10`, children: d.jsx("span", { className: "select-none text-sm md:text-base", children: M }) }) }, `d-${M}`) })] }) })] }), d.jsxs("section", { className: "mb-6", children: [d.jsx("h3", { className: "text-lg font-semibold mb-2", children: "전체 평균 시청률" }), d.jsxs("div", { className: "flex items-center gap-4", children: [d.jsxs("div", { className: "text-3xl font-extrabold", children: [b, "%"] }), d.jsx("div", { className: "flex-1", children: d.jsx("div", { className: "h-4 bg-muted rounded-full overflow-hidden", children: d.jsx("div", { className: "h-full bg-primary", style: { width: `${Math.min(100, Math.max(0, b))}%` } }) }) })] })] }), d.jsxs("section", { children: [d.jsx("h3", { className: "text-lg font-semibold mb-4", children: "영상별 시청현황" }), d.jsx("div", { className: "space-y-4", children: E.map(O => { s[O.id]; const V = o(O.id, O.duration); return d.jsxs("div", { className: "p-4 border rounded-lg bg-card flex items-center justify-between", children: [d.jsxs("div", { className: "flex items-center gap-4 min-w-0", children: [d.jsx("img", { src: O.thumbnail, alt: O.title, className: "w-24 h-14 object-cover rounded-md flex-shrink-0" }), d.jsxs("div", { className: "min-w-0", children: [d.jsx("div", { className: "font-semibold truncate", children: O.title }), d.jsxs("div", { className: "text-sm text-muted-foreground", children: ["재생시간: ", fN(O.duration)] })] })] }), d.jsxs("div", { className: "ml-4 w-64", children: [d.jsxs("div", { className: "text-sm mb-1", children: ["시청률: ", V, "%"] }), d.jsx("div", { className: "h-2 bg-muted rounded-full overflow-hidden", children: d.jsx("div", { className: "h-full bg-primary", style: { width: `${Math.min(100, Math.max(0, V))}%` } }) })] })] }, O.id) }) })] })] }) }, pN = () => { const r = typeof window < "u" ? localStorage.getItem("currentUser") : null; let t = null; try { r && (t = JSON.parse(r)) } catch { } return t ? d.jsxs("div", { children: [d.jsxs("div", { className: "text-lg font-semibold", children: [t.employeeId, " - ", t.name, "님, 환영합니다!"] }), d.jsxs("div", { className: "text-sm text-muted-foreground", children: ["출석: ", t.attendance ? "출석" : "결석"] })] }) : d.jsxs("div", { children: [d.jsx("div", { className: "text-lg font-semibold", children: "로그인 정보가 없습니다." }), d.jsx("div", { className: "text-sm text-muted-foreground", children: "사용자 로그인을 먼저 해주세요." })] }) }, Km = 420, yt = 260; function mN() { const [r, t] = x.useState("userLogin"), [s, o] = x.useState(""), [a, l] = x.useState(null), [u, f] = x.useState(null), [p, m] = x.useState(null), [v, y] = x.useState([]), [_, S] = x.useState(!0), [E, b] = x.useState({}), [k, C] = x.useState(!1), [T, P] = x.useState(null), [I, O] = x.useState("idle"), V = x.useRef([]), M = H => { t(H), history.pushState({ view: H }, "", window.location.href) }; x.useEffect(() => { const H = se => { se.state && se.state.view && t(se.state.view) }; return window.addEventListener("popstate", H), () => window.removeEventListener("popstate", H) }, []), x.useEffect(() => { const H = localStorage.getItem("currentUser"); if (H) try { m(JSON.parse(H)) } catch (se) { console.error("Failed to parse saved user:", se), localStorage.removeItem("currentUser") } }, []), x.useEffect(() => { R() }, []); const R = async () => { try { const H = await fetch(`https://${Re}.supabase.co/functions/v1/make-server-a8898ff1/categories`, { headers: { Authorization: `Bearer ${$e}` }, cache: "no-store" }); if (!H.ok) throw new Error("Failed to fetch categories"); const de = (await H.json()).categories || []; y(de); const q = {}; for (const le of de) try { const ve = await fetch(`https://${Re}.supabase.co/functions/v1/make-server-a8898ff1/videos/${le.id}`, { headers: { Authorization: `Bearer ${$e}` }, cache: "no-store" }); if (ve.ok) { const be = await ve.json(), je = Array.isArray(be.videos) ? be.videos : []; q[le.id] = je } else q[le.id] = Kc[le.id] || [] } catch (ve) { console.error(`Error loading videos for category ${le.id}:`, ve), q[le.id] = Kc[le.id] || [] } b(q) } catch (H) { console.error("Error loading categories:", H) } finally { S(!1) } }, L = () => { V.current.forEach(H => clearTimeout(H)), V.current = [] }, F = (H, se) => { const de = setTimeout(() => { V.current = V.current.filter(q => q !== de), H() }, se); return V.current.push(de), de }, K = H => { L(), O("idle"), H?.resetActive && P(null) }, G = H => { if (T || I === "fade-out") return; K({ resetActive: !0 }), P(H), o(H), U(H); const se = Math.max(0, Km - yt); se === 0 ? O("fade-out") : F(() => O("fade-out"), se), F(() => { M("videoList"), P(null), O("fade-in"), F(() => { O("idle") }, yt) }, Km) }, oe = H => { K(), l(H), O("fade-out"), F(() => { M("videoPlayer"), O("fade-in"), F(() => { O("idle") }, yt) }, yt) }, ae = () => { K({ resetActive: !0 }), O("fade-out"), F(() => { M("topics"), o(""), l(null), P(null), O("fade-in"), F(() => { O("idle") }, yt) }, yt) }, ue = () => { K(), O("fade-out"), F(() => { M("videoList"), l(null), O("fade-in"), F(() => { O("idle") }, yt) }, yt) }, te = H => { K(), f(H), O("fade-out"), F(() => { M("adminDashboard"), O("fade-in"), F(() => { O("idle") }, yt) }, yt) }, ne = () => { K({ resetActive: !0 }), f(null), O("fade-out"), F(() => { M("topics"), O("fade-in"), F(() => { O("idle") }, yt) }, yt) }, $ = H => { K({ resetActive: !0 }), m(H), O("fade-out"), F(() => { M("topics"), O("fade-in"), F(() => { O("idle") }, yt) }, yt) }, ee = () => { K({ resetActive: !0 }), m(null), localStorage.removeItem("currentUser"), O("fade-out"), F(() => { M("userLogin"), O("fade-in"), F(() => { O("idle") }, yt) }, yt) }, X = () => E[s] || [], j = () => v.find(H => H.id === s), U = async H => { if (H) try { C(!0); const se = await fetch(`https://${Re}.supabase.co/functions/v1/make-server-a8898ff1/videos/${H}`, { headers: { Authorization: `Bearer ${$e}` }, cache: "no-store" }); if (!se.ok) throw new Error("Failed to fetch videos"); const de = await se.json(), q = Array.isArray(de.videos) ? de.videos : []; b(le => ({ ...le, [H]: q })) } catch (se) { console.error("Error loading videos:", se), b(de => ({ ...de, [H]: Kc[H] || [] })) } finally { C(!1) } }, re = ["page-transition", I === "fade-out" ? "page-transition--fade-out" : "", I === "fade-in" ? "page-transition--fade-in" : ""].filter(Boolean).join(" "); return x.useEffect(() => () => { L() }, []), r === "adminLogin" ? d.jsx(N_, { onLogin: te, onBack: () => t("topics") }) : r === "adminDashboard" ? d.jsx(nN, { admin: u, onLogout: ne }) : r === "userLogin" ? d.jsx(sN, { onLogin: $, onBack: () => t("topics") }) : r === "myPage" ? d.jsx(hN, { videosByCategory: E, onBack: () => t("topics") }) : d.jsxs("div", { className: "min-h-screen flex flex-col bg-background", children: [d.jsx("header", { className: "sticky top-0 z-50 w-full border-b bg-background/95 backdrop-blur supports-[backdrop-filter]:bg-background/60", children: d.jsx("div", { className: "container mx-auto px-4 py-4", children: d.jsx("div", { className: "flex items-center justify-between", children: d.jsxs("div", { className: "flex items-center gap-1", children: [r !== "topics" && d.jsx(Ne, { variant: "ghost", size: "sm", onClick: r === "videoList" ? ae : ue, className: "flex items-center gap-2", children: d.jsx(td, { className: "w-4 h-4" }) }), d.jsxs("div", { className: "flex items-center gap-1", children: [d.jsx("img", { src: Ma, alt: "Logo", className: "w-8 h-8 object-contain self-center" }), d.jsx("h1", { className: "text-xl font-bold", children: "동대문승무사업소 불안제로" })] })] }) }) }) }), d.jsx("main", { className: "flex-1 container mx-auto px-4 py-4", children: d.jsxs("div", { className: re, children: [r === "topics" && d.jsxs("div", { children: [d.jsx("div", { className: "mb-12 text-center", children: d.jsx("div", { className: "mb-6", children: p && d.jsxs("div", { children: [d.jsxs("h1", { className: "text-2xl font-bold mt-4", children: [p.name, "님!"] }), d.jsx("h2", { className: "gemini text-xl mb-4", children: "불안제로에 오신 것을 환영합니다! 👋" }), d.jsx("p", { className: "text-muted-foreground max-w-2xl mx-auto", children: "안전한 지하철을 만들기 위한 학습을 시작해보세요." }), d.jsx("p", { className: "text-muted-foreground max-w-2xl mx-auto", children: "동대문승무사업소 학습동아리가 준비한" }), d.jsx("p", { className: "text-muted-foreground max-w-2xl mx-auto", children: "안전교육영상으로 지금 배워보세요." }), p.isNewUser && d.jsx("div", { className: "mt-4 p-4 bg-primary/10 border border-primary/20 rounded-lg max-w-md mx-auto", children: d.jsx("p", { className: "text-sm text-primary", children: "🎉 처음 방문하신 것을 환영합니다! 학습 진행률이 자동으로 저장됩니다." }) })] }) }) }), p && d.jsx("div", { children: _ ? d.jsx("div", { className: "flex items-center justify-center py-12", children: d.jsxs("div", { className: "text-center", children: [d.jsx("div", { className: "animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600 mx-auto mb-4" }), d.jsx("p", { children: "카테고리를 불러오는 중..." })] }) }) : d.jsx("div", { className: "grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6", children: v.map(H => { const se = T === H.id, de = !!(T && !se), q = `transform transition-all duration-300 ${T ? "cursor-default" : "cursor-pointer hover:scale-[1.03] hover:shadow-2xl"} ${de ? "pointer-events-none opacity-60" : ""}`.trim(); return d.jsx("div", { onClick: () => T ? void 0 : G(H.id), className: q, children: d.jsxs("div", { className: `relative overflow-hidden rounded-2xl p-4 shadow-lg bg-gradient-to-br from-indigo-700 via-fuchsia-600 to-pink-500 focus-card ${se ? "focus-card--active" : ""} ${de ? "focus-card--dimmed" : ""}`.trim(), children: [d.jsx("div", { className: "absolute inset-0 bg-gradient-to-b from-transparent to-black/25 pointer-events-none" }), d.jsx("div", { className: "relative z-10 flex items-center gap-4", children: d.jsxs("div", { className: "flex-1 min-w-0", children: [d.jsx("h3", { className: "text-2xl font-extrabold leading-tight mb-1 bg-clip-text text-transparent bg-gradient-to-r from-yellow-200 via-white to-rose-200 drop-shadow-md", children: H.title }), d.jsxs("div", { className: "flex items-center gap-3", children: [d.jsxs("span", { className: "inline-flex items-center gap-2 px-2 py-1 rounded-full bg-white/10 text-x font-semibold text-white/95", children: [d.jsx(Sa, { className: "w-3 h-3" }), d.jsxs("span", { children: [E[H.id]?.length || 0, "개"] })] }), d.jsx("span", { className: "text-xs px-2 py-1 rounded-md bg-white/5 text-white/90", children: "자세히 보기" })] })] }) })] }) }, H.id) }) }) })] }), r === "videoList" && d.jsxs("div", { children: [d.jsxs("div", { className: "mb-8", children: [d.jsx("h2", { className: "mb-2 text-2xl font-bold", children: j()?.title }), d.jsx("p", { className: "text-muted-foreground", children: j()?.description }), d.jsxs("div", { className: "flex items-center gap-2 mt-4", children: [d.jsx(Sa, { className: "w-4 h-4" }), d.jsxs("span", { className: "text-sm", children: ["총 ", X().length, "개의 영상"] })] })] }), d.jsx("div", { className: "space-y-4", children: X().map(H => d.jsx(Gp, { video: H, onSelect: oe }, H.id)) })] }), r === "videoPlayer" && a && d.jsx("div", { className: "max-w-6xl mx-auto", children: d.jsxs("div", { className: "grid grid-cols-1 lg:grid-cols-3 gap-8", children: [d.jsx("div", { className: "lg:col-span-2 space-y-6", children: d.jsx(k_, { video: a, categoryId: s }) }), d.jsxs("div", { className: "space-y-6", children: [d.jsx(E_, { video: a }), d.jsxs("div", { children: [d.jsx("h3", { className: "mb-4 text-xl ", children: "이 주제의 다른 영상" }), d.jsx("div", { className: "space-y-4", children: X().filter(H => H.id !== a.id).slice(0, 3).map(H => d.jsx(Gp, { video: H, onSelect: oe }, H.id)) })] })] })] }) })] }) }), d.jsx("footer", { className: "w-full mt-4", style: { paddingBottom: "env(safe-area-inset-bottom)" }, children: d.jsx("div", { className: "container mx-auto px-4 flex items-center justify-center", children: d.jsxs("div", { className: "flex items-center gap-3 bg-background/95 backdrop-blur border border-muted/20 rounded-full px-4 py-2 shadow", children: [p ? d.jsx("div", { className: "flex items-center gap-3", children: d.jsxs(Ne, { variant: "outline", size: "sm", onClick: ee, className: "flex items-center gap-2", children: [d.jsx(wg, { className: "w-4 h-4" }), "로그아웃"] }) }) : null, d.jsxs(Ne, { variant: "outline", size: "sm", onClick: () => M("adminLogin"), className: "flex items-center gap-2", children: [d.jsx(xg, { className: "w-4 h-4" }), "관리자"] }), d.jsxs(Ne, { variant: "outline", size: "sm", onClick: () => M("myPage"), className: "flex items-center gap-2", children: [d.jsx(_g, { className: "w-4 h-4" }), "내 페이지"] })] }) }) })] }) } typeof window < "u" && (window.__SUPABASE_PROJECT_ID__ = Re, window.__SUPABASE_ANON_KEY__ = $e); rx.createRoot(document.getElementById("root")).render(d.jsx(mN, {}));
